C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          
   8          //edits - added new
   9          
  10          //Passcode
  11          int k = 0;
  12          char passcode[] = "";
  13          char *ACTUAL = "1457";
  14          
  15          // real time clock
  16          unsigned char seconds_l;
  17          unsigned char minutes_l;
  18          unsigned char hours_l;
  19          unsigned char amPm_l;
  20          unsigned char date_l;
  21          unsigned char month_l;
  22          unsigned char year_l;
  23          unsigned char selection;
  24          unsigned char set;
  25          
  26          const char code *setDateTime[] =  {/*0*/  "SET SECONDS",
  27              /*1*/ "SET MINUTES",
  28              /*2*/ "SET HOURS",
  29              /*3*/ "SET AM/PM",
  30              /*4*/ "SET DATE",
  31              /*5*/ "SET MONTH",
  32              /*6*/ "SET YEAR"};
  33          
  34          
  35          //original code's variables
  36          
  37          unsigned char tsByte;
  38          
  39          bit sliderCommandReceived = 0;
  40          bit splashEnd = 0;
  41          bit screenReset = 0;
  42          bit ackFromScreen = 0;
  43          bit tsCommandReceived = 0;
  44          bit tsCommandTransmitted = 0;
  45          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  46          
  47          unsigned char sharedDataRx[SHARED_DATA_MAX];
  48          unsigned char sharedDataTx[SHARED_DATA_MAX];
  49          unsigned char eepromTx[EEPROM_TX_BUFFER];
  50          unsigned char eepromRx[EEPROM_RX_BUFFER];
  51          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  52          
  53          unsigned int pageCount;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 2   

  54          unsigned int bytesExtra;
  55          unsigned int eepromPageCounter;
  56          unsigned int startAddr;
  57          unsigned char slaveAddr;                                                // Target SMBus slave address
  58          unsigned char eepromDataByte;
  59          
  60          unsigned int numBytesRD;
  61          unsigned int numBytesWR;
  62          unsigned char slaveWriteDone;
  63          unsigned char slaveReadDone;
  64          unsigned char eepromWriteDone;
  65          unsigned char eepromReaddone;
  66          unsigned char rtcWriteDone;
  67          unsigned char rtcReadDone;
  68          
  69          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  70          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  71          unsigned char userCommand[RX_BUFFER_SIZE];
  72          
  73          unsigned int tsRxIn;
  74          unsigned int tsRxOut; 
  75          unsigned int tsTxIn;
  76          unsigned int tsTxOut;
  77          
  78          bit tsRxEmpty;
  79          bit tsTxEmpty;
  80          bit tsLastCharGone; 
  81          
  82          bit screenChanged;
  83          unsigned char screen;
  84          unsigned char lastScreen;
  85          
  86          const char code * Font[] = {/*0*/ "m10B", 
  87              /*1*/ "m12B",
  88              /*2*/ "m14B",
  89              /*3*/ "m16B",
  90              /*4*/ "m20B",
  91              /*5*/ "m24B",
  92              /*6*/ "m32B",
  93              /*7*/ "m48",
  94              /*8*/ "m64"};
  95          
  96          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  97          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  98          
  99          unsigned int startAddr;
 100          unsigned char slaveAddr;                                                // Target SMBus slave address
 101          
 102          unsigned int numBytesRD;
 103          unsigned int numBytesWR;
 104          
 105          unsigned char slaveWriteDone;
 106          unsigned char slaveReadDone;
 107          
 108          unsigned char roomTemp1;
 109          unsigned char roomTemp2;
 110          unsigned char roomTemp3;
 111          
 112          unsigned char seconds;
 113          unsigned char minutes;
 114          unsigned char hours;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 3   

 115          unsigned char hours24;
 116          unsigned char amPm;
 117          unsigned char day;
 118          unsigned char date;
 119          unsigned char month;
 120          unsigned char year;
 121          unsigned char century;
 122          unsigned char timeMode;
 123          unsigned char currentIndex = 0;
 124          unsigned char minuteIndex = 0;
 125          unsigned char hourIndex = 0;
 126          
 127          unsigned char currentDate;
 128          unsigned char currentMonth;
 129          unsigned char currentYear;
 130          
 131          unsigned char realTimeClockItems;
 132          
 133          unsigned char adjustedSeconds;
 134          unsigned char adjustedMinutes;
 135          unsigned char adjustedHours;
 136          unsigned char adjustedAmPm;
 137          unsigned char adjustedDay;
 138          unsigned char adjustedDate;
 139          unsigned char adjustedMonth;
 140          unsigned char adjustedYear;
 141          unsigned char adjustedCentury;
 142          unsigned char adjustedTimeMode;
 143          
 144          bit monthUpdated;
 145          bit dateUpdated;
 146          bit yearUpdated;
 147          bit hoursUpdated;
 148          bit minutesUpdated;
 149          bit secondsUpdated;
 150          bit amPmUpdated;
 151          bit timeUpdated;
 152          bit monthDateYearUpdated;
 153          
 154          const char code * dayOfWeek[] =   {/*0*/  "NON",
 155              /*1*/ "SUN",
 156              /*2*/ "MON",
 157              /*3*/ "TUE",
 158              /*4*/ "WED",
 159              /*5*/ "THU",
 160              /*6*/ "FRI",
 161              /*7*/ "SAT"};
 162          
 163          const char code * monthOfYear[] =   {/*0*/  "NON",
 164              /*1*/ "JAN",
 165              /*2*/ "FEB",
 166              /*3*/ "MAR",
 167              /*4*/ "APR",
 168              /*5*/ "MAY",
 169              /*6*/ "JUN",
 170              /*7*/ "JUL",
 171              /*8*/ "AUG",
 172              /*9*/ "SEP",
 173              /*10*/  "OCT",
 174              /*11*/  "NOV",
 175              /*12*/  "DEC"};
 176          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 4   

 177          
 178          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 179              /*1*/ "WRITING DATA... WAIT!  ",
 180              /*2*/ "DATA SUCCESSFULLY SAVED",
 181              /*3*/ "ERROR                  "};
 182          
 183          //-------------------------------------------------------------------------------------------------------
 184          // System Configurations
 185          //-------------------------------------------------------------------------------------------------------
 186          void systemClockInit(void)
 187          {
 188   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 189   1          int i = 0;
 190   1          
 191   1          SFRPAGE  = CONFIG_PAGE;
 192   1          
 193   1          OSCICN    = 0x83;
 194   1          
 195   1          SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 196   1      }
 197          
 198          void portInit(void)
 199          {
 200   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 201   1          
 202   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
 203   1          
 204   1          XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4
 205   1          XBR1 = 0x01;
 206   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up
 207   1          
 208   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 209   1          // TX0 = P0.0; RX0 = P0.1
 210   1          P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 211   1          // TX1 = P1.0; RX1 = P1.1
 212   1          P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pul
             -l
 213   1          
 214   1          P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 215   1          
 216   1          P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 217   1          
 218   1          P6MDOUT = 0x00;
 219   1          
 220   1          P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 221   1          
 222   1          P0 = 0xFF;                                  // Initialize port P0 latch
 223   1          P1 = 0xFF;                                  // Initialize port P1 latch
 224   1          P2 = 0xFF;                                  // Initialize port P2 latch
 225   1          P3 = 0xFF;                                  // Initialize port P3 latch
 226   1          P4 = 0xFF;                                  // Initialize port P4 latch
 227   1          P5 = 0xFF;                                  // Initialize port P5 latch
 228   1          P6 = 0xFF;                                  // Initialize port P6 latch
 229   1          P7 = 0xFF;                                  // Initialize port P7 latch
 230   1          
 231   1          RHW = 0;                                  // Pull low SMB error line
 232   1          
 233   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 234   1      }
 235          
 236          void enableInterrupts(void)
 237          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 5   

 238   1          IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 239   1          EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 240   1          EIE2 |= 0x40;                               // Enable UART1 interrupt
 241   1          EIE1 |= 0x0A;                               // Enable SMBus interrupt
 242   1      }
 243          
 244          void uart0Init(void)
 245          {
 246   1          char SFRPAGE_SAVE;
 247   1          
 248   1          SFRPAGE_SAVE = SFRPAGE;                                             // Preserve SFRPAGE
 249   1          
 250   1          SFRPAGE = TMR2_PAGE;
 251   1          TMR2CN = 0x00;                                                      // Stop timer. Timer 2 in 16-bit auto
             --reload up timer mode
 252   1          TMR2CF = 0x08;                                                      // SYSCLK is time base; no output; up
             - count only
 253   1          RCAP2L = 0xF3;                                                               // Low byte
 254   1          RCAP2H = 0xFF;                                                               // High byte
 255   1          TMR2 = RCAP2;                                                                // Load 16 bit reload val
             -ue into timer 2
 256   1          TMR2CN = 0x04;                                                               // Enable timer 2 (Start 
             -timer 2)
 257   1          
 258   1          SFRPAGE = UART0_PAGE;
 259   1          SCON0 = 0x50;                                                       // 8-bit variable baud rate; 9th bit 
             -ignored; RX enabled
 260   1          SSTA0 = 0x05;                                                       // Enable baud rate
 261   1          // Use timer 2 as RX and TX baud rate source
 262   1          IE = 0x90;                                                                   // Enable all interrupts 
             -and UART0 Interrupt
 263   1          
 264   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 265   1      }
 266          
 267          void disableWatchdog(void)
 268          {
 269   1          WDTCN = 0xDE;                                               // Disable watchdog timer
 270   1          WDTCN = 0xAD;
 271   1      }
 272          
 273          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 274          {
 275   1          char SFRPAGE_SAVE = SFRPAGE;
 276   1          unsigned int i = 0;
 277   1          unsigned long txWaitCounter = 0;
 278   1          
 279   1          SFRPAGE = UART0_PAGE;
 280   1          
 281   1          if(RI0 == 1)                                                        // There is a char in SBUF
 282   1          {
 283   2              RI0 = 0;                                                    // Clear interrupt flag
 284   2              
 285   2              tsByte = SBUF0;                                             // Read a character from UART
 286   2              
 287   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 288   2              {
 289   3                  if(tsByte != '\r')                          // Check end of a command from touch screen
 290   3                  {
 291   4                      tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 292   4                      tsRxIn++;                           // Increment index
 293   4                  }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 6   

 294   3                  else                                // If it is CR character, it marks end of command
 295   3                  {
 296   4                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 297   4                      {
 298   5                          if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[
             -4] == 'e' && tsRxBuffer[5] == '}')
 299   5                          {
 300   6                              splashEnd = 1;                                        // Detect end of splash scree
             -n
 301   6                              screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 302   6                          }
 303   5                          else
 304   5                          {
 305   6                              splashEnd = 0;                                          // End of splash screen NO
             -T detected
 306   6                              screenReset = 0;
 307   6                          }
 308   5                      }
 309   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 310   4                      {                                                               // A command starts with '
             -('
 311   5                          for(i = 0; i < tsRxIn; i++)
 312   5                          {
 313   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 314   6                          }
 315   5                          
 316   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 317   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 318   5                      }
 319   4                      else if (tsRxBuffer[0] == 'l')
 320   4                      {
 321   5                          for(i = 0; i < tsRxIn; i++)
 322   5                          {
 323   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 324   6                          }
 325   5                          sliderCommandReceived = 1;
 326   5      
 327   5                      }
 328   4                      else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 329   4                      {                               // A command starts with '('
 330   5                          for(i = 0; i < tsRxIn; i++)
 331   5                          {
 332   6                              userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluatio
             -n
 333   6                          }
 334   5                          
 335   5                          ackFromScreen = 0;                      // This is a command, NOT an ACK
 336   5                          tsCommandReceived = 1;                    // Set flag when a complete command is received
 337   5                      }
 338   4                      else                              // Not a command from touch screen controller
 339   4                      {
 340   5                          ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 341   5                          tsCommandReceived = 0;                    // No need to set flag because it is not a command
 342   5                      }
 343   4                      
 344   4                      for(i = 0; i < tsRxIn; i++)
 345   4                      {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 7   

 346   5                          tsRxBuffer[i] = '\0';                   // Delete all contents
 347   5                      }
 348   4                      
 349   4                      tsRxOut = 0;                          // Reset index Out
 350   4                      tsRxIn = 0;                           // Reset index In
 351   4                  }
 352   3              }
 353   2              else                                  // Reset all indexes
 354   2              {
 355   3                  while(tsRxOut < tsRxIn)
 356   3                  {
 357   4                      tsRxBuffer[tsRxOut] = '\0';
 358   4                      tsRxOut++;
 359   4                  }
 360   3                  tsRxOut = 0;
 361   3                  tsRxIn = 0;
 362   3                  tsCommandReceived = 0;
 363   3              }
 364   2          }
 365   1          
 366   1          if(TI0 == 1)                                                // Check if one character is successfully sent out
 367   1          {
 368   2              TI0 = 0;                                                    // Clear interrupt flag
 369   2              
 370   2              if(tsTxEmpty == 0)                            // TX buffer has something to send
 371   2              {
 372   3                  SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 373   3                  tsTxOut++;                              // Move to next character
 374   3                  
 375   3                  while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmissi
             -on TI0 = 1
 376   3                  if(txWaitCounter >= TX_WAIT_LIMIT)
 377   3                  {
 378   4                      TI0 = 1;                            // TI0 is not set by hardware, set it by software
 379   4                  }                                 // When TI0 is set to 1, this ISR is executed again
 380   3                  
 381   3                  txWaitCounter = 0;                          // Reset counter for next execution
 382   3                  
 383   3                  if(tsTxOut >= TX_BUFFER_SIZE)
 384   3                  {
 385   4                      tsTxOut = 0;                          // Reset index to 0
 386   4                  }
 387   3                  
 388   3                  if(tsTxOut == tsTxIn)                       // If two indexes are equal
 389   3                  {
 390   4                      tsTxEmpty = 1;                          // No more character in buffer. Empty
 391   4                  }
 392   3              }
 393   2              else
 394   2              {
 395   3                  tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 396   3              }
 397   2          }
 398   1          
 399   1          SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 400   1      }
 401          
 402          //-------------------------------------------------------------------------------------------------------
 403          // Function Name: sendCommand
 404          // Return Value: None 
 405          // Parmeters: s (a string to send)
 406          // Function Description: This function sends a command from the touch screen
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 8   

 407          //-------------------------------------------------------------------------------------------------------
 408          void sendCommand(const char * s)
 409          { 
 410   1          char SFRPAGE_SAVE = SFRPAGE;
 411   1          
 412   1          while(*s != '\0')                             // Search for end of touch screen command in buffer
 413   1          {
 414   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 415   2              {
 416   3                  tsTxBuffer[tsTxIn++] = *s;
 417   3                  if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 418   3                  {
 419   4                      tsTxIn = 0;                           // Reset if limit reached
 420   4                  }
 421   3                  
 422   3                  if(tsTxEmpty == 1)                          // If buffer is empty
 423   3                  {
 424   4                      tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 425   4                  }
 426   3              }
 427   2              
 428   2              s++;                                  // Point to next char to send out
 429   2          }
 430   1          
 431   1          if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 432   1          {
 433   2              tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 434   2              SFRPAGE = UART0_PAGE;
 435   2              TI0 = 1;                                                            // Set this flage to call ISR to
             - send out one character
 436   2          }
 437   1          
 438   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 439   1      }
 440          
 441          //-------------------------------------------------------------------------------------------------------
 442          // Function Name: displayText
 443          // Return Value: None 
 444          // Parmeters: fg, bg, size, message, x, y
 445          // Function Description: This function displays a text on the touch screen
 446          //-------------------------------------------------------------------------------------------------------
 447          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 448          {
 449   1          char str[TS_BUFFER_SIZE] = { 0 };                         // String
 450   1          
 451   1          sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 452   1          sendCommand(str);
 453   1          sprintf(str, "f %s\r", Font[size]);                     // Set text font
 454   1          sendCommand(str);
 455   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
 456   1          sendCommand(str);
 457   1      }
 458          
 459          //-------------------------------------------------------------------------------------------------------
 460          // Function Name: showBitmap
 461          // Return Value: None 
 462          // Parmeters: index, x, y (bitmap index and coordinates)
 463          // Function Description: This function displays a bitmap image
 464          //-------------------------------------------------------------------------------------------------------
 465          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 466          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 9   

 467   1          char str[TS_BUFFER_SIZE];
 468   1          
 469   1          sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 470   1          sendCommand(str);
 471   1      }
 472          
 473          //-------------------------------------------------------------------------------------------------------
 474          // Function Name: changeScreen
 475          // Return Value: None 
 476          // Parmeters: screenIndex (macro number)
 477          // Function Description: This function switches to the new screen
 478          //-------------------------------------------------------------------------------------------------------
 479          void changeScreen(const unsigned char screenIndex)
 480          {
 481   1          callMacro(screenIndex);                           // Change screen
 482   1      }
 483          
 484          //-------------------------------------------------------------------------------------------------------
 485          // Function Name: callMacro
 486          // Return Value: None 
 487          // Parmeters: macroNumber (macro number in the macro file)
 488          // Function Description: This function calls a macro
 489          //-------------------------------------------------------------------------------------------------------
 490          void callMacro(const unsigned int macroNumber)
 491          {
 492   1          char str[TS_BUFFER_SIZE];
 493   1          
 494   1          sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 495   1          sendCommand(str);
 496   1      }
 497          
 498          //-------------------------------------------------------------------------------------------------------
 499          // Function Name: scanUserInput
 500          // Return Value: None 
 501          // Parmeters: None
 502          // Function Description: This function processes commands from the touch screen
 503          //-------------------------------------------------------------------------------------------------------
 504          void scanUserInput(void)
 505          { 
 506   1          int i = 0;
 507   1          
 508   1          if(screen == MAIN_PAGE)                           // Main screen
 509   1          {
 510   2              if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 511   2              {
 512   3                  switch (userCommand[1])                         // Scan a command type
 513   3                  {
 514   4                      case '1':                           // Main page
 515   4                          changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 516   4                          break;
 517   4                      case '2':                           // Settings page
 518   4                          changeScreen(SETTINGS_PAGE);
 519   4                          break;
 520   4                      case '3':                             // Service page
 521   4                          changeScreen(SERVICE_PAGE);
 522   4                          break;
 523   4                      case 'A':
 524   4                          // Call a function here or do something here
 525   4                          break;
 526   4                      case 'B':
 527   4                          // Call a function here or do something here
 528   4                          break;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 10  

 529   4                      case 'C':
 530   4                          // Call a function here or do something here
 531   4                          break;
 532   4                      default:                            // Other options
 533   4                          break;
 534   4                  }
 535   3              }
 536   2              else                                  // Not a command, empty buffer with null char
 537   2              {
 538   3                  i = 0;
 539   3                  while(userCommand[i] != '\0')
 540   3                  {
 541   4                      userCommand[i] = '\0';
 542   4                      i++;
 543   4                  }
 544   3              }
 545   2          }
 546   1          else if(screen == SETTINGS_PAGE)                      // Settings page
 547   1          {
 548   2              if(userCommand[0] == '(')
 549   2              {
 550   3                  switch (userCommand[1])
 551   3                  {
 552   4                      case '1':
 553   4                          changeScreen(MAIN_PAGE);
 554   4                          break;
 555   4                      case '2':
 556   4                          changeScreen(SETTINGS_PAGE);
 557   4                          break;
 558   4                      case '3':
 559   4                          changeScreen(SERVICE_PAGE);
 560   4                          break;
 561   4                      case 'A':
 562   4                          // Call a function here or do something here
 563   4                          break;
 564   4                      case 'B':
 565   4                          // Call a function here or do something here
 566   4                          break;
 567   4                      case 'C':
 568   4                          // Call a function here or do something here
 569   4                          break;
 570   4                      default:
 571   4                          break;
 572   4                  }
 573   3              }
 574   2              else                                  // Not a command, empty buffer with null
 575   2              {
 576   3                  i = 0;
 577   3                  while(userCommand[i] != '\0')
 578   3                  {
 579   4                      userCommand[i] = '\0';
 580   4                      i++;
 581   4                  }
 582   3              }
 583   2          }
 584   1          else if(screen == SERVICE_PAGE)
 585   1          {
 586   2              if(userCommand[0] == '(')
 587   2              {
 588   3                  switch (userCommand[1])
 589   3                  {
 590   4                      case '1':
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 11  

 591   4                          changeScreen(MAIN_PAGE);
 592   4                          break;
 593   4                      case '2':
 594   4                          changeScreen(SETTINGS_PAGE);
 595   4                          break;
 596   4                      case '3':
 597   4                          changeScreen(SERVICE_PAGE);
 598   4                          break;
 599   4                      case 'A':
 600   4                          // Call a function here or do something here
 601   4                      case 'B':
 602   4                          // Call a function here or do something here
 603   4                      case 'C':
 604   4                          // Call a function here or do something here
 605   4                      default:
 606   4                          break;
 607   4                  }
 608   3              }
 609   2              else                                  // Not a command, empty buffer with null
 610   2              {
 611   3                  i = 0;
 612   3                  while(userCommand[i] != '\0')
 613   3                  {
 614   4                      userCommand[i] = '\0';
 615   4                      i++;
 616   4                  }
 617   3              }
 618   2          }
 619   1          else
 620   1          {
 621   2              
 622   2          }
 623   1          
 624   1          i = 0;
 625   1          while(userCommand[i] != '\0')
 626   1          {
 627   2              userCommand[i] = '\0';                          // Delete all contents in array
 628   2              i++;
 629   2          }
 630   1      }
 631          
 632          //-------------------------------------------------------------------------------------------------------
 633          // Function Name: smbInit
 634          // Return Value: None 
 635          // Parmeters: None
 636          // Function Description: This function initializes the SMB bus 
 637          //-------------------------------------------------------------------------------------------------------
 638          void smbInit(void)
 639          {
 640   1          int i;
 641   1          unsigned long pollingCounter = 0;
 642   1          char SFRPAGE_SAVE = SFRPAGE;
 643   1          
 644   1          SFRPAGE = SMB0_PAGE;
 645   1          while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because o
             -f error or reset
 646   1          {
 647   2              SCL = 0;                                                          // Drive the clock low
 648   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 649   2              SCL = 1;                                                          // Release the clock
 650   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
 651   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 12  

 652   2          }
 653   1          
 654   1          SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 655   1          // Enable SMBus Free timeout detect;
 656   1          SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and 
             -Thigh equations
 657   1          
 658   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 659   1          
 660   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 661   1          
 662   1          SMB_BUSY = 0;
 663   1          // Release SMB
 664   1          slaveWriteDone = FALSE;
 665   1          slaveReadDone = FALSE;
 666   1          eepromWriteDone = FALSE;
 667   1          eepromReadDone = FALSE;
 668   1          rtcWriteDone = FALSE;
 669   1          rtcReadDone = FALSE;
 670   1      }
 671          
 672          //-------------------------------------------------------------------------------------------------------
 673          // Function Name: timer3Init
 674          // Return Value: None 
 675          // Parmeters: None
 676          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 677          //-------------------------------------------------------------------------------------------------------
 678          void timer3Init (void)
 679          {
 680   1          char SFRPAGE_SAVE = SFRPAGE;
 681   1          
 682   1          SFRPAGE = TMR3_PAGE;
 683   1          
 684   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 685   1          // Timer 3 auto reload
 686   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 687   1          
 688   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 689   1          TMR3 = RCAP3;
 690   1          
 691   1          TR3 = 1;                                                            // Start Timer 3
 692   1          
 693   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 694   1      }
 695          
 696          //-------------------------------------------------------------------------------------------------------
 697          // Function Name: timer3ISR
 698          // Return Value: None 
 699          // Parmeters: None
 700          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 701          //-------------------------------------------------------------------------------------------------------
 702          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 703          {
 704   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 705   1          
 706   1          SFRPAGE = SMB0_PAGE;
 707   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 708   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 709   1          
 710   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 13  

 711   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 712   1          SMB_BUSY = 0;                                                       // Free bus
 713   1          
 714   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 715   1      }
 716          
 717          //-------------------------------------------------------------------------------------------------------
 718          // Function Name: writeOneByteToSlave
 719          // Return Value: None 
 720          // Parmeters: target, startAddr, content
 721          // Function Description: This function writes one to the slave microprocessor
 722          //-------------------------------------------------------------------------------------------------------
 723          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 724          {       
 725   1          sharedDataTx[startAddr] = content;
 726   1          smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 727   1      }
 728          
 729          //-------------------------------------------------------------------------------------------------------
 730          // Function Name: readOneByteFromSlave
 731          // Return Value: long 
 732          // Parmeters: startAddr, bytes
 733          // Function Description: This function reads one from the slave microprocessor
 734          //-------------------------------------------------------------------------------------------------------
 735          unsigned char readOneByteFromSlave(unsigned char startAddr)
 736          {
 737   1          smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 738   1          return sharedDataRx[startAddr];
 739   1      }
 740          
 741          //-------------------------------------------------------------------------------------------------------
 742          // Function Name: writeBytesToRealTimeClock
 743          // Return Value: None 
 744          // Parmeters: target, startAddr, bytes
 745          // Function Description: This function writes data byte to the real time clock DS3232
 746          //-------------------------------------------------------------------------------------------------------
 747          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 748          {
 749   1          smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 750   1      }
 751          
 752          //-------------------------------------------------------------------------------------------------------
 753          // Function Name: readBytesFromRealTimeClock
 754          // Return Value: None 
 755          // Parmeters: target, startAddr, bytes
 756          // Function Description: This function reads data byte from the real time clock DS3232
 757          //-------------------------------------------------------------------------------------------------------
 758          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 759          {
 760   1          smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 761   1      }
 762          
 763          //-------------------------------------------------------------------------------------------------------
 764          // Function Name: smbRead
 765          // Return Value: unsigned char * 
 766          // Parmeters: target, startAddr, bytes
 767          // Function Description: This function reads from SM bus
 768          //-------------------------------------------------------------------------------------------------------
 769          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 770          {
 771   1          char SFRPAGE_SAVE = SFRPAGE;
 772   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 14  

 773   1          SFRPAGE = SMB0_PAGE;
 774   1          
 775   1          while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 776   1          
 777   1          SFRPAGE = SFRPAGE_SAVE;
 778   1          
 779   1          switch(deviceId)
 780   1          {
 781   2              case MCU_SLAVE_ADDR:
 782   2              case REAL_TIME_CLOCK_ADDR:
 783   2              case EEPROM_ADDR:
 784   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 785   2                  break;
 786   2              default:
 787   2                  break;
 788   2          }
 789   1          
 790   1          SFRPAGE = SMB0_PAGE;
 791   1          
 792   1          while(BUSY || SMB_BUSY);
 793   1          slaveAddr = deviceId;                                                     // Address of MCU slave
 794   1          startAddr = location;                                 // Starting address to read from slave
 795   1          numBytesRD = bytes;                                   // Number of bytes to read
 796   1          
 797   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
 798   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
 799   1          STA = 1;
 800   1          
 801   1          while(BUSY || SMB_BUSY);                                                    // Wait for SMB
 802   1          
 803   1          SFRPAGE = SFRPAGE_SAVE;
 804   1          
 805   1          switch(deviceId)
 806   1          {
 807   2              case MCU_SLAVE_ADDR:
 808   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
 809   2                  break;
 810   2              case REAL_TIME_CLOCK_ADDR:
 811   2                  while(rtcReadDone == 0);                                            // Wait until real time cloc
             -k write completed or timeout occurs
 812   2                  break;
 813   2              case EEPROM_ADDR:
 814   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
 815   2                  break;
 816   2              default:
 817   2                  break;
 818   2          }
 819   1      }
 820          
 821          //-------------------------------------------------------------------------------------------------------
 822          // Function Name: smbWrite
 823          // Return Value: unsigned char * 
 824          // Parmeters: target, startAddr, bytes
 825          // Function Description: This function reads to SM bus
 826          //-------------------------------------------------------------------------------------------------------
 827          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 828          {
 829   1          unsigned char i = 0;
 830   1          unsigned int pageWrittenDelay = 0;
 831   1          char SFRPAGE_SAVE = SFRPAGE;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 15  

 832   1          
 833   1          SFRPAGE = SMB0_PAGE;
 834   1          
 835   1          while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
 836   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
 837   1          startAddr = location;                               // Starting address to write to slave
 838   1          
 839   1          switch(deviceId)
 840   1          {
 841   2              case MCU_SLAVE_ADDR:                              // Pass through
 842   2              case DEVICE_DUMP_ADDR:                              // Pass through
 843   2                  numBytesWR = bytes;                             // Number of bytes to read
 844   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 845   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 846   2                  STA = 1;                                                          // Start transfer
 847   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 848   2                  break;
 849   2              case REAL_TIME_CLOCK_ADDR:
 850   2                  numBytesWR = bytes;                             // Number of bytes to read
 851   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 852   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 853   2                  STA = 1;                                                          // Start transfer
 854   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
 855   2                  break;
 856   2              default:
 857   2                  break;
 858   2          }
 859   1          
 860   1          SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
 861   1      }
 862          
 863          //-------------------------------------------------------------------------------------------------------
 864          // Function Name: smbISR
 865          // Return Value: None 
 866          // Parmeters: None
 867          // Function Description: 
 868          // SMBus Interrupt Service Routine (ISR)
 869          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 870          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 871          //-------------------------------------------------------------------------------------------------------
 872          void smbISR (void) interrupt INTERRUPT_SMB using 2
 873          {
 874   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
 875   1          static unsigned int TxCounter;                          // Initialize counter
 876   1          static unsigned int RxCounter;                          // Initialize counter
 877   1          static unsigned int slaveCount = 0;
 878   1          static unsigned int realTimeClockCount = 0;
 879   1          static unsigned int eepromCount = 0;
 880   1          static unsigned char eepromAddrDone;
 881   1          
 882   1          switch (SMB0STA >> 3)                             // Check SMB bus status
 883   1          {
 884   2                  //--------------------------------------------------------------------------------------------
             ------------
 885   2                  // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device ad
             -dress
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 16  

 886   2                  //--------------------------------------------------------------------------------------------
             ------------
 887   2              case SMB_START:                               // Master initiates a transfer
 888   2                  
 889   2                  //--------------------------------------------------------------------------------------------
             ------------
 890   2                  // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave 
             -device address
 891   2                  //--------------------------------------------------------------------------------------------
             ------------
 892   2              case SMB_REPEAT_START:
 893   2                  SMB0DAT = slaveAddr;                                            // Load address of the slave.
 894   2                  SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for t
             -he R/W bit
 895   2                  SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
 896   2                  STA = 0;                                                      // Manually clear STA bit
 897   2                  
 898   2                  RxCounter = 0;                                                // Reset the counter
 899   2                  TxCounter = 0;                                                // Reset the counter
 900   2                  eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address
 901   2                  
 902   2                  break;
 903   2                  
 904   2                  //--------------------------------------------------------------------------------------------
             ------------
 905   2                  // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 906   2                  // For a WRITE: Send the first data byte to the slave
 907   2                  //--------------------------------------------------------------------------------------------
             ------------
 908   2              case SMB_ADDR_W_TX_ACK_RX:
 909   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 910   2                  {
 911   3                      if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence o
             -nly
 912   3                      {
 913   4                          STO = 1;                            // Stop this transfer
 914   4                          SMB_BUSY = 0;                         // Releas SMB
 915   4                      }
 916   3                      else
 917   3                      {
 918   4                          SMB0DAT = startAddr;                      // Send 1 byte address to slave
 919   4                          slaveWriteDone = 0;                       // Mark start of slave write
 920   4                      }
 921   3                  }
 922   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 923   2                  {
 924   3                      SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
 925   3                      rtcWriteDone = 0;                         // Mark start of rtc write
 926   3                  }
 927   2                  else{}
 928   2                  break;
 929   2                  
 930   2                  //--------------------------------------------------------------------------------------------
             ------------
 931   2                  // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 932   2                  //--------------------------------------------------------------------------------------------
             ------------
 933   2              case SMB_ADDR_W_TX_NACK_RX:
 934   2                  if(slaveAddr == MCU_SLAVE_ADDR || slaveAddr == WAVEFORM_GEN_ADDR )
 935   2                  {
 936   3                      if(slaveCount < MAX_NACK_RETRY)
 937   3                      {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 17  

 938   4                          slaveCount++;                         // Increment number of attempts when NACK is received
 939   4                          STA = 1;                            // Restart a new transfer
 940   4                      }
 941   3                      else
 942   3                      {
 943   4                          slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
 944   4                          slaveWriteDone = 1;
 945   4                          STO = 1;
 946   4                          SMB_BUSY = 0;
 947   4                          FAIL = 1;
 948   4                      }
 949   3                  }
 950   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 951   2                  {
 952   3                      if(realTimeClockCount < MAX_NACK_RETRY)
 953   3                      {
 954   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
 955   4                          STA = 1;                            // Restart a new transfer
 956   4                      }
 957   3                      else
 958   3                      {
 959   4                          realTimeClockCount = 0;
 960   4                          rtcWriteDone = 1;
 961   4                          STO = 1;
 962   4                          SMB_BUSY = 0;
 963   4                          FAIL = 1;
 964   4                      }
 965   3                  }
 966   2                  else if(slaveAddr == EEPROM_ADDR)
 967   2                  {
 968   3                      if(eepromCount < MAX_NACK_RETRY)
 969   3                      {
 970   4                          eepromCount++;                          // Increment number of attempts when NACK is received
 971   4                          STA = 1;                            // Restart a new transfer
 972   4                      }
 973   3                      else
 974   3                      {
 975   4                          eepromCount = 0;
 976   4                          eepromWriteDone = 1;
 977   4                          STO = 1;
 978   4                          SMB_BUSY = 0;
 979   4                          FAIL = 1;
 980   4                      }
 981   3                  }
 982   2                  else
 983   2                  {}
 984   2                  
 985   2                  break;
 986   2                  
 987   2                  //--------------------------------------------------------------------------------------------
             ------------
 988   2                  //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 989   2                  //For a WRITE: Send all data.  After the last data byte, send the stop bit
 990   2                  //--------------------------------------------------------------------------------------------
             ------------
 991   2              case SMB_DATA_TX_ACK_RX:
 992   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 993   2                  {
 994   3                      if(TxCounter < numBytesWR)
 995   3                      {
 996   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
 997   4                          TxCounter++;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 18  

 998   4                      }
 999   3                      else
1000   3                      {
1001   4                          STO = 1;                                                // Set STO to terminate transfer
1002   4                          SMB_BUSY = 0;                                           // And free SMBus interface
1003   4                          slaveWriteDone = 1;                       // Mark end of slave write
1004   4                      }
1005   3                  }
1006   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1007   2                  {
1008   3                      if(TxCounter < numBytesWR)
1009   3                      {
1010   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1011   4                          TxCounter++;
1012   4                      }
1013   3                      else
1014   3                      {
1015   4                          STO = 1;                                                // Set STO to terminate transfer
1016   4                          SMB_BUSY = 0;                                           // And free SMBus interface
1017   4                          rtcWriteDone = 1;                       // Mark end of slave write
1018   4                      }
1019   3                  }
1020   2                  break;
1021   2                  
1022   2                  //--------------------------------------------------------------------------------------------
             ------------
1023   2                  // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1024   2                  //--------------------------------------------------------------------------------------------
             ------------
1025   2              case SMB_DATA_TX_NACK_RX:
1026   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1027   2                  {
1028   3                      if(slaveCount < MAX_NACK_RETRY)
1029   3                      {
1030   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1031   4                          STA = 1;                            // Restart a new transfer
1032   4                      }
1033   3                      else
1034   3                      {
1035   4                          slaveCount = 0;
1036   4                          STO = 1;
1037   4                          SMB_BUSY = 0;
1038   4                          FAIL = 1;
1039   4                      }
1040   3                  }
1041   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1042   2                  {
1043   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1044   3                      {
1045   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1046   4                          STA = 1;                            // Restart a new transfer
1047   4                      }
1048   3                      else
1049   3                      {
1050   4                          realTimeClockCount = 0;
1051   4                          STO = 1;
1052   4                          SMB_BUSY = 0;
1053   4                          FAIL = 1;
1054   4                      }
1055   3                  }
1056   2                  else if(slaveAddr == EEPROM_ADDR)
1057   2                  {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 19  

1058   3                      if(eepromCount < MAX_NACK_RETRY)
1059   3                      {
1060   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1061   4                          STA = 1;                            // Restart a new transfer
1062   4                      }
1063   3                      else
1064   3                      {
1065   4                          eepromCount = 0;
1066   4                          STO = 1;
1067   4                          SMB_BUSY = 0;
1068   4                          FAIL = 1;
1069   4                      }
1070   3                  }
1071   2                  else
1072   2                  {}
1073   2                  break;
1074   2                  
1075   2                  //--------------------------------------------------------------------------------------------
             ------------
1076   2                  // Master Receiver: Slave address + READ transmitted.  ACK received.
1077   2                  // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1078   2                  // is received to end the transfer. if not, set the ACK and receive the other data bytes
1079   2                  //--------------------------------------------------------------------------------------------
             ------------
1080   2              case SMB_ADDR_R_TX_ACK_RX:
1081   2                  if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1082   2                  {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1083   3                      AA = 0;                                                   // Clear AA flag before data byte is 
             -received
1084   3                      // send NACK signal to slave after byte is received
1085   3                  }
1086   2                  else
1087   2                  {
1088   3                      AA = 1;                                                   // More than one byte in this transfe
             -r,
1089   3                      // send ACK after byte is received
1090   3                  }
1091   2                  break;
1092   2                  
1093   2                  //--------------------------------------------------------------------------------------------
             ------------
1094   2                  // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1095   2                  //--------------------------------------------------------------------------------------------
             ------------
1096   2              case SMB_ADDR_R_TX_NACK_RX:
1097   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1098   2                  {
1099   3                      if(slaveCount < MAX_NACK_RETRY)
1100   3                      {
1101   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1102   4                          STA = 1;                            // Restart transfer after receiving a NACK
1103   4                      }
1104   3                      else
1105   3                      {
1106   4                          slaveCount = 0;                         // Reset counter
1107   4                          STO = 1;
1108   4                          SMB_BUSY = 0;
1109   4                          FAIL = 1;
1110   4                      }
1111   3                  }
1112   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1113   2                  {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 20  

1114   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1115   3                      {
1116   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1117   4                          STA = 1;                            // Restart a new transfer
1118   4                      }
1119   3                      else
1120   3                      {
1121   4                          realTimeClockCount = 0;
1122   4                          STO = 1;
1123   4                          SMB_BUSY = 0;
1124   4                          FAIL = 1;
1125   4                      }
1126   3                  }
1127   2                  else if(slaveAddr == EEPROM_ADDR)
1128   2                  {
1129   3                      if(eepromCount < MAX_NACK_RETRY)
1130   3                      {
1131   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1132   4                          STA = 1;                            // Restart a new transfer
1133   4                      }
1134   3                      else
1135   3                      {
1136   4                          eepromCount = 0;
1137   4                          STO = 1;
1138   4                          SMB_BUSY = 0;
1139   4                          FAIL = 1;
1140   4                      }
1141   3                  }
1142   2                  else
1143   2                  {}
1144   2                  break;
1145   2                  
1146   2                  //--------------------------------------------------------------------------------------------
             ------------
1147   2                  // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1148   2                  // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and se
             -t the STOP bit
1149   2                  //--------------------------------------------------------------------------------------------
             ------------
1150   2              case SMB_DATA_RX_ACK_TX:
1151   2                  
1152   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1153   2                  {
1154   3                      if (RxCounter < numBytesRD)
1155   3                      {
1156   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1157   4                          AA = 1;                                                 // Send ACK to indicate byte recei
             -ved
1158   4                          RxCounter++;                                            // Increment the byte counter
1159   4                          slaveReadDone = 0;                        // Mark start of slave read
1160   4                      }
1161   3                      else
1162   3                      {
1163   4                          AA = 0;                                                 // Send NACK to indicate last byte
             - is received
1164   4                          slaveReadDone = 1;                        // Mark end of slave read
1165   4                      }
1166   3                  }
1167   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1168   2                  {
1169   3                      if(RxCounter < numBytesRD)
1170   3                      {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 21  

1171   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1172   4                          rtcReadDone = 0;
1173   4                          
1174   4                          AA = 1;                             // Send ACK to indicate byte received
1175   4                          RxCounter++;                          // Increment the byte counter
1176   4                      }
1177   3                      else
1178   3                      {
1179   4                          rtcReadDone = 1;
1180   4                          AA = 0;                             // Send NACK to indicate last byte is received
1181   4                      }
1182   3                  }
1183   2                  else if(slaveAddr == EEPROM_ADDR)
1184   2                  {
1185   3                      if(RxCounter < numBytesRD)
1186   3                      {
1187   4                          eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1188   4                          AA = 1;                             // Send ACK to indicate byte received
1189   4                          RxCounter++;                          // Increment the byte counter
1190   4                          eepromReadDone = 0;                       // Mark start of fram read
1191   4                      }
1192   3                      else
1193   3                      {
1194   4                          AA = 0;                             // Send NACK to indicate last byte is received
1195   4                          eepromReadDone = 1;                       // Mark end of fram read
1196   4                      }
1197   3                  }
1198   2                  break;
1199   2                  
1200   2                  //--------------------------------------------------------------------------------------------
             ------------
1201   2                  // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1202   2                  // For a READ: Read operation has completed.  Read data register and send STOP
1203   2                  //--------------------------------------------------------------------------------------------
             ------------
1204   2              case SMB_DATA_RX_NACK_TX:
1205   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1206   2                  {
1207   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1208   3                      STO = 1;                              // Stop transfer
1209   3                      SMB_BUSY = 0;                           // Release SMB
1210   3                      AA = 1;
1211   3                      slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next
             - transfer
1212   3                  }
1213   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1214   2                  {
1215   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1216   3                      rtcReadDone = 1;
1217   3                      
1218   3                      STO = 1;                              // Stop transfer
1219   3                      SMB_BUSY = 0;                           // Release SMB
1220   3                      AA = 1;                               // Send ACK to indicate byte received
1221   3                  }
1222   2                  else if(slaveAddr == EEPROM_ADDR)
1223   2                  {
1224   3                      eepromRx[RxCounter] = SMB0DAT;
1225   3                      STO = 1;                              // Stop transfer
1226   3                      SMB_BUSY = 0;                           // Release SMB
1227   3                      AA = 1;
1228   3                      eepromReadDone = 1;                         // Mark end of eeprom read
1229   3                  }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 22  

1230   2                  break;
1231   2                  
1232   2                  //--------------------------------------------------------------------------------------------
             ------------
1233   2                  // Master Transmitter: Arbitration lost
1234   2                  //--------------------------------------------------------------------------------------------
             ------------
1235   2              case SMB_ARBITRATION_LOST:
1236   2                  FAIL = 1;                                                     // Indicate failed transfer
1237   2                  // and handle at end of ISR
1238   2                  break;
1239   2                  
1240   2                  //--------------------------------------------------------------------------------------------
             ------------
1241   2                  // All other status codes invalid.  Reset communication
1242   2                  //--------------------------------------------------------------------------------------------
             ------------
1243   2              default:
1244   2                  FAIL = 1;
1245   2                  break;
1246   2          }
1247   1          //----------------------------------------------------------------------------------------------------
             ----
1248   1          // If all failed, reset everything
1249   1          //----------------------------------------------------------------------------------------------------
             ----
1250   1          if(FAIL)                                                            // If the transfer failed,
1251   1          {
1252   2              SMB0CN &= ~0x40;                                                  // Reset communication
1253   2              SMB0CN |= 0x40;
1254   2              STA = 0;
1255   2              STO = 0;
1256   2              AA = 0;
1257   2              
1258   2              SMB_BUSY = 0;                                                     // Free SMBus
1259   2              
1260   2              FAIL = 0;
1261   2              // Set to finish all pending processes
1262   2              slaveWriteDone = 1;                             // Mark end of slave write
1263   2              slaveReadDone = 1;                              // Mark end of slave read
1264   2              rtcWriteDone = 1;
1265   2              rtcReadDone = 1;
1266   2              eepromWriteDone = 1;                            // Mark end of eeprom write
1267   2              eepromReadDone = 1;                             // Mark end of eeprom read
1268   2          }
1269   1          
1270   1          SI = 0;                                                             // Clear interrupt flag
1271   1      }
1272          
1273          //-------------------------------------------------------------------------------------------------------
1274          // Function Name: setClockControl
1275          // Return Value: None 
1276          // Parmeters: None
1277          // Function Description: This function sets values to the real time clock control register
1278          // Check DS3232 documentation for more details of this this control register
1279          //-------------------------------------------------------------------------------------------------------
1280          void setClockControl(void)
1281          {
1282   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1283   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30;
1284   1          writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
1285   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 23  

1286          
1287          //-------------------------------------------------------------------------------------------------------
1288          // Function Name: setClock
1289          // Return Value: None 
1290          // Parmeters: None
1291          // Function Description: This function sets the new values to the real time clock
1292          //-------------------------------------------------------------------------------------------------------
1293          void setClock(void)
1294          { 
1295   1          unsigned char hoursAux;
1296   1          
1297   1          sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to 
             -array before writing
1298   1          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... ar
             -e already converted to BCD
1299   1          sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1300   1          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1301   1          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1302   1          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1303   1          
1304   1          hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1305   1          
1306   1          hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1307   1          
1308   1          if(amPm == 'P')
1309   1          {
1310   2              hoursAux = hoursAux | 0x60;                         // Set AM/PM bit --> PM mode
1311   2          }
1312   1          else if(amPm == 'A')
1313   1          {
1314   2              hoursAux = hoursAux & 0x5F;                         // Clear AM/PM bit --> AM mode
1315   2          }
1316   1          
1317   1          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1318   1          
1319   1          writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes t
             -o RTC
1320   1          
1321   1          //resetAllDisplayCounters();                              // Update new values on screen
1322   1      }     
1323          
1324          //-------------------------------------------------------------------------------------------------------
1325          // Function Name: getClockData()
1326          // Return Value: None 
1327          // Parmeters: None
1328          // Function Description: This function gets the new values from the real time clock
1329          //-------------------------------------------------------------------------------------------------------
1330          void getClockData()
1331          {
1332   1          static unsigned char previousMonth = 0;
1333   1          static unsigned char previousDate = 0;
1334   1          static unsigned char previousYear = 0;
1335   1          static unsigned char previousHours = 0;
1336   1          static unsigned char previousMinutes = 0;
1337   1          static unsigned char previousSeconds = 0;
1338   1          
1339   1          unsigned int currentIndex = 0;
1340   1          unsigned char tempHours;
1341   1          
1342   1          readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1343   1          
1344   1          seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal fo
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 24  

             -r seconds (1 byte)
1345   1          minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal fo
             -r minutes (1 byte)
1346   1          
1347   1          tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/P
             -M
1348   1          
1349   1          if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1350   1          {
1351   2              timeMode = TWELVE_HR_MODE;
1352   2              
1353   2              if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
1354   2              {
1355   3                  amPm = 'P';
1356   3              }
1357   2              else
1358   2              {
1359   3                  amPm = 'A';
1360   3              }
1361   2          }
1362   1          else
1363   1          {
1364   2              timeMode = TWENTY_FOUR_HR_MODE;
1365   2          }
1366   1          
1367   1          hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore othe
             -rs)
1368   1          
1369   1          if(hours == 12)
1370   1          {
1371   2              if(amPm == 'A')
1372   2              {
1373   3                  hours24 = 0;
1374   3              }
1375   2              else
1376   2              {
1377   3                  hours24 = hours;
1378   3              }
1379   2          }
1380   1          else
1381   1          {
1382   2              if(amPm == 'P')
1383   2              {
1384   3                  hours24 = hours + 12;                           // Twenty four hour format if PM
1385   3              }
1386   2              else
1387   2              {
1388   3                  hours24 = hours;                              // Twenty four hour format if AM
1389   3              }
1390   2          }
1391   1          
1392   1          day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day 
             -(1 byte)
1393   1          date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for dat
             -e (1 byte)
1394   1          month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for m
             -onth (1 byte)
1395   1          year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for yea
             -r (1 byte)
1396   1          
1397   1          if(month != previousMonth || date != previousDate || year != previousYear)
1398   1          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 25  

1399   2              monthDateYearUpdated = SET;
1400   2          }
1401   1          if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1402   1          {
1403   2              timeUpdated = SET;
1404   2          }
1405   1          
1406   1          if(amPm == 'P')
1407   1          {
1408   2              currentIndex = ((12 + hours) * 60) + minutes;
1409   2          }
1410   1          else if(amPm == 'A')
1411   1          {
1412   2              if(hours == 12)
1413   2              {
1414   3                  hours = 0;
1415   3              }
1416   2              
1417   2              currentIndex = (hours * 60) + minutes;
1418   2          }
1419   1          else
1420   1          {}
1421   1          
1422   1          minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1423   1          hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1424   1          
1425   1          previousDate = date;
1426   1          previousMonth = month;
1427   1          previousYear = year;
1428   1          previousHours = hours;
1429   1          previousMinutes = minutes;
1430   1          previousSeconds = seconds;
1431   1      }
1432          
1433          //-------------------------------------------------------------------------------------------------------
1434          // Function Name: moveDateTimeUp
1435          // Return Value: None 
1436          // Parmeters: None
1437          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1438          //-------------------------------------------------------------------------------------------------------
1439          /*
1440           void moveDateTimeUp(void)
1441           {
1442           }
1443           */
1444          
1445          //-------------------------------------------------------------------------------------------------------
1446          // Function Name: moveDateTimeDown
1447          // Return Value: None 
1448          // Parmeters: None
1449          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1450          //-------------------------------------------------------------------------------------------------------
1451          /*
1452           void moveDateTimeDown(void)
1453           {
1454           
1455           }
1456           */
1457          
1458          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 26  

1459          // Function Name: enterDateTime
1460          // Return Value: None 
1461          // Parmeters: None
1462          // Function Description: This function confirms the date or time set by the user on the touch screen
1463          //-------------------------------------------------------------------------------------------------------
1464          /*
1465           void enterDateTime(void)
1466           {
1467           char str[SPRINTF_SIZE];
1468           
1469           realTimeClockItems++;                                // Move to next item
1470           
1471           if(realTimeClockItems == MONTH_ADJUST)
1472           {
1473           monthUpdated = SET;
1474           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1475           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1476           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1477           }
1478           else if(realTimeClockItems == DATE_ADJUST)
1479           {
1480           dateUpdated = SET;
1481           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1482           sprintf(str, "%bu   ", adjustedDate);
1483           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1484           }
1485           else if(realTimeClockItems == YEAR_ADJUST)
1486           {
1487           yearUpdated = SET;
1488           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1489           sprintf(str, "20%02bu", adjustedYear);
1490           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1491           }
1492           else if(realTimeClockItems == HOUR_ADJUST)
1493           {
1494           hoursUpdated = SET;
1495           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1496           sprintf(str, "%bu   ", adjustedHours);
1497           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1498           }
1499           else if(realTimeClockItems == MINUTE_ADJUST)
1500           {
1501           minutesUpdated = SET;
1502           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
1503           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1504           sprintf(str, "%bu   ", adjustedMinutes);
1505           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1506           }
1507           else if(realTimeClockItems == AMPM_ADJUST)
1508           {
1509           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
1510           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE_
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 27  

             -DISPLAY_Y);
1511           sprintf(str, "%cM  ", adjustedAmPm);
1512           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1513           }
1514           else if(realTimeClockItems == DONE_ADJUST)
1515           {
1516           amPmUpdated = SET;                               // Set it if user explicitly press enter button
1517           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1518           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPLA
             -Y_Y);
1519           }
1520           else if(realTimeClockItems == ROLL_OVER_ADJUST)
1521           {
1522           realTimeClockItems = MONTH_ADJUST;                       // Set it for next round of real time clock items
1523           monthUpdated = SET;
1524           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1525           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1526           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1527           }
1528           else
1529           {}
1530           }
1531           */
1532          
1533          //-------------------------------------------------------------------------------------------------------
1534          // Function Name: setClockOnScreen
1535          // Return Value: None 
1536          // Parmeters: None
1537          // Function Description: This function sets the real time clock on the touch screen
1538          //-------------------------------------------------------------------------------------------------------
1539          /*
1540           void setClockOnScreen(void)
1541           {
1542           unsigned char hoursAux;
1543           
1544           if(monthUpdated == SET)
1545           {
1546           sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);   // Get updated month from use
             -r on screen
1547           writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);              // Set month only (1 byte)
1548           monthUpdated = CLEAR;                              //Clear flag after writing to real time clock
1549           }
1550           
1551           if(dateUpdated == SET)
1552           {
1553           sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);   // Get updated date from user o
             -n screen
1554           writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);             // Set date only (1 byte)
1555           dateUpdated = CLEAR;
1556           }
1557           
1558           if(yearUpdated == SET)
1559           {
1560           sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);   // Get updated year from user o
             -n screen
1561           writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);             // Set year only (1 byte)
1562           yearUpdated = CLEAR;
1563           }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 28  

1564           
1565           if(hoursUpdated == SET || amPmUpdated == SET)
1566           {
1567           hoursAux = convertDecimalToBCD(adjustedHours);                 // Get updated hours from user on screen
1568           
1569           if(amPmUpdated == SET)
1570           {
1571           amPm = adjustedAmPm;                           // Set updated amPm from user on screen
1572           
1573           hoursAux = hoursAux | 0x40;                          // Set 12/24 bit --> 12 hour mode
1574           
1575           if(adjustedAmPm == 'P')
1576           {
1577           hoursAux = hoursAux | 0x60;                        // Set AM/PM bit --> PM mode
1578           }
1579           else if(adjustedAmPm == 'A')
1580           {
1581           hoursAux = hoursAux & 0x5F;                        // Clear AM/PM bit --> AM mode
1582           }
1583           else
1584           {}
1585           
1586           amPmUpdated = CLEAR;
1587           }
1588           
1589           sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1590           writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);              // Set hours only (1 byte)
1591           hoursUpdated = CLEAR;
1592           }
1593           
1594           if(minutesUpdated == SET)
1595           {
1596           sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes); // Get updated minutes fro
             -m user on screen
1597           writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);              // Set minutes only (1 byte)
1598           minutesUpdated = CLEAR;
1599           }
1600           
1601           realTimeClockItems = MONTH_ADJUST;                         // Set starting item = Month for adjustment
1602           
1603           getClockData();                                      // Get current month, date, year set by user
1604           
1605           //clockSetupDisplayRepeat = 0;                           // Display clock updates on screen                                    // Syste
             -m goes back to main page
1606           }
1607           */
1608          
1609          //-------------------------------------------------------------------------------------------------------
1610          // Function Name: resetClock
1611          // Return Value: None 
1612          // Parmeters: None
1613          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1614          //-------------------------------------------------------------------------------------------------------
1615          void resetClock(void)
1616          {
1617   1          seconds = 0;
1618   1          minutes = 0;
1619   1          hours = 0;
1620   1          amPm = 'P';
1621   1          day = 1;
1622   1          date = 1;
1623   1          month = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 29  

1624   1          year = 0;
1625   1          century = 0;
1626   1          timeMode = 1;
1627   1          
1628   1          setClock();                                             // Set real time clock
1629   1      }
1630          
1631          //-------------------------------------------------------------------------------------------------------
1632          // Function Name: convertDecimalToBCD
1633          // Return Value: bcd 
1634          // Parmeters: decimal
1635          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1636          //-------------------------------------------------------------------------------------------------------
1637          unsigned char convertDecimalToBCD(unsigned char decimal)
1638          {
1639   1          unsigned char bcd;
1640   1          
1641   1          bcd = (decimal / 10) << 4;                              // Get upper 4 bits
1642   1          bcd = bcd | (decimal % 10);                             // Get a BCD
1643   1          
1644   1          return bcd;
1645   1      }
1646          
1647          //-------------------------------------------------------------------------------------------------------
1648          // Function Name: convertBCDToDecimal
1649          // Return Value: decimal value 
1650          // Parmeters: bcd
1651          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1652          //-------------------------------------------------------------------------------------------------------
1653          unsigned char convertBCDToDecimal(unsigned char bcd)
1654          {
1655   1          unsigned char decimal;
1656   1          
1657   1          decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
1658   1          // 8 bit number
1659   1          return decimal;
1660   1      }
1661          
1662          //-------------------------------------------------------------------------------------------------------
1663          // Function Name: displayClock
1664          // Return Value: None 
1665          // Parmeters: None
1666          // Function Description: This function displays clock data on the touch screen
1667          // The clock format is MM/DD/YYYY hour/minute/second
1668          //-------------------------------------------------------------------------------------------------------
1669          void displayClock(void)
1670          {
1671   1          char str[SPRINTF_SIZE];
1672   1          
1673   1          //if(screen == MAIN_PAGE)
1674   1          //{
1675   1          getClockData();
1676   1          
1677   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1678   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS_DAT
             -E_Y);
1679   1          monthDateYearUpdated = CLEAR;
1680   1          
1681   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1682   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS_TIM
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 30  

             -E_Y);
1683   1          //}
1684   1          /*else if(screen == CLOCK_SETUP_PAGE)
1685   1           {
1686   1           if(buttonPressed == CLEAR)
1687   1           {
1688   1           getClockData();
1689   1           
1690   1           sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1691   1           displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y)
             -;
1692   1           monthDateYearUpdated = CLEAR;
1693   1           
1694   1           sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1695   1           displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y)
             -;
1696   1           timeUpdated = CLEAR;
1697   1           }
1698   1           }*/
1699   1      }
1700          
1701          //------------------------------------------------------------------------------------------------------
1702          // Utility functions by team 1 
1703          //------------------------------------------------------------------------------------------------------
1704          
1705          typedef enum 
1706          {
1707              SLIDER_VERTICAL = 0,
1708              SLIDER_HORIZONTAL,
1709          } SLIDER_ORIENTATION_E;
1710          
1711          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1712          {
1713   1          char str[128] = { 0 };
1714   1          
1715   1          int i = 0;
1716   1          while(i < 10000) i++;
1717   1          
1718   1          sprintf(str, "S %s %s\r", fg, bg);
1719   1          sendCommand(str);
1720   1          sprintf(str, "f %s\r", Font[size]);
1721   1          sendCommand(str);
1722   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1723   1          sendCommand(str);
1724   1      }
1725          
1726          void display_time_settings_text(const char * fg, const char * bg, const unsigned char size, const char * m
             -essage, const int x, const int y)
1727          {
1728   1          char str[128] = { 0 };
1729   1          
1730   1          int i = 0;
1731   1          while(i < 10000) i++;
1732   1          
1733   1          sprintf(str, "S %s %s\r", fg, bg);
1734   1          sendCommand(str);
1735   1          sprintf(str, "f %s\r", Font[size]);
1736   1          sendCommand(str);
1737   1          sprintf(str, "t \"%11s\" %u %u\r", message, x, y);
1738   1          sendCommand(str);
1739   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 31  

1740          
1741          static void send_macro(const unsigned int macro_index)
1742          {
1743   1          char str[8] = { 0 };
1744   1          
1745   1          int i = 0;
1746   1          while(i < 10000) i++;
1747   1          
1748   1          sprintf(str, "m %u\r", macro_index);
1749   1          sendCommand(str);
1750   1      }
1751          
1752          static void display_slider(const int idx, const int bg, const int x, const int y, const int slider, 
1753                                     const int offset, const SLIDER_ORIENTATION_E orientation, const int invert, con
             -st int high, const int low)
1754          {
1755   1          char str[50] = { 0 };
1756   1          sprintf(str, "sl %u %u %u %u %u %u %u %u 1 %u %u ", idx, bg, x, y, slider, offset, orientation, invert
             -, high, low);
1757   1          sendCommand(str);
1758   1      }
1759          
1760          static void set_brightness(const char * brightness)
1761          {
1762   1          char str[10] = { 0 };
1763   1      
1764   1          sprintf(str, "xbb %s\r", brightness);
1765   1          sendCommand(str);
1766   1      }
1767          
1768          static void set_volume(const char * volume)
1769          {
1770   1          char str[10] = { 0 };
1771   1      
1772   1          sprintf(str, "bv %s\r", volume);
1773   1          sendCommand(str);
1774   1      }
1775          
1776          int handle_passcode(int k){
1777   1          int isValid = 0,i = 0;
1778   1          char str[SPRINTF_SIZE];
1779   1          sprintf(str, "%s", "     ");
1780   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 240, 80);
1781   1          if(k == 0){
1782   2              passcode[0]='\0';
1783   2          }
1784   1          
1785   1          if ('1' == userCommand[1] && '4' == userCommand[2] && '1' == userCommand[3]) {
1786   2              strcat(passcode,"1");
1787   2              isValid = 1;
1788   2          }
1789   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '2' == userCommand[3]) {
1790   2              strcat(passcode,"2");
1791   2              isValid = 1;
1792   2          }
1793   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '3' == userCommand[3]) {
1794   2              strcat(passcode,"3");
1795   2              isValid = 1;
1796   2          }
1797   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '4' == userCommand[3]) {
1798   2              strcat(passcode,"4");
1799   2              isValid = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 32  

1800   2          }
1801   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '5' == userCommand[3]) {
1802   2              strcat(passcode,"5");
1803   2              isValid = 1;
1804   2          }
1805   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '6' == userCommand[3]) {
1806   2              strcat(passcode,"6");
1807   2              isValid = 1;
1808   2          }
1809   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '7' == userCommand[3]) {
1810   2              strcat(passcode,"7");
1811   2              isValid = 1;
1812   2          }
1813   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '8' == userCommand[3]) {
1814   2              strcat(passcode,"8");
1815   2              isValid = 1;
1816   2          }
1817   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '9' == userCommand[3]) {
1818   2              strcat(passcode,"9");
1819   2              isValid = 1;
1820   2          }
1821   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '0' == userCommand[3]) {
1822   2              strcat(passcode,"0");
1823   2              isValid = 1;
1824   2          }
1825   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '0' == userCommand[3]) {
1826   2              strcat(passcode,"*");
1827   2              isValid = 1;
1828   2          }
1829   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '1' == userCommand[3]) {
1830   2              strcat(passcode,"#");
1831   2              isValid = 1;
1832   2          }
1833   1          if(isValid){
1834   2              str[0] = '\0';
1835   2              for(i=0;i<=k;i++){
1836   3                  strcat(str,"*");
1837   3              }
1838   2          }
1839   1          //sprintf(str, "%s", passcode);
1840   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 280, 105);
1841   1          return isValid;
1842   1      }
1843          
1844          
1845          void display_time(unsigned char Seconds_l, unsigned char Minutes_l, unsigned char Hours_l, unsigned char A
             -mPm, unsigned char Date_l, unsigned char Month_l, unsigned char Year_l) {
1846   1          char *str;
1847   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[Month_l], Date_l, Year_l);
1848   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 55, 190);
1849   1          //monthDateYearUpdated = CLEAR;
1850   1          
1851   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", Hours_l, Minutes_l, Seconds_l, AmPm);
1852   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 55, 240);
1853   1          
1854   1      }
1855          
1856          #define PAGE_MAIN            1
1857          #define PAGE_SETTINGS        2
1858          #define PAGE_SERVICE         3
1859          #define PAGE_CONFIG          4
1860          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 33  

1861          unsigned int set_Clock(void)
1862          {
1863   1          //154 - previous, 155 - next, 156 - enter, 157 -> value - 1, 158 -> value + 1;
1864   1          char *str;
1865   1          unsigned int screen_index = PAGE_CONFIG;
1866   1          getClockData();
1867   1          seconds_l = seconds;
1868   1          minutes_l = minutes;
1869   1          hours_l = hours;
1870   1          amPm_l = amPm;
1871   1          date_l = date;
1872   1          month_l = month;
1873   1          year_l = year;
1874   1          
1875   1          
1876   1          set = 0;
1877   1          selection = 1;
1878   1          //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
1879   1         
1880   1          
1881   1         while (!set)
1882   1          {   
1883   2            
1884   2              display_time_settings_text(SETTINGS_DATE_FG, SETTINGS_DATE_BG,SETTINGS_DATE_FONT,setDateTime[selec
             -tion], 370,180); //menu display to set
1885   2              if (selection < 4) {
1886   3                  sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1887   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1888   3              }
1889   2              else {
1890   3                  sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1891   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1892   3              }
1893   2              while(tsCommandReceived == 0); //wait till there is a new key pressed pressed
1894   2              /*if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3])// upper arrow - inc
             -rease value (158)
1895   2              {
1896   2                  switch(selection)
1897   2                  {
1898   2                  case 0 : {
1899   2                      //increase seconds
1900   2                      if (seconds_l == 59) {
1901   2                          seconds_l = 0;
1902   2                      }
1903   2                      else {
1904   2                          seconds_l += 1;
1905   2                      }
1906   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1907   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1908   2                      
1909   2                      break;
1910   2                  }
1911   2                  case 1 : {
1912   2                      //increase minutes
1913   2                      if (minutes_l == 59) {
1914   2                          minutes_l = 0;
1915   2                      }
1916   2                      else {
1917   2                          minutes_l += 1;
1918   2                      }
1919   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1920   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 34  

1921   2                      
1922   2                      
1923   2                      break;
1924   2                  }
1925   2                  case 2 : {
1926   2                      //increase hours
1927   2                      if (hours_l == 12) {
1928   2                          hours_l = 1;
1929   2                      }
1930   2                      else {
1931   2                          hours_l += 1;
1932   2                      }
1933   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1934   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1935   2                      
1936   2                      break;
1937   2                  }
1938   2                  case 3 : {
1939   2                      //changes AM / PM
1940   2                      if (amPm_l == 'P') {
1941   2                          amPm_l = 'A';
1942   2                      }
1943   2                      else {
1944   2                          amPm_l = 'P';
1945   2                      }
1946   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1947   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1948   2                      
1949   2                      break;
1950   2                  }
1951   2                  case 4 : {
1952   2                      //increase date
1953   2                      if (date_l == 31) {
1954   2                          date_l = 1;
1955   2                      }
1956   2                      else {
1957   2                          date_l += 1;
1958   2                      }
1959   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1960   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1961   2                      
1962   2                      break;
1963   2                  }
1964   2                  case 5 : {
1965   2                      //increase month
1966   2                      if (month_l == 12) {
1967   2                          month_l = 1;
1968   2                      }
1969   2                      else {
1970   2                          month_l += 1;
1971   2                      }
1972   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1973   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1974   2                      
1975   2                      break;
1976   2                  }
1977   2                  case 6 : {
1978   2                      //increase year
1979   2                      year_l += 1;
1980   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1981   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1982   2                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 35  

1983   2                      break;
1984   2                  }
1985   2                  default :
1986   2                      {
1987   2                          break;
1988   2                      }
1989   2                  } //switch ends
1990   2              } //if ends
1991   2              
1992   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3])// lower arrow - decre
             -ase value (157)
1993   2              {
1994   2                  switch(selection)
1995   2                  {
1996   2                  case 0 :
1997   2                      {
1998   2                          //decrease seconds
1999   2                          if (seconds_l == 0) {
2000   2                              seconds_l = 59;
2001   2                          }
2002   2                          else {
2003   2                              seconds_l -= 1;
2004   2                          }
2005   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2006   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2007   2                          break;
2008   2                      }
2009   2                  case 1 :
2010   2                      {
2011   2                          //decrease minutes
2012   2                          if (minutes_l == 0) {
2013   2                              minutes_l = 59;
2014   2                          }
2015   2                          else {
2016   2                              minutes_l -= 1;
2017   2                          }
2018   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2019   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2020   2                          break;
2021   2                      }
2022   2                  case 2 :
2023   2                      {
2024   2                          //decrease hours
2025   2                          if (hours_l == 0) {
2026   2                              hours_l = 12;
2027   2                          }
2028   2                          else {
2029   2                              hours_l -= 1;
2030   2                          }
2031   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2032   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2033   2                          break;
2034   2                      }
2035   2                  case 3 :
2036   2                      {
2037   2                          //changes AM / PM
2038   2                          if (amPm_l == 'P') {
2039   2                              amPm_l = 'A';
2040   2                          }
2041   2                          else {
2042   2                              amPm_l = 'P';
2043   2                          }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 36  

2044   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2045   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2046   2                          break;
2047   2                      }
2048   2                  case 4 :
2049   2                      {
2050   2                          //decrease date
2051   2                          if (date_l == 1) {
2052   2                              date_l = 31;
2053   2                          }
2054   2                          else {
2055   2                              date_l -= 1;
2056   2                          }
2057   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2058   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2059   2                          
2060   2                          break;
2061   2                      }
2062   2                  case 5 :
2063   2                      {
2064   2                          //decrease month
2065   2                          if (month_l == 1) {
2066   2                              month_l = 12;
2067   2                          }
2068   2                          else {
2069   2                              month_l -= 1;
2070   2                          }
2071   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2072   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2073   2                          
2074   2                          break;
2075   2                      }
2076   2                  case 6 :
2077   2                      {
2078   2                          //decrease year
2079   2                          year_l -= 1;
2080   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2081   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2082   2                          
2083   2                          break;
2084   2                      }
2085   2                  default :
2086   2                      {
2087   2                          break;
2088   2                      }
2089   2                  }
2090   2              } */
2091   2          if (selection == 0) { //to set seconds in time
2092   3                  
2093   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2094   4                      //increase seconds
2095   4                      if (seconds_l == 59) {
2096   5                          seconds_l = 0;
2097   5                      }
2098   4                      else {
2099   5                          seconds_l += 1;
2100   5                      }
2101   4                      
2102   4                  }
2103   3                  
2104   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2105   4                      //decrease seconds
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 37  

2106   4                      if (seconds_l == 0) {
2107   5                          seconds_l = 59;
2108   5                      }
2109   4                      else {
2110   5                          seconds_l -= 1;
2111   5                      }
2112   4                      
2113   4                  }
2114   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2115   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2116   3                      
2117   3              }
2118   2              
2119   2              else if (selection == 1) { //to set minutes
2120   3                  
2121   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2122   4                      //increase seconds
2123   4                      if (minutes_l == 59) {
2124   5                          minutes_l = 0;
2125   5                      }
2126   4                      else {
2127   5                          minutes_l += 1;
2128   5                      }
2129   4                      
2130   4                  }
2131   3                  
2132   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2133   4                      //decrease seconds
2134   4                      if (minutes_l == 0) {
2135   5                          minutes_l = 59;
2136   5                      }
2137   4                      else {
2138   5                          minutes_l -= 1;
2139   5                      }
2140   4                      
2141   4                  }
2142   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2143   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2144   3                      
2145   3              }
2146   2              
2147   2              else if (selection == 2) { //to set hours
2148   3                  
2149   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2150   4                      //increase hours
2151   4                      if (hours_l == 12) {
2152   5                          hours_l = 1;
2153   5                      }
2154   4                      else {
2155   5                          hours_l += 1;
2156   5                      }
2157   4                  }
2158   3                  
2159   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2160   4                      //decrease hours
2161   4                      if (hours_l == 1) {
2162   5                          hours_l = 12;
2163   5                      }
2164   4                      else {
2165   5                          hours_l -= 1;
2166   5                      }
2167   4                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 38  

2168   4                  }
2169   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2170   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2171   3                      
2172   3              }
2173   2              
2174   2              else if (selection == 3) { //to set Am/ Pm
2175   3                  
2176   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2177   4                      //changes AM / PM
2178   4                      if (amPm_l == 'P') {
2179   5                          amPm_l = 'A';
2180   5                      }
2181   4                      else {
2182   5                          amPm_l = 'P';
2183   5                      }
2184   4                     
2185   4                  }
2186   3                  
2187   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2188   4                      //changes AM / PM
2189   4                      if (amPm_l == 'P') {
2190   5                          amPm_l = 'A';
2191   5                      }
2192   4                      else {
2193   5                          amPm_l = 'P';
2194   5                      }
2195   4                      
2196   4                  }
2197   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2198   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2199   3                      
2200   3              }
2201   2              
2202   2              else if (selection == 4) { //to set date
2203   3                  
2204   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2205   4                      //increase date
2206   4                      if (date_l == 31) {
2207   5                          date_l = 1;
2208   5                      }
2209   4                      else {
2210   5                          date_l += 1;
2211   5                      }
2212   4                      
2213   4                  }
2214   3                  
2215   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2216   4                      //decrease date
2217   4                      if (date_l == 1) {
2218   5                          date_l = 31;
2219   5                      }
2220   4                      else {
2221   5                          date_l -= 1;
2222   5                      }
2223   4                    sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2224   4                    displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2225   4                            
2226   4                      
2227   4                  }
2228   3              }
2229   2              
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 39  

2230   2              else if (selection == 5) { //to set month
2231   3                  
2232   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2233   4                      //increase month
2234   4                      if (month_l == 12) {
2235   5                          month_l = 1;
2236   5                      }
2237   4                      else {
2238   5                          month_l += 1;
2239   5                      }
2240   4                      
2241   4                  }
2242   3                  
2243   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2244   4                      //decrease month
2245   4                      if (month_l == 1) {
2246   5                          month_l = 12;
2247   5                      }
2248   4                      else {
2249   5                          month_l -= 1;
2250   5                      }
2251   4                      
2252   4                      
2253   4                  }
2254   3            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2255   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2256   3                          
2257   3              }
2258   2              
2259   2              else if (selection == 6) { //to set year
2260   3                  
2261   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2262   4                      //increase year
2263   4                      year_l += 1;
2264   4                      
2265   4                    
2266   4                  }
2267   3                  
2268   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2269   4                      //decrease year
2270   4                      year_l -= 1;
2271   4                      
2272   4                    
2273   4                  }
2274   3            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2275   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2276   3                          
2277   3              }
2278   2              
2279   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '4' == userCommand[3]) {
2280   3                  //previous in menu
2281   3                  if (selection == 0) {
2282   4                      selection = 6;
2283   4                  }
2284   3                  else {
2285   4                      selection -= 1;
2286   4                  }
2287   3                  //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2288   3              }
2289   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '5' == userCommand[3]) {
2290   3                  //next in menu
2291   3                  if (selection == 6) {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 40  

2292   4                      selection = 0;
2293   4                  }
2294   3                  else {
2295   4                      selection += 1;
2296   4                  }
2297   3                  //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2298   3              }
2299   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '6' == userCommand[3]) {
2300   3                  // store the values (Enter is pressed, 156)
2301   3                  seconds = seconds_l;
2302   3                  minutes = minutes_l;
2303   3                  hours = hours_l;
2304   3                  amPm = amPm_l;
2305   3                  //day = day_l;
2306   3                  date = date_l;
2307   3                  month = month_l;
2308   3                  year = year_l;
2309   3                  set = 1;
2310   3                  setClock();                                                                            // Set 
             -real time clock
2311   3                  screen_index = PAGE_MAIN;
2312   3                  //enter directs to settings page where user has to enter password again
2313   3              }
2314   2              
2315   2              if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3])
2316   2              {
2317   3                  screen_index = PAGE_SETTINGS;
2318   3                  set = 1;
2319   3              }
2320   2              if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2321   3                  screen_index = PAGE_MAIN;
2322   3                  set = 1;
2323   3              }
2324   2              if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2325   3                  screen_index = PAGE_SERVICE;
2326   3                  set = 1;
2327   3              }
2328   2          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
2329   2          display_text(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 55, 190);
2330   2          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
2331   2          display_text(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 55, 240);
2332   2          } //end of while
2333   1          return screen_index;
2334   1      }
2335          
2336          //-------------------------------------------------------------------------------------------------------
2337          // Main
2338          //-------------------------------------------------------------------------------------------------------
2339          
2340          
2341          #define PAGE_SETTINGS_SUCCESS 5
2342          int current_page = 1;
2343          int busyWait = 0;
2344          
2345          void main()
2346          {
2347   1          int i = 0;
2348   1          int count = 0;
2349   1          int prev_temp = 0;
2350   1          int display_celsius = 0;
2351   1          int state_changed = 1;
2352   1          char str[SPRINTF_SIZE];
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 41  

2353   1          
2354   1          disableWatchdog();
2355   1          systemClockInit();
2356   1          portInit();
2357   1          enableInterrupts();
2358   1          uart0Init();
2359   1          smbInit();
2360   1          timer3Init();
2361   1          
2362   1          tsLastCharGone = 1;
2363   1          tsTxOut = tsTxIn = 0;
2364   1          tsTxEmpty = 1;
2365   1          
2366   1          sprintf(str, "z\r"); //clear screen
2367   1          sendCommand(str); //clear screen
2368   1          send_macro(Splash); //startUp page
2369   1        //   while(i < 600) { i++;
2370   1          // //sprintf(str,"%d", i);
2371   1        //     //  display_text("000000","FFFFFF",6,str, 240,40);
2372   1          //  if (i == 599){
2373   1          //    sprintf(str,"%d", i);
2374   1        //       display_text("000000","FFFFFF",6,str, 240,40);
2375   1          //  }
2376   1          // } //wait for startup graphics to finish
2377   1        //   i = 0;
2378   1          //state_changed = 1;
2379   1          //current_page = PAGE_MAIN;
2380   1          
2381   1          while(!splashEnd);
2382   1          while(1)
2383   1          {
2384   2              //scanUserInput();                                                        // Detect a string input
             - from the touch screen
2385   2              
2386   2              
2387   2              //sprintf(str,"%d", current_page);
2388   2              //display_text("000000","FFFFFF",6,str, 240,40);
2389   2              switch(current_page)
2390   2              {
2391   3                  case (PAGE_SETTINGS_SUCCESS):
2392   3                  {
2393   4                      if(state_changed)
2394   4                      {
2395   5                          state_changed = 0;
2396   5                        }
2397   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2398   5                          current_page = PAGE_SETTINGS;
2399   5                          state_changed = 1;
2400   5                          break;
2401   5                      }
2402   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2403   5                          current_page = PAGE_MAIN;
2404   5                          state_changed = 1;
2405   5                          break;
2406   5                      }
2407   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2408   5                          current_page = PAGE_SERVICE;
2409   5                          state_changed = 1;
2410   5                          break;
2411   5                      }
2412   4                      break;
2413   4                  }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 42  

2414   3                      
2415   3                  case (PAGE_SETTINGS):
2416   3                  {
2417   4                      
2418   4                      if (state_changed) {
2419   5                state_changed = 0;
2420   5                send_macro(display_settings_new);
2421   5                          //clear passcode
2422   5                passcode[0] = '\0';
2423   5                          
2424   5                        
2425   5                          
2426   5                      }
2427   4                      
2428   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2429   5                          current_page = PAGE_SETTINGS;
2430   5                          state_changed = 0;
2431   5                          break;
2432   5                      }
2433   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2434   5                          current_page = PAGE_MAIN;
2435   5                          state_changed = 1;
2436   5                          break;
2437   5                      }
2438   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2439   5                          current_page = PAGE_SERVICE;
2440   5                          state_changed = 1;
2441   5                          break;
2442   5                      }
2443   4                      else {
2444   5                          for (k = 0; k < 4 ; ){
2445   6                              
2446   6                              while(tsCommandReceived == 0);
2447   6                              if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2448   7                                  current_page = PAGE_SETTINGS;
2449   7                                  state_changed = 0;
2450   7                                  break;
2451   7                              }
2452   6                              else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) 
             -{
2453   7                                  current_page = PAGE_MAIN;
2454   7                                  state_changed = 1;
2455   7                                  break;
2456   7                              }
2457   6                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) 
             -{
2458   7                                  current_page = PAGE_SERVICE;
2459   7                                  state_changed = 1;
2460   7                                  break;
2461   7                              }
2462   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '3' == userCommand[3]) 
             -{
2463   7                                  if(strcmp(passcode,ACTUAL) == 0){
2464   8                                      //display_text("000000","FFFFFF",6,"OK!", 240,200);
2465   8                                      current_page = PAGE_CONFIG;
2466   8                                      state_changed = 1;
2467   8                               //       send_macro(display_configuration);
2468   8                                  }
2469   7                                  else {
2470   8                      sprintf(str, "%s", "ERROR");
2471   8                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 280, 105);
2472   8                                      k = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 43  

2473   8                                      current_page = PAGE_SETTINGS;
2474   8                                      state_changed = 0;
2475   8                                  }
2476   7                                  break;//continue;
2477   7                              }
2478   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '2' == userCommand[3]) 
             -{
2479   7                                  size_t len = strlen(passcode);
2480   7                                  if(len > 0) passcode[len-1]=0;
2481   7                                  // k = 0;
2482   7                                  current_page = PAGE_SETTINGS;
2483   7                              }
2484   6                              else if(k < 4) {
2485   7                                  if(handle_passcode(k)) k++;
2486   7                                  current_page = PAGE_SETTINGS;
2487   7                              }
2488   6                              //tsCommandReceived  = 0;
2489   6                          }
2490   5                      }
2491   4                      break;
2492   4                  }
2493   3                  case (PAGE_CONFIG):
2494   3                  {
2495   4                      if (state_changed) {
2496   5                          state_changed = 0;
2497   5                          send_macro(display_configuration);
2498   5                          //display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
2499   5                      }
2500   4                      
2501   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2502   5                          current_page = PAGE_SETTINGS;
2503   5                          state_changed = 1;
2504   5                      }
2505   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2506   5                          current_page = PAGE_MAIN;
2507   5                          state_changed = 1;
2508   5                      }
2509   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2510   5                          current_page = PAGE_SERVICE;
2511   5                          state_changed = 1;
2512   5                      }
2513   4                      else {
2514   5                          current_page = set_Clock();
2515   5                          state_changed = 1;
2516   5                      }
2517   4                      break;
2518   4                  }
2519   3                  case (PAGE_SERVICE):
2520   3                  {
2521   4                      // display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2522   4                      if (state_changed) {
2523   5                          state_changed = 0;
2524   5                          // display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2525   5                          send_macro(display_service);
2526   5                          display_slider(200, 7, 135, 275, 8, 50, 1, 0, 255, 1);
2527   5                      }
2528   4                      
2529   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2530   5                          current_page = PAGE_SETTINGS;
2531   5                          state_changed = 1;
2532   5                      }
2533   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 44  

2534   5                          current_page = PAGE_MAIN;
2535   5                          state_changed = 1;
2536   5                      }
2537   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2538   5                          current_page = PAGE_SERVICE;
2539   5                          state_changed = 0;
2540   5                      }
2541   4                      else {
2542   5                          // NOOP
2543   5                      }
2544   4                      if(sliderCommandReceived)
2545   4                      {
2546   5                          if ('2' == userCommand[1] && '0' == userCommand[2] && '0' == userCommand[3])
2547   5                          {
2548   6                              int i = 0;
2549   6                              char temp[4] = { '\0' };
2550   6                              for(i = 0; i < 4; i++)
2551   6                              {
2552   7                                  if(userCommand[5+i] != '\r')
2553   7                                  {
2554   8                                      temp[i] = userCommand[5+i];
2555   8                                  }
2556   7                                  else
2557   7                                  {
2558   8                                      temp[i] = '\0';
2559   8                                      break;
2560   8                                  }
2561   7                              }
2562   6                              temp[3] = '\0';
2563   6                              set_brightness(temp);
2564   6                          }
2565   5      
2566   5                          else if ('2' == userCommand[1] && '0' == userCommand[2] && '1' == userCommand[3])
2567   5                          {
2568   6                              int i = 0;
2569   6                              char temp[4] = { '\0' };
2570   6                              for(i = 0; i < 4; i++)
2571   6                              {
2572   7                                  if(userCommand[5+i] != '\r')
2573   7                                  {
2574   8                                      temp[i] = userCommand[5+i];
2575   8                                  }
2576   7                                  else
2577   7                                  {
2578   8                                      temp[i] = '\0';
2579   8                                      break;
2580   8                                  }
2581   7                              }
2582   6                              temp[3] = '\0';
2583   6                              set_volume(temp);
2584   6                          }
2585   5                      }
2586   4                      break;
2587   4                  }
2588   3                  default:            // no break
2589   3                  case (PAGE_MAIN) :
2590   3                  {
2591   4                      //sprintf(str, "%d", state_changed);
2592   4                      //display_text("000000", "FFFFFF", 8, str, 240, 110);
2593   4                      roomTemp1 = readOneByteFromSlave(ROOM_TEMP_1);
2594   4                      
2595   4                      
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 21:00:07 PAGE 45  

2596   4                      if (state_changed) {
2597   5                          state_changed = 0;
2598   5                          while(busyWait < 250)
2599   5                          {
2600   6                              busyWait++;
2601   6                          }
2602   5                          sprintf(str, "%-3buC", roomTemp1);
2603   5                          display_text("000000", "FFFFFF", 6, str, 240, 110);
2604   5                send_macro(display_temperature); //main_page/ temperature display
2605   5                      }
2606   4                      
2607   4                      if (tsCommandReceived || roomTemp1 != prev_temp)
2608   4                      {
2609   5                          prev_temp = roomTemp1;
2610   5                          
2611   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
2612   6                              display_celsius = 1;
2613   6                              sprintf(str, "%-3buC", roomTemp1);
2614   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2615   6                          }
2616   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2617   6                              display_celsius = 0;
2618   6                              roomTemp1 = (roomTemp1 * 9) / 5 + 32;
2619   6                              sprintf(str, "%-3buF", roomTemp1);
2620   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2621   6                          }
2622   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2623   6                              current_page = PAGE_SETTINGS;
2624   6                              state_changed = 1;
2625   6                          }
2626   5                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2627   6                              current_page = PAGE_MAIN;
2628   6                              state_changed = 0;
2629   6                          }
2630   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2631   6                              current_page = PAGE_SERVICE;
2632   6                              state_changed = 1;
2633   6                          }
2634   5                          else {
2635   6                              // Noop
2636   6                          }
2637   5                      }
2638   4                      break;
2639   4                  }
2640   3              }//switch ends
2641   2          } //while ends
2642   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9707    ----
   CONSTANT SIZE    =    998    ----
   XDATA SIZE       =   3538    1048
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     21       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
