C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          unsigned char tsByte;
   8          
   9          int k = 0;
  10          char passcode[] = "";
  11          char *ACTUAL = "1457";
  12          
  13          // real time clock
  14          unsigned char seconds_l;
  15          unsigned char minutes_l;
  16          unsigned char hours_l;
  17          unsigned char amPm_l;
  18          unsigned char date_l;
  19          unsigned char month_l;
  20          unsigned char year_l;
  21          unsigned char selection;
  22          unsigned char set;
  23          
  24          const char code *setDateTime[] =    {/*0*/  "SET SECONDS",
  25                                               /*1*/  "SET MINUTES",
  26                                               /*2*/  "SET HOURS", 
  27                                               /*3*/  "SET AM/PM",
  28                                               /*4*/  "SET DATE", 
  29                                               /*5*/  "SET MONTH",
  30                                               /*6*/  "SET YEAR"};
  31          
  32          bit splashEnd = 0;
  33          bit screenReset = 0;
  34          bit ackFromScreen = 0;
  35          bit tsCommandReceived = 0;
  36          bit tsCommandTransmitted = 0;
  37          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  38          
  39          unsigned char sharedDataRx[SHARED_DATA_MAX];
  40          unsigned char sharedDataTx[SHARED_DATA_MAX];
  41          unsigned char eepromTx[EEPROM_TX_BUFFER];
  42          unsigned char eepromRx[EEPROM_RX_BUFFER];
  43          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  44          
  45          unsigned int pageCount;
  46          unsigned int bytesExtra;
  47          unsigned int eepromPageCounter;
  48          unsigned int startAddr;
  49          unsigned char slaveAddr;                                                        // Target SMBus slave addr
             -ess
  50          unsigned char eepromDataByte;
  51          
  52          unsigned int numBytesRD;
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 2   

  53          unsigned int numBytesWR;
  54          unsigned char slaveWriteDone;
  55          unsigned char slaveReadDone;
  56          unsigned char eepromWriteDone;
  57          unsigned char eepromReaddone;
  58          unsigned char rtcWriteDone;
  59          unsigned char rtcReadDone;
  60          
  61          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  62          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  63          unsigned char userCommand[RX_BUFFER_SIZE];
  64          
  65          unsigned int tsRxIn;
  66          unsigned int tsRxOut; 
  67          unsigned int tsTxIn;
  68          unsigned int tsTxOut;
  69          
  70          bit tsRxEmpty;
  71          bit tsTxEmpty;
  72          bit tsLastCharGone; 
  73          
  74          bit screenChanged;
  75          unsigned char screen;
  76          unsigned char lastScreen;
  77          
  78          const char code * Font[] = {/*0*/   "m10B", 
  79                                      /*1*/   "m12B",
  80                                      /*2*/   "m14B",
  81                                      /*3*/   "m16B",
  82                                      /*4*/   "m20B",
  83                                      /*5*/   "m24B",
  84                                      /*6*/   "m32B",
  85                                      /*7*/   "m48",
  86                                      /*8*/   "m64"};
  87          
  88          bit SMB_BUSY = 0;                                                               // Set to claim the bus, c
             -lear to free
  89          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  90          
  91          unsigned int startAddr;
  92          unsigned char slaveAddr;                                                        // Target SMBus slave addr
             -ess
  93          
  94          unsigned int numBytesRD;
  95          unsigned int numBytesWR;
  96          
  97          unsigned char slaveWriteDone;
  98          unsigned char slaveReadDone;
  99                                      
 100          unsigned char roomTemp1;
 101          unsigned char roomTemp2;
 102          unsigned char roomTemp3;
 103                                      
 104          unsigned char seconds;
 105          unsigned char minutes;
 106          unsigned char hours;
 107          unsigned char hours24;
 108          unsigned char amPm;
 109          unsigned char day;
 110          unsigned char date;
 111          unsigned char month;
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 3   

 112          unsigned char year;
 113          unsigned char century;
 114          unsigned char timeMode;
 115          unsigned char currentIndex = 0;
 116          unsigned char minuteIndex = 0;
 117          unsigned char hourIndex = 0;
 118          
 119          unsigned char currentDate;
 120          unsigned char currentMonth;
 121          unsigned char currentYear;
 122          
 123          unsigned char realTimeClockItems;
 124          
 125          unsigned char adjustedSeconds;
 126          unsigned char adjustedMinutes;
 127          unsigned char adjustedHours;
 128          unsigned char adjustedAmPm;
 129          unsigned char adjustedDay;
 130          unsigned char adjustedDate;
 131          unsigned char adjustedMonth;
 132          unsigned char adjustedYear;
 133          unsigned char adjustedCentury;
 134          unsigned char adjustedTimeMode;
 135          
 136          bit monthUpdated;
 137          bit dateUpdated;
 138          bit yearUpdated;
 139          bit hoursUpdated;
 140          bit minutesUpdated;
 141          bit secondsUpdated;
 142          bit amPmUpdated;
 143          bit timeUpdated;
 144          bit monthDateYearUpdated;
 145          
 146          const char code * dayOfWeek[] =     {/*0*/  "NON",
 147                                               /*1*/  "SUN",
 148                                               /*2*/  "MON", 
 149                                               /*3*/  "TUE",
 150                                               /*4*/  "WED", 
 151                                               /*5*/  "THU",
 152                                               /*6*/  "FRI", 
 153                                               /*7*/  "SAT"}; 
 154          
 155          const char code * monthOfYear[] =   {/*0*/  "NON",
 156                                               /*1*/  "JAN",
 157                                               /*2*/  "FEB", 
 158                                               /*3*/  "MAR",
 159                                               /*4*/  "APR", 
 160                                               /*5*/  "MAY",
 161                                               /*6*/  "JUN", 
 162                                               /*7*/  "JUL",
 163                                               /*8*/  "AUG",
 164                                               /*9*/  "SEP",
 165                                               /*10*/ "OCT", 
 166                                               /*11*/ "NOV",
 167                                               /*12*/ "DEC"};
 168          
 169          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 170                                              /*1*/   "WRITING DATA... WAIT!  ",
 171                                              /*2*/   "DATA SUCCESSFULLY SAVED",
 172                                              /*3*/   "ERROR                  "};
 173          
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 4   

 174          //-------------------------------------------------------------------------------------------------------
 175          // System Configurations
 176          //-------------------------------------------------------------------------------------------------------
 177          void systemClockInit(void)
 178          {
 179   1          char SFRPAGE_SAVE = SFRPAGE;                                                // Save Current SFR page
 180   1          int i = 0;
 181   1          
 182   1          SFRPAGE  = CONFIG_PAGE;
 183   1          
 184   1          OSCICN    = 0x83;
 185   1      
 186   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFRPAGE
 187   1      }
 188          
 189          void portInit(void)
 190          {
 191   1          char SFRPAGE_SAVE = SFRPAGE;                                                // Save Current SFR page
 192   1      
 193   1          SFRPAGE = CONFIG_PAGE;                                                      // Set SFR page
 194   1      
 195   1          XBR0 = 0x2F;                                                                // Enable UART0, UART1, SP
             -I0, SMB, CEX0 - CEX4                                                                          
 196   1          XBR1 = 0x01;                                        
 197   1          XBR2 = 0xC4;                                                                // Enable crossbar and dis
             -able weak pull-up                                             
 198   1          
 199   1          P0MDOUT = 0x01;                                                             // Set TX0 pin to push-pul
             -l
 200   1                                                                                      // TX0 = P0.0; RX0 = P0.1
 201   1          P1MDOUT = 0x01;                                                             // Set TX1 pin to push-pul
             -l, P1.0
 202   1                                                                                      // TX1 = P1.0; RX1 = P1.1
 203   1          P3MDOUT = 0xCA;                                                             // P3.0, P3.2, P3.4, P3.5:
             - open drain; P3.1, P3.3, P3.6, P3.7: push pull
 204   1          
 205   1          P4MDOUT = 0x0F;                                                             // P4.0, P4.1, P4.2, P4.3:
             - push pull
 206   1                                                                                      
 207   1          P5MDOUT = 0x04;                                                             // P5.0 open drain; P5.1 O
             -pen drain; P5.2 Push pull
 208   1          
 209   1          P6MDOUT = 0x00;
 210   1                                                                                                                
             -                                                  
 211   1          P7MDOUT = 0x80;                                                             // Set P7.7 push-pull (smb
             - error line)
 212   1          
 213   1          P0 = 0xFF;                                                                  // Initialize port P0 latc
             -h
 214   1          P1 = 0xFF;                                                                  // Initialize port P1 latc
             -h
 215   1          P2 = 0xFF;                                                                  // Initialize port P2 latc
             -h
 216   1          P3 = 0xFF;                                                                  // Initialize port P3 latc
             -h
 217   1          P4 = 0xFF;                                                                  // Initialize port P4 latc
             -h
 218   1          P5 = 0xFF;                                                                  // Initialize port P5 latc
             -h
 219   1          P6 = 0xFF;                                                                  // Initialize port P6 latc
             -h
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 5   

 220   1          P7 = 0xFF;                                                                  // Initialize port P7 latc
             -h
 221   1      
 222   1          RHW = 0;                                                                    // Pull low SMB error line
 223   1      
 224   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFR page
 225   1      }
 226          
 227          void enableInterrupts(void)
 228          {
 229   1          IE = 0x92;                                                                  // Enable all interrupts +
             - UART0 + Timer 0
 230   1          EIE2 |= 0x01;                                                               // Enable Timer 3 interrup
             -t
 231   1          EIE2 |= 0x40;                                                               // Enable UART1 interrupt
 232   1          EIE1 |= 0x0A;                                                               // Enable SMBus interrupt
 233   1      }
 234          
 235          void uart0Init(void)
 236          {
 237   1         char SFRPAGE_SAVE;
 238   1      
 239   1         SFRPAGE_SAVE = SFRPAGE;                                                      // Preserve SFRPAGE
 240   1      
 241   1         SFRPAGE = TMR2_PAGE;
 242   1         TMR2CN = 0x00;                                                               // Stop timer. Timer 2 in 
             -16-bit auto-reload up timer mode
 243   1         TMR2CF = 0x08;                                                               // SYSCLK is time base; no
             - output; up count only
 244   1         RCAP2L = 0xF3;                                                               // Low byte
 245   1         RCAP2H = 0xFF;                                                               // High byte
 246   1         TMR2 = RCAP2;                                                                // Load 16 bit reload valu
             -e into timer 2
 247   1         TMR2CN = 0x04;                                                               // Enable timer 2 (Start t
             -imer 2)
 248   1      
 249   1         SFRPAGE = UART0_PAGE;
 250   1         SCON0 = 0x50;                                                                // 8-bit variable baud rat
             -e; 9th bit ignored; RX enabled
 251   1         SSTA0 = 0x05;                                                                // Enable baud rate       
             -                                                                  
 252   1                                                                                      // Use timer 2 as RX and T
             -X baud rate source
 253   1         IE = 0x90;                                                                   // Enable all interrupts a
             -nd UART0 Interrupt
 254   1      
 255   1         SFRPAGE = SFRPAGE_SAVE;                                                      // Restore SFRPAGE
 256   1      }
 257          
 258          void disableWatchdog(void)
 259          {
 260   1          WDTCN = 0xDE;                                                               // Disable watchdog timer
 261   1          WDTCN = 0xAD;
 262   1      }
 263          
 264          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 265          {
 266   1          char SFRPAGE_SAVE = SFRPAGE;
 267   1          unsigned int i = 0;
 268   1          unsigned long txWaitCounter = 0;
 269   1      
 270   1          SFRPAGE = UART0_PAGE;
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 6   

 271   1      
 272   1          if(RI0 == 1)                                                                // There is a char in SBUF
 273   1          {
 274   2              RI0 = 0;                                                                // Clear interrupt flag
 275   2      
 276   2              tsByte = SBUF0;                                                         // Read a character from U
             -ART
 277   2      
 278   2              if(tsRxIn < RX_BUFFER_SIZE)                                             // If buffer size is withi
             -n limit
 279   2              {
 280   3                  if(tsByte != '\r')                                                  // Check end of a command 
             -from touch screen
 281   3                  {
 282   4                      tsRxBuffer[tsRxIn] = tsByte;                                    // Store a character in so
             -ftware buffer
 283   4                      tsRxIn++;                                                       // Increment index
 284   4                  }
 285   3                  else                                                                // If it is CR character, 
             -it marks end of command
 286   3                  {                                                               
 287   4                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 288   4                      {
 289   5                          if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[
             -4] == 'e' && tsRxBuffer[5] == '}')
 290   5                          {
 291   6                              splashEnd = 1;                                          // Detect end of splash sc
             -reen
 292   6                              screenReset = 1;                                        // Screen was reset, so to
             -uch screen sends {babe\r}
 293   6                          }
 294   5                          else
 295   5                          {
 296   6                              splashEnd = 0;                                          // End of splash screen NO
             -T detected
 297   6                              screenReset = 0;                                    
 298   6                          }
 299   5                      }
 300   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 301   4                      {                                                               // A command starts with '
             -('
 302   5                          for(i = 0; i < tsRxIn; i++)
 303   5                          {
 304   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 305   6                          }
 306   5      
 307   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 308   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 309   5                      }
 310   4                      else if(tsRxBuffer[0] == '(')                                   // It is a command from to
             -uch screen controller
 311   4                      {                                                               // A command starts with '
             -('
 312   5                          for(i = 0; i < tsRxIn; i++)
 313   5                          {
 314   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 315   6                          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 7   

 316   5      
 317   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 318   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 319   5                      }
 320   4                      else                                                            // Not a command from touc
             -h screen controller
 321   4                      {
 322   5                          ackFromScreen = 1;                                          // Set a flag to indicate 
             -it is an ACK from screen
 323   5                          tsCommandReceived = 0;                                      // No need to set flag bec
             -ause it is not a command
 324   5                      }
 325   4      
 326   4                      for(i = 0; i < tsRxIn; i++)
 327   4                      {
 328   5                          tsRxBuffer[i] = '\0';                                       // Delete all contents
 329   5                      }
 330   4                      
 331   4                      tsRxOut = 0;                                                    // Reset index Out
 332   4                      tsRxIn = 0;                                                     // Reset index In
 333   4                  }   
 334   3              }
 335   2              else                                                                    // Reset all indexes
 336   2              {   
 337   3                  while(tsRxOut < tsRxIn)
 338   3                  {
 339   4                      tsRxBuffer[tsRxOut] = '\0';
 340   4                      tsRxOut++;
 341   4                  }
 342   3                  tsRxOut = 0;
 343   3                  tsRxIn = 0;
 344   3                  tsCommandReceived = 0;
 345   3              }
 346   2         }
 347   1      
 348   1         if(TI0 == 1)                                                                 // Check if one character 
             -is successfully sent out
 349   1         {
 350   2              TI0 = 0;                                                                // Clear interrupt flag
 351   2      
 352   2              if(tsTxEmpty == 0)                                                      // TX buffer has something
             - to send
 353   2              {
 354   3                  SBUF0 = tsTxBuffer[tsTxOut];                                        // Send a character in TX 
             -buffer
 355   3                  tsTxOut++;                                                          // Move to next character
 356   3      
 357   3                  while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);                 // Wait until completion o
             -f transmission TI0 = 1
 358   3                  if(txWaitCounter >= TX_WAIT_LIMIT)
 359   3                  {
 360   4                      TI0 = 1;                                                        // TI0 is not set by hardw
             -are, set it by software
 361   4                  }                                                                   // When TI0 is set to 1, t
             -his ISR is executed again
 362   3                  
 363   3                  txWaitCounter = 0;                                                  // Reset counter for next 
             -execution 
 364   3      
 365   3                  if(tsTxOut >= TX_BUFFER_SIZE)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 8   

 366   3                  {
 367   4                      tsTxOut = 0;                                                    // Reset index to 0
 368   4                  }                               
 369   3      
 370   3                  if(tsTxOut == tsTxIn)                                               // If two indexes are equa
             -l
 371   3                  {
 372   4                      tsTxEmpty = 1;                                                  // No more character in bu
             -ffer. Empty
 373   4                  }
 374   3              }
 375   2              else
 376   2              {
 377   3                  tsLastCharGone = 1;                                                 // Last character has gone
             -. Buffer is empty
 378   3              }
 379   2          }
 380   1          
 381   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFR page detect
             -or
 382   1      }
 383          
 384          //-------------------------------------------------------------------------------------------------------
 385          // Function Name: sendCommand
 386          // Return Value: None 
 387          // Parmeters: s (a string to send)
 388          // Function Description: This function sends a command from the touch screen
 389          //-------------------------------------------------------------------------------------------------------
 390          void sendCommand(const char * s)
 391          {   
 392   1          char SFRPAGE_SAVE = SFRPAGE;
 393   1          
 394   1          while(*s != '\0')                                                           // Search for end of touch
             - screen command in buffer
 395   1          {
 396   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))                               // Tx is empty or two inde
             -xes are not equal
 397   2              {
 398   3                  tsTxBuffer[tsTxIn++] = *s;
 399   3                  if(tsTxIn >= TX_BUFFER_SIZE)                                        // Check for limit
 400   3                  {
 401   4                      tsTxIn = 0;                                                     // Reset if limit reached
 402   4                  }
 403   3      
 404   3                  if(tsTxEmpty == 1)                                                  // If buffer is empty
 405   3                  {
 406   4                      tsTxEmpty = 0;                                                  // Now buffer has at leat 
             -1 character, set flag
 407   4                  }
 408   3              }
 409   2              
 410   2              s++;                                                                    // Point to next char to s
             -end out
 411   2          }
 412   1                                                                                      
 413   1          if(tsLastCharGone == 1)                                                     // All characters in buffe
             -r has sent out
 414   1          {
 415   2              tsLastCharGone = 0;                                                     // Reset flag to indicate 
             -no char left in buffer
 416   2              SFRPAGE = UART0_PAGE;                                                                           
 417   2              TI0 = 1;                                                                // Set this flage to call 
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 9   

             -ISR to send out one character
 418   2          }                                                                           
 419   1                                                                                      
 420   1          SFRPAGE = SFRPAGE_SAVE;                                                     // Restore SFRPAGE
 421   1      }
 422          
 423          //-------------------------------------------------------------------------------------------------------
 424          // Function Name: displayText
 425          // Return Value: None 
 426          // Parmeters: fg, bg, size, message, x, y
 427          // Function Description: This function displays a text on the touch screen
 428          //-------------------------------------------------------------------------------------------------------
 429          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 430          {
 431   1          char str[TS_BUFFER_SIZE];                                                   // String
 432   1              
 433   1          sprintf(str, "S %s %s\r", fg, bg);                                          // Set forground and backg
             -round color
 434   1          sendCommand(str);                                                       
 435   1          sprintf(str, "f %s\r", Font[size]);                                         // Set text font
 436   1          sendCommand(str);                                                       
 437   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);                            // Display text
 438   1          sendCommand(str);                                                       
 439   1      }
 440          
 441          //-------------------------------------------------------------------------------------------------------
 442          // Function Name: showBitmap
 443          // Return Value: None 
 444          // Parmeters: index, x, y (bitmap index and coordinates)
 445          // Function Description: This function displays a bitmap image
 446          //-------------------------------------------------------------------------------------------------------
 447          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 448          {
 449   1          char str[TS_BUFFER_SIZE];
 450   1      
 451   1          sprintf(str, "xi %u %u %u\r", index, x, y);                                 // Bitmap index
 452   1          sendCommand(str);
 453   1      }
 454          
 455          //-------------------------------------------------------------------------------------------------------
 456          // Function Name: changeScreen
 457          // Return Value: None 
 458          // Parmeters: screenIndex (macro number)
 459          // Function Description: This function switches to the new screen
 460          //-------------------------------------------------------------------------------------------------------
 461          void changeScreen(const unsigned char screenIndex)
 462          {
 463   1          callMacro(screenIndex);                                                     // Change screen        
 464   1      }
 465          
 466          //-------------------------------------------------------------------------------------------------------
 467          // Function Name: callMacro
 468          // Return Value: None 
 469          // Parmeters: macroNumber (macro number in the macro file)
 470          // Function Description: This function calls a macro
 471          //-------------------------------------------------------------------------------------------------------
 472          void callMacro(const unsigned int macroNumber)
 473          {
 474   1          char str[TS_BUFFER_SIZE];
 475   1      
 476   1          sprintf(str, "m %u\r", macroNumber);                                        // Execute macro number
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 10  

 477   1          sendCommand(str);
 478   1      }
 479          
 480          //-------------------------------------------------------------------------------------------------------
 481          // Function Name: scanUserInput
 482          // Return Value: None 
 483          // Parmeters: None
 484          // Function Description: This function processes commands from the touch screen
 485          //-------------------------------------------------------------------------------------------------------
 486          void scanUserInput(void)
 487          {   
 488   1          int i = 0;
 489   1      
 490   1          if(screen == MAIN_PAGE)                                                     // Main screen
 491   1          {        
 492   2              if(userCommand[0] == '(')                                               // Check for an actual com
             -mand followed by this '(' character
 493   2              {
 494   3                  switch (userCommand[1])                                             // Scan a command type
 495   3                  {
 496   4                      case '1':                                                       // Main page
 497   4                          changeScreen(MAIN_PAGE);                                    // Stay in main page if ma
             -in button is pressed again
 498   4                          break;
 499   4                      case '2':                                                       // Settings page
 500   4                          changeScreen(SETTINGS_PAGE);
 501   4                          break;
 502   4                      case '3':                                                       // Service page
 503   4                          changeScreen(SERVICE_PAGE);
 504   4                          break;
 505   4                      case 'A':
 506   4                          // Call a function here or do something here            
 507   4                          break;
 508   4                      case 'B':
 509   4                          // Call a function here or do something here
 510   4                          break;
 511   4                      case 'C':
 512   4                          // Call a function here or do something here
 513   4                          break;  
 514   4                      default:                                                        // Other options
 515   4                          break;
 516   4                      }
 517   3              }
 518   2              else                                                                    // Not a command, empty bu
             -ffer with null char
 519   2              {
 520   3                  i = 0;
 521   3                  while(userCommand[i] != '\0')
 522   3                  {
 523   4                      userCommand[i] = '\0';
 524   4                      i++;
 525   4                  }
 526   3              }   
 527   2          }
 528   1          else if(screen == SETTINGS_PAGE)                                            // Settings page
 529   1          {
 530   2              if(userCommand[0] == '(')
 531   2              {
 532   3                  switch (userCommand[1])
 533   3                  {
 534   4                      case '1':
 535   4                          changeScreen(MAIN_PAGE);
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 11  

 536   4                          break;
 537   4                      case '2':
 538   4                          changeScreen(SETTINGS_PAGE);
 539   4                          break;
 540   4                      case '3':
 541   4                          changeScreen(SERVICE_PAGE);
 542   4                          break;
 543   4                      case 'A':
 544   4                          // Call a function here or do something here
 545   4                          break;
 546   4                      case 'B':
 547   4                          // Call a function here or do something here
 548   4                          break;
 549   4                      case 'C':
 550   4                          // Call a function here or do something here
 551   4                          break;
 552   4                      default:
 553   4                          break;
 554   4                  }
 555   3              }
 556   2              else                                                                    // Not a command, empty bu
             -ffer with null
 557   2              {
 558   3                  i = 0;
 559   3                  while(userCommand[i] != '\0')
 560   3                  {
 561   4                      userCommand[i] = '\0';
 562   4                      i++;
 563   4                  }
 564   3              }               
 565   2          }
 566   1          else if(screen == SERVICE_PAGE)
 567   1          {
 568   2              if(userCommand[0] == '(')
 569   2              {
 570   3                  switch (userCommand[1])
 571   3                  {
 572   4                      case '1':
 573   4                          changeScreen(MAIN_PAGE);
 574   4                          break;
 575   4                      case '2':
 576   4                          changeScreen(SETTINGS_PAGE);
 577   4                          break;
 578   4                      case '3':
 579   4                          changeScreen(SERVICE_PAGE);
 580   4                          break;
 581   4                      case 'A':
 582   4                          // Call a function here or do something here
 583   4                      case 'B':
 584   4                          // Call a function here or do something here
 585   4                      case 'C':
 586   4                          // Call a function here or do something here
 587   4                      default:
 588   4                          break;
 589   4                  }
 590   3              }
 591   2              else                                                                    // Not a command, empty bu
             -ffer with null
 592   2              {                                                           
 593   3                  i = 0;
 594   3                  while(userCommand[i] != '\0')
 595   3                  {
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 12  

 596   4                      userCommand[i] = '\0';
 597   4                      i++;
 598   4                  }
 599   3              }               
 600   2          }   
 601   1          else
 602   1          {
 603   2      
 604   2          }
 605   1      
 606   1          i = 0;
 607   1          while(userCommand[i] != '\0')
 608   1          {
 609   2              userCommand[i] = '\0';                                                  // Delete all contents in 
             -array
 610   2              i++;
 611   2          }
 612   1      }
 613          
 614          //-------------------------------------------------------------------------------------------------------
 615          // Function Name: smbInit
 616          // Return Value: None 
 617          // Parmeters: None
 618          // Function Description: This function initializes the SMB bus 
 619          //-------------------------------------------------------------------------------------------------------
 620          void smbInit(void)
 621          {
 622   1          int i;
 623   1          unsigned long pollingCounter = 0;
 624   1          char SFRPAGE_SAVE = SFRPAGE;
 625   1      
 626   1          SFRPAGE = SMB0_PAGE;
 627   1          while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)                         // If slave is holding
             - SDA low because of error or reset
 628   1          {
 629   2              SCL = 0;                                                                    // Drive the clock low
 630   2              for(i = 0; i < 255; i++);                                                   // Hold the clock low
 631   2              SCL = 1;                                                                    // Release the clock
 632   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);                    // Wait for open-drain
 633   2              for(i = 0; i < 10; i++);                                                    // Hold the clock high
 634   2          }
 635   1                  
 636   1          SMB0CN = 0x07;                                                                  // Assert Acknowledge 
             -low (AA bit = 1b);
 637   1                                                                                          // Enable SMBus Free t
             -imeout detect;
 638   1          SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));                            // Derived approximati
             -on from the Tlow and Thigh equations
 639   1                                                                          
 640   1          SMB0CN |= 0x40;                                                                 // Enable SMBus;
 641   1      
 642   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page de
             -tector
 643   1          
 644   1          SMB_BUSY = 0;
 645   1                                                                                          // Release SMB
 646   1          slaveWriteDone = FALSE;
 647   1          slaveReadDone = FALSE;
 648   1          eepromWriteDone = FALSE;
 649   1          eepromReadDone = FALSE;
 650   1          rtcWriteDone = FALSE;
 651   1          rtcReadDone = FALSE;
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 13  

 652   1      }
 653          
 654          //-------------------------------------------------------------------------------------------------------
 655          // Function Name: timer3Init
 656          // Return Value: None 
 657          // Parmeters: None
 658          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 659          //-------------------------------------------------------------------------------------------------------
 660          void timer3Init (void)
 661          {
 662   1          char SFRPAGE_SAVE = SFRPAGE;        
 663   1      
 664   1          SFRPAGE = TMR3_PAGE;
 665   1      
 666   1          TMR3CN = 0x00;                                                                  // Timer 3 in timer mo
             -de
 667   1                                                                                          // Timer 3 auto reload
 668   1          TMR3CF = 0x00;                                                                  // Timer 3 prescaler =
             - 12
 669   1      
 670   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                              // Timer 3 overflows a
             -fter 25 ms
 671   1          TMR3 = RCAP3;                                                               
 672   1      
 673   1          TR3 = 1;                                                                        // Start Timer 3
 674   1      
 675   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page
 676   1      }
 677          
 678          //-------------------------------------------------------------------------------------------------------
 679          // Function Name: timer3ISR
 680          // Return Value: None 
 681          // Parmeters: None
 682          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 683          //-------------------------------------------------------------------------------------------------------
 684          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 685          {
 686   1          char SFRPAGE_SAVE = SFRPAGE;                                                    // Save Current SFR pa
             -ge
 687   1      
 688   1          SFRPAGE = SMB0_PAGE;
 689   1          SMB0CN &= ~0x40;                                                                // Disable SMBus
 690   1          SMB0CN |= 0x40;                                                                 // Re-enable SMBus
 691   1      
 692   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Switch back to the 
             -Timer3 SFRPAGE
 693   1          TF3 = 0;                                                                        // Clear Timer3 interr
             -upt-pending flag
 694   1          SMB_BUSY = 0;                                                                   // Free bus
 695   1         
 696   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page de
             -tector
 697   1      }
 698          
 699          //-------------------------------------------------------------------------------------------------------
 700          // Function Name: writeOneByteToSlave
 701          // Return Value: None 
 702          // Parmeters: target, startAddr, content
 703          // Function Description: This function writes one to the slave microprocessor
 704          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 14  

 705          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 706          {           
 707   1          sharedDataTx[startAddr] = content;
 708   1          smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 709   1      }
 710          
 711          //-------------------------------------------------------------------------------------------------------
 712          // Function Name: readOneByteFromSlave
 713          // Return Value: long 
 714          // Parmeters: startAddr, bytes
 715          // Function Description: This function reads one from the slave microprocessor
 716          //-------------------------------------------------------------------------------------------------------
 717          unsigned char readOneByteFromSlave(unsigned char startAddr)
 718          {
 719   1          smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 720   1          return sharedDataRx[startAddr];                                                                       
             -                      
 721   1      }
 722          
 723          //-------------------------------------------------------------------------------------------------------
 724          // Function Name: writeBytesToRealTimeClock
 725          // Return Value: None 
 726          // Parmeters: target, startAddr, bytes
 727          // Function Description: This function writes data byte to the real time clock DS3232
 728          //-------------------------------------------------------------------------------------------------------
 729          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 730          {
 731   1          smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 732   1      }
 733          
 734          //-------------------------------------------------------------------------------------------------------
 735          // Function Name: readBytesFromRealTimeClock
 736          // Return Value: None 
 737          // Parmeters: target, startAddr, bytes
 738          // Function Description: This function reads data byte from the real time clock DS3232
 739          //-------------------------------------------------------------------------------------------------------
 740          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 741          {
 742   1          smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 743   1      }
 744          
 745          //-------------------------------------------------------------------------------------------------------
 746          // Function Name: smbRead
 747          // Return Value: unsigned char * 
 748          // Parmeters: target, startAddr, bytes
 749          // Function Description: This function reads from SM bus
 750          //-------------------------------------------------------------------------------------------------------
 751          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 752          {
 753   1          char SFRPAGE_SAVE = SFRPAGE;
 754   1      
 755   1          SFRPAGE = SMB0_PAGE;
 756   1          
 757   1          while(BUSY || SMB_BUSY);                                                        // Wait for free SMB
 758   1      
 759   1          SFRPAGE = SFRPAGE_SAVE;
 760   1              
 761   1          switch(deviceId)
 762   1          {
 763   2              case MCU_SLAVE_ADDR:
 764   2              case REAL_TIME_CLOCK_ADDR:
 765   2              case EEPROM_ADDR:
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 15  

 766   2                  smbWrite(deviceId, location, 0);                                        // Write address befor
             -e reading
 767   2                  break;
 768   2              default:
 769   2                  break;  
 770   2          }
 771   1      
 772   1          SFRPAGE = SMB0_PAGE;
 773   1              
 774   1          while(BUSY || SMB_BUSY);
 775   1          slaveAddr = deviceId;                                                           // Address of MCU slav
             -e
 776   1          startAddr = location;                                                           // Starting address to
             - read from slave
 777   1          numBytesRD = bytes;                                                             // Number of bytes to 
             -read
 778   1          
 779   1          SMB_BUSY = 1;                                                                   // Claim SMBus (set to
             - busy)
 780   1          SMB_RW = 1;                                                                     // Mark this transfer 
             -as a READ
 781   1          STA = 1;
 782   1      
 783   1          while(BUSY || SMB_BUSY);                                                        // Wait for SMB
 784   1              
 785   1          SFRPAGE = SFRPAGE_SAVE;
 786   1                  
 787   1          switch(deviceId)
 788   1          {
 789   2              case MCU_SLAVE_ADDR:
 790   2                  while(slaveReadDone == 0);                                              // Wait until slave wr
             -ite completed
 791   2                  break;
 792   2              case REAL_TIME_CLOCK_ADDR:
 793   2                  while(rtcReadDone == 0);                                                // Wait until real tim
             -e clock write completed or timeout occurs
 794   2                  break;
 795   2              case EEPROM_ADDR:
 796   2                  while(eepromReadDone == 0);                                             // Wait until EEPROM w
             -rite completed
 797   2                  break;
 798   2              default:
 799   2                  break;  
 800   2          }    
 801   1      }
 802          
 803          //-------------------------------------------------------------------------------------------------------
 804          // Function Name: smbWrite
 805          // Return Value: unsigned char * 
 806          // Parmeters: target, startAddr, bytes
 807          // Function Description: This function reads to SM bus
 808          //-------------------------------------------------------------------------------------------------------
 809          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 810          {
 811   1          unsigned char i = 0;
 812   1          unsigned int pageWrittenDelay = 0;
 813   1          char SFRPAGE_SAVE = SFRPAGE;
 814   1              
 815   1          SFRPAGE = SMB0_PAGE;
 816   1          
 817   1          while(BUSY || SMB_BUSY);                                                        // Wait for SMB to be 
             -free
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 16  

 818   1          slaveAddr = deviceId;                                                           // Address of MCU slav
             -e board
 819   1          startAddr = location;                                                           // Starting address to
             - write to slave
 820   1      
 821   1          switch(deviceId)
 822   1          {
 823   2              case MCU_SLAVE_ADDR:                                                        // Pass through
 824   2              case DEVICE_DUMP_ADDR:                                                      // Pass through
 825   2                  numBytesWR = bytes;                                                     // Number of bytes to 
             -read
 826   2                  SMB_BUSY = 1;                                                           // Claim SMBus (set to
             - busy)
 827   2                  SMB_RW = 0;                                                             // Mark this transfer 
             -as a WRITE
 828   2                  STA = 1;                                                                // Start transfer
 829   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 830   2                  break;
 831   2              case REAL_TIME_CLOCK_ADDR:
 832   2                  numBytesWR = bytes;                                                     // Number of bytes to 
             -read
 833   2                  SMB_BUSY = 1;                                                           // Claim SMBus (set to
             - busy)
 834   2                  SMB_RW = 0;                                                             // Mark this transfer 
             -as a WRITE
 835   2                  STA = 1;                                                                // Start transfer
 836   2                  while(rtcWriteDone == 0);                                               // Wait until SRAM wri
             -te completed or timeout occurs
 837   2                  break;
 838   2              default:
 839   2                  break;      
 840   2          }
 841   1      
 842   1          SFRPAGE = SFRPAGE_SAVE;                                                         // Restore SFR page
 843   1      }
 844          
 845          //-------------------------------------------------------------------------------------------------------
 846          // Function Name: smbISR
 847          // Return Value: None 
 848          // Parmeters: None
 849          // Function Description: 
 850          // SMBus Interrupt Service Routine (ISR)
 851          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 852          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 853          //-------------------------------------------------------------------------------------------------------
 854          void smbISR (void) interrupt INTERRUPT_SMB using 2
 855          {
 856   1          bit FAIL = 0;                                                                   // Used by the ISR to 
             -flag failed transfers
 857   1          static unsigned int TxCounter;                                                  // Initialize counter
 858   1          static unsigned int RxCounter;                                                  // Initialize counter
 859   1          static unsigned int slaveCount = 0;
 860   1          static unsigned int realTimeClockCount = 0;
 861   1          static unsigned int eepromCount = 0;
 862   1          static unsigned char eepromAddrDone;
 863   1          
 864   1          switch (SMB0STA >> 3)                                                           // Check SMB bus statu
             -s
 865   1          {
 866   2      //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 17  

 867   2      // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device address
 868   2      //-------------------------------------------------------------------------------------------------------
 869   2              case SMB_START:                                                             // Master initiates a 
             -transfer
 870   2      
 871   2      //-------------------------------------------------------------------------------------------------------
 872   2      // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave device addre
             -ss
 873   2      //-------------------------------------------------------------------------------------------------------
 874   2              case SMB_REPEAT_START:
 875   2                  SMB0DAT = slaveAddr;                                                    // Load address of the
             - slave.
 876   2                  SMB0DAT &= 0xFE;                                                        // Clear the LSB of th
             -e address for the R/W bit
 877   2                  SMB0DAT |= SMB_RW;                                                      // Load R/W bit (Read 
             -= 1; Write = 0)
 878   2                  STA = 0;                                                                // Manually clear STA 
             -bit
 879   2      
 880   2                  RxCounter = 0;                                                          // Reset the counter
 881   2                  TxCounter = 0;                                                          // Reset the counter
 882   2                  eepromAddrDone = CLEAR;                                                 // For 2 byte EEPROM a
             -ddress    
 883   2                  
 884   2                  break;
 885   2      
 886   2      //-------------------------------------------------------------------------------------------------------
 887   2      // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 888   2      // For a WRITE: Send the first data byte to the slave
 889   2      //-------------------------------------------------------------------------------------------------------
 890   2              case SMB_ADDR_W_TX_ACK_RX:
 891   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 892   2                  {
 893   3                      if(startAddr == DEVICE_DUMP_ADDR)                                   // Dump device address
             - to check slave presence only
 894   3                      {
 895   4                          STO = 1;                                                        // Stop this transfer
 896   4                          SMB_BUSY = 0;                                                   // Releas SMB
 897   4                      }
 898   3                      else
 899   3                      {
 900   4                          SMB0DAT = startAddr;                                            // Send 1 byte address
             - to slave
 901   4                          slaveWriteDone = 0;                                             // Mark start of slave
             - write
 902   4                      }
 903   3                  }
 904   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 905   2                  {
 906   3                      SMB0DAT = startAddr;                                                // Point to byte addre
             -ss to write on real time clock
 907   3                      rtcWriteDone = 0;                                                   // Mark start of rtc w
             -rite
 908   3                  }
 909   2                  else{}
 910   2                  break;
 911   2      
 912   2      //-------------------------------------------------------------------------------------------------------
 913   2      // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 914   2      //-------------------------------------------------------------------------------------------------------
 915   2              case SMB_ADDR_W_TX_NACK_RX:
 916   2                  if(slaveAddr == MCU_SLAVE_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 18  

 917   2                  {
 918   3                      if(slaveCount < MAX_NACK_RETRY)
 919   3                      {
 920   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
 921   4                          STA = 1;                                                        // Restart a new trans
             -fer
 922   4                      }
 923   3                      else
 924   3                      {
 925   4                          slaveCount = 0;                                                 // Reset this counter 
             -to keep retry seeking slave response
 926   4                          slaveWriteDone = 1;
 927   4                          STO = 1;
 928   4                          SMB_BUSY = 0;
 929   4                          FAIL = 1;
 930   4                      }   
 931   3                  }
 932   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 933   2                  {
 934   3                      if(realTimeClockCount < MAX_NACK_RETRY)
 935   3                      {
 936   4                          realTimeClockCount++;                                           // Increment number of
             - attempts when NACK is received
 937   4                          STA = 1;                                                        // Restart a new trans
             -fer
 938   4                      }
 939   3                      else
 940   3                      {
 941   4                          realTimeClockCount = 0;
 942   4                          rtcWriteDone = 1;
 943   4                          STO = 1;
 944   4                          SMB_BUSY = 0;
 945   4                          FAIL = 1;
 946   4                      }   
 947   3                  }
 948   2                  else if(slaveAddr == EEPROM_ADDR)
 949   2                  {
 950   3                      if(eepromCount < MAX_NACK_RETRY)
 951   3                      {
 952   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
 953   4                          STA = 1;                                                        // Restart a new trans
             -fer
 954   4                      }
 955   3                      else
 956   3                      {
 957   4                          eepromCount = 0;
 958   4                          eepromWriteDone = 1;
 959   4                          STO = 1;
 960   4                          SMB_BUSY = 0;
 961   4                          FAIL = 1;
 962   4                      }   
 963   3                  }
 964   2                  else
 965   2                  {}
 966   2      
 967   2                  break;
 968   2      
 969   2      //-------------------------------------------------------------------------------------------------------
 970   2      //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 971   2      //For a WRITE: Send all data.  After the last data byte, send the stop bit
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 19  

 972   2      //-------------------------------------------------------------------------------------------------------
 973   2              case SMB_DATA_TX_ACK_RX:
 974   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 975   2                  {
 976   3                      if(TxCounter < numBytesWR)
 977   3                      {
 978   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];                  // Send data byte
 979   4                          TxCounter++;
 980   4                      }
 981   3                      else
 982   3                      {
 983   4                          STO = 1;                                                        // Set STO to terminat
             -e transfer                                                
 984   4                          SMB_BUSY = 0;                                                   // And free SMBus inte
             -rface
 985   4                          slaveWriteDone = 1;                                             // Mark end of slave w
             -rite
 986   4                      }
 987   3                  }
 988   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 989   2                  {
 990   3                      if(TxCounter < numBytesWR)
 991   3                      {
 992   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];                  // Send data byte
 993   4                          TxCounter++;
 994   4                      }
 995   3                      else
 996   3                      {
 997   4                          STO = 1;                                                        // Set STO to terminat
             -e transfer                                                
 998   4                          SMB_BUSY = 0;                                                   // And free SMBus inte
             -rface
 999   4                          rtcWriteDone = 1;                                               // Mark end of slave w
             -rite
1000   4                      }
1001   3                  }
1002   2                  break;
1003   2      
1004   2      //-------------------------------------------------------------------------------------------------------
1005   2      // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1006   2      //-------------------------------------------------------------------------------------------------------
1007   2              case SMB_DATA_TX_NACK_RX:
1008   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1009   2                  {
1010   3                      if(slaveCount < MAX_NACK_RETRY)
1011   3                      {
1012   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
1013   4                          STA = 1;                                                        // Restart a new trans
             -fer
1014   4                      }
1015   3                      else
1016   3                      {
1017   4                          slaveCount = 0;
1018   4                          STO = 1;
1019   4                          SMB_BUSY = 0;
1020   4                          FAIL = 1;
1021   4                      }   
1022   3                  }
1023   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1024   2                  {
1025   3                      if(realTimeClockCount < MAX_NACK_RETRY)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 20  

1026   3                      {
1027   4                          realTimeClockCount++;                                           // Increment number of
             - attempts when NACK is received
1028   4                          STA = 1;                                                        // Restart a new trans
             -fer
1029   4                      }
1030   3                      else
1031   3                      {
1032   4                          realTimeClockCount = 0;
1033   4                          STO = 1;
1034   4                          SMB_BUSY = 0;
1035   4                          FAIL = 1;
1036   4                      }   
1037   3                  }
1038   2                  else if(slaveAddr == EEPROM_ADDR)
1039   2                  {
1040   3                      if(eepromCount < MAX_NACK_RETRY)
1041   3                      {
1042   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
1043   4                          STA = 1;                                                        // Restart a new trans
             -fer
1044   4                      }
1045   3                      else
1046   3                      {
1047   4                          eepromCount = 0;
1048   4                          STO = 1;
1049   4                          SMB_BUSY = 0;
1050   4                          FAIL = 1;
1051   4                      }   
1052   3                  }
1053   2                  else
1054   2                  {}
1055   2                  break;
1056   2      
1057   2      //-------------------------------------------------------------------------------------------------------
1058   2      // Master Receiver: Slave address + READ transmitted.  ACK received. 
1059   2      // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1060   2      // is received to end the transfer. if not, set the ACK and receive the other data bytes
1061   2      //-------------------------------------------------------------------------------------------------------
1062   2              case SMB_ADDR_R_TX_ACK_RX:
1063   2                  if(numBytesRD == 1)                                                     // If there is one byt
             -e to transfer, send a NACK and go to
1064   2                  {                                                                       // SMB_DATA_RX_NACK_TX
             - case to accept data from slave
1065   3                      AA = 0;                                                             // Clear AA flag befor
             -e data byte is received
1066   3                                                                                          // send NACK signal to
             - slave after byte is received
1067   3                  }
1068   2                  else
1069   2                  {
1070   3                      AA = 1;                                                             // More than one byte 
             -in this transfer,
1071   3                                                                                          // send ACK after byte
             - is received
1072   3                  }
1073   2                  break;
1074   2      
1075   2      //-------------------------------------------------------------------------------------------------------
1076   2      // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1077   2      //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 21  

1078   2              case SMB_ADDR_R_TX_NACK_RX:
1079   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1080   2                  {
1081   3                      if(slaveCount < MAX_NACK_RETRY)
1082   3                      {
1083   4                          slaveCount++;                                                   // Increment number of
             - attempts when NACK is received
1084   4                          STA = 1;                                                        // Restart transfer af
             -ter receiving a NACK
1085   4                      }
1086   3                      else
1087   3                      {
1088   4                          slaveCount = 0;                                                 // Reset counter
1089   4                          STO = 1;
1090   4                          SMB_BUSY = 0;
1091   4                          FAIL = 1;
1092   4                      }   
1093   3                  }
1094   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1095   2                  {
1096   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1097   3                      {
1098   4                          realTimeClockCount++;                                           // Increment number of
             - attempts when NACK is received
1099   4                          STA = 1;                                                        // Restart a new trans
             -fer
1100   4                      }
1101   3                      else
1102   3                      {
1103   4                          realTimeClockCount = 0;
1104   4                          STO = 1;
1105   4                          SMB_BUSY = 0;
1106   4                          FAIL = 1;
1107   4                      }   
1108   3                  }
1109   2                  else if(slaveAddr == EEPROM_ADDR)
1110   2                  {
1111   3                      if(eepromCount < MAX_NACK_RETRY)
1112   3                      {
1113   4                          eepromCount++;                                                  // Increment number of
             - attempts when NACK is received
1114   4                          STA = 1;                                                        // Restart a new trans
             -fer
1115   4                      }
1116   3                      else
1117   3                      {
1118   4                          eepromCount = 0;
1119   4                          STO = 1;
1120   4                          SMB_BUSY = 0;
1121   4                          FAIL = 1;
1122   4                      }   
1123   3                  }
1124   2                  else
1125   2                  {}
1126   2                  break;
1127   2      
1128   2      //-------------------------------------------------------------------------------------------------------
1129   2      // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1130   2      // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and set the STOP b
             -it
1131   2      //-------------------------------------------------------------------------------------------------------
1132   2              case SMB_DATA_RX_ACK_TX:
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 22  

1133   2                  
1134   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1135   2                  {
1136   3                      if (RxCounter < numBytesRD)
1137   3                      {
1138   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1139   4                          AA = 1;                                                         // Send ACK to indicat
             -e byte received
1140   4                          RxCounter++;                                                    // Increment the byte 
             -counter
1141   4                          slaveReadDone = 0;                                              // Mark start of slave
             - read
1142   4                      }
1143   3                      else
1144   3                      {
1145   4                          AA = 0;                                                         // Send NACK to indica
             -te last byte is received
1146   4                          slaveReadDone = 1;                                              // Mark end of slave r
             -ead
1147   4                      }
1148   3                  }
1149   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1150   2                  {
1151   3                      if(RxCounter < numBytesRD)
1152   3                      {
1153   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;                  // RTC
1154   4                          rtcReadDone = 0;
1155   4                          
1156   4                          AA = 1;                                                         // Send ACK to indicat
             -e byte received
1157   4                          RxCounter++;                                                    // Increment the byte 
             -counter
1158   4                      }
1159   3                      else
1160   3                      {
1161   4                          rtcReadDone = 1;
1162   4                          AA = 0;                                                         // Send NACK to indica
             -te last byte is received
1163   4                      }
1164   3                  }
1165   2                  else if(slaveAddr == EEPROM_ADDR)
1166   2                  {
1167   3                      if(RxCounter < numBytesRD)
1168   3                      {
1169   4                          eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1170   4                          AA = 1;                                                         // Send ACK to indicat
             -e byte received
1171   4                          RxCounter++;                                                    // Increment the byte 
             -counter
1172   4                          eepromReadDone = 0;                                             // Mark start of fram 
             -read
1173   4                      }
1174   3                      else
1175   3                      {
1176   4                          AA = 0;                                                         // Send NACK to indica
             -te last byte is received
1177   4                          eepromReadDone = 1;                                             // Mark end of fram re
             -ad
1178   4                      }
1179   3                  }
1180   2                  break;
1181   2      
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 23  

1182   2      //-------------------------------------------------------------------------------------------------------
1183   2      // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1184   2      // For a READ: Read operation has completed.  Read data register and send STOP
1185   2      //-------------------------------------------------------------------------------------------------------
1186   2              case SMB_DATA_RX_NACK_TX:
1187   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1188   2                  {
1189   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1190   3                      STO = 1;                                                            // Stop transfer
1191   3                      SMB_BUSY = 0;                                                       // Release SMB
1192   3                      AA = 1;
1193   3                      slaveReadDone = 1;                                                  // Mark end of slave r
             -ead                                                               // Set AA for next transfer                           
             -                              
1194   3                  }
1195   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1196   2                  {
1197   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;                      // RTC
1198   3                      rtcReadDone = 1;
1199   3      
1200   3                      STO = 1;                                                            // Stop transfer
1201   3                      SMB_BUSY = 0;                                                       // Release SMB
1202   3                      AA = 1;                                                             // Send ACK to indicat
             -e byte received
1203   3                  }
1204   2                  else if(slaveAddr == EEPROM_ADDR)
1205   2                  {
1206   3                      eepromRx[RxCounter] = SMB0DAT;
1207   3                      STO = 1;                                                            // Stop transfer
1208   3                      SMB_BUSY = 0;                                                       // Release SMB
1209   3                      AA = 1;
1210   3                      eepromReadDone = 1;                                                 // Mark end of eeprom 
             -read      
1211   3                  }
1212   2                  break;
1213   2      
1214   2      //-------------------------------------------------------------------------------------------------------
1215   2      // Master Transmitter: Arbitration lost
1216   2      //-------------------------------------------------------------------------------------------------------
1217   2              case SMB_ARBITRATION_LOST:
1218   2                  FAIL = 1;                                                               // Indicate failed tra
             -nsfer
1219   2                                                                                          // and handle at end o
             -f ISR
1220   2                  break;
1221   2      
1222   2      //-------------------------------------------------------------------------------------------------------
1223   2      // All other status codes invalid.  Reset communication
1224   2      //-------------------------------------------------------------------------------------------------------
1225   2              default:
1226   2                  FAIL = 1;
1227   2                  break;
1228   2         }
1229   1      //-------------------------------------------------------------------------------------------------------
1230   1      // If all failed, reset everything
1231   1      //-------------------------------------------------------------------------------------------------------
1232   1          if(FAIL)                                                                        // If the transfer fai
             -led,
1233   1          {
1234   2              SMB0CN &= ~0x40;                                                            // Reset communication
1235   2              SMB0CN |= 0x40;
1236   2              STA = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 24  

1237   2              STO = 0;
1238   2              AA = 0;
1239   2      
1240   2              SMB_BUSY = 0;                                                               // Free SMBus
1241   2      
1242   2              FAIL = 0;
1243   2                                                                                          // Set to finish all p
             -ending processes
1244   2              slaveWriteDone = 1;                                                         // Mark end of slave w
             -rite
1245   2              slaveReadDone = 1;                                                          // Mark end of slave r
             -ead
1246   2              rtcWriteDone = 1;
1247   2              rtcReadDone = 1;
1248   2              eepromWriteDone = 1;                                                        // Mark end of eeprom 
             -write
1249   2              eepromReadDone = 1;                                                         // Mark end of eeprom 
             -read
1250   2          }
1251   1      
1252   1          SI = 0;                                                                         // Clear interrupt fla
             -g
1253   1      }
1254          
1255          //-------------------------------------------------------------------------------------------------------
1256          // Function Name: setClockControl
1257          // Return Value: None 
1258          // Parmeters: None
1259          // Function Description: This function sets values to the real time clock control register
1260          // Check DS3232 documentation for more details of this this control register
1261          //-------------------------------------------------------------------------------------------------------
1262          void setClockControl(void)
1263          {
1264   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1265   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30; 
1266   1          writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);                         // Set control reg
             -isters (2 byte)
1267   1      }
1268                                            
1269          //-------------------------------------------------------------------------------------------------------
1270          // Function Name: setClock
1271          // Return Value: None 
1272          // Parmeters: None
1273          // Function Description: This function sets the new values to the real time clock
1274          //-------------------------------------------------------------------------------------------------------
1275          void setClock(void)
1276          {   
1277   1          unsigned char hoursAux;
1278   1          
1279   1          sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);              // Load all data f
             -rom PC to array before writing
1280   1          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);              // All data: secon
             -ds,.... are already converted to BCD
1281   1          sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1282   1          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1283   1          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1284   1          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1285   1          
1286   1          hoursAux = convertDecimalToBCD(hours);                                              // Get updated hou
             -rs from user on screen
1287   1      
1288   1          hoursAux = hoursAux | 0x40;                                                         // Set 12/24 bit -
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 25  

             --> 12 hour mode
1289   1          
1290   1          if(amPm == 'P')
1291   1          {
1292   2               hoursAux = hoursAux | 0x60;                                                    // Set AM/PM bit -
             --> PM mode
1293   2          }
1294   1          else if(amPm == 'A')
1295   1          {
1296   2               hoursAux = hoursAux & 0x5F;                                                    // Clear AM/PM bit
             - --> AM mode
1297   2          }
1298   1          
1299   1          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1300   1          
1301   1          writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes t
             -o RTC
1302   1      
1303   1          //resetAllDisplayCounters();                                                            // Update new 
             -values on screen
1304   1      }           
1305          
1306          //-------------------------------------------------------------------------------------------------------
1307          // Function Name: getClockData()
1308          // Return Value: None 
1309          // Parmeters: None
1310          // Function Description: This function gets the new values from the real time clock
1311          //-------------------------------------------------------------------------------------------------------
1312          void getClockData()
1313          {
1314   1          static unsigned char previousMonth = 0;
1315   1          static unsigned char previousDate = 0;
1316   1          static unsigned char previousYear = 0;
1317   1          static unsigned char previousHours = 0;
1318   1          static unsigned char previousMinutes = 0;
1319   1          static unsigned char previousSeconds = 0;
1320   1          
1321   1          unsigned int currentIndex = 0;
1322   1          unsigned char tempHours;
1323   1          
1324   1          readBytesFromRealTimeClock(RTC_START_ADDR, 7);                                      // Get date and ti
             -me (7 bytes)
1325   1      
1326   1          seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);              // Convert BCD to 
             -decimal for seconds (1 byte)
1327   1          minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);              // Convert BCD to 
             -decimal for minutes (1 byte)
1328   1      
1329   1          tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                                   // Get BCD without
             - conversion and check AM/PM
1330   1      
1331   1          if(tempHours & 0x40)                                                                // 12/24 bit (bit 
             -6) is set --> 12 hour mode
1332   1          {
1333   2              timeMode = TWELVE_HR_MODE;
1334   2      
1335   2              if(tempHours & 0x20)                                                            // PM/AM bit (bit 
             -5) is set --> PM
1336   2              {
1337   3                  amPm = 'P';
1338   3              }
1339   2              else
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 26  

1340   2              {
1341   3                  amPm = 'A';
1342   3              }
1343   2          }
1344   1          else
1345   1          {
1346   2              timeMode = TWENTY_FOUR_HR_MODE;
1347   2          }
1348   1      
1349   1          hours = convertBCDToDecimal(tempHours & 0x1F);                                      // Get hours (bit 
             -4 to bit 0 only. Ignore others)
1350   1      
1351   1          if(hours == 12)
1352   1          {
1353   2              if(amPm == 'A')
1354   2              {
1355   3                  hours24 = 0;
1356   3              }
1357   2              else
1358   2              {
1359   3                  hours24 = hours;
1360   3              }   
1361   2          }
1362   1          else
1363   1          {
1364   2              if(amPm == 'P')
1365   2              {
1366   3                  hours24 = hours + 12;                                                       // Twenty four hou
             -r format if PM
1367   3              }
1368   2              else
1369   2              {
1370   3                  hours24 = hours;                                                            // Twenty four hou
             -r format if AM
1371   3              }
1372   2          }
1373   1      
1374   1          day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);                      // Convert BCD to 
             -decimal for day (1 byte)
1375   1          date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);                    // Convert BCD to 
             -decimal for date (1 byte)
1376   1          month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);                  // Convert BCD to 
             -decimal for month (1 byte)
1377   1          year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);                    // Convert BCD to 
             -decimal for year (1 byte)
1378   1      
1379   1          if(month != previousMonth || date != previousDate || year != previousYear)
1380   1          {
1381   2              monthDateYearUpdated = SET;     
1382   2          }
1383   1          if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1384   1          {
1385   2              timeUpdated = SET;
1386   2          }
1387   1      
1388   1          if(amPm == 'P')
1389   1          {
1390   2              currentIndex = ((12 + hours) * 60) + minutes;
1391   2          }
1392   1          else if(amPm == 'A')
1393   1          {
1394   2              if(hours == 12)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 27  

1395   2              {
1396   3                  hours = 0;
1397   3              }
1398   2              
1399   2              currentIndex = (hours * 60) + minutes;
1400   2          }
1401   1          else
1402   1          {}
1403   1      
1404   1          minuteIndex = currentIndex % 60;                                                    // Get minute inde
             -x from 0 - 59
1405   1          hourIndex = currentIndex / 60;                                                      // Get hour index 
             -from 0 - 23
1406   1      
1407   1          previousDate = date;
1408   1          previousMonth = month;
1409   1          previousYear = year;
1410   1          previousHours = hours;
1411   1          previousMinutes = minutes;
1412   1          previousSeconds = seconds;
1413   1      }
1414          
1415          //-------------------------------------------------------------------------------------------------------
1416          // Function Name: moveDateTimeUp
1417          // Return Value: None 
1418          // Parmeters: None
1419          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1420          //-------------------------------------------------------------------------------------------------------
1421          void moveDateTimeUp(void)
1422          {
1423   1          char str[SPRINTF_SIZE];
1424   1          
1425   1          if(realTimeClockItems == MONTH_ADJUST)
1426   1          {
1427   2              adjustedMonth++;
1428   2              monthUpdated = SET;
1429   2      
1430   2              if(adjustedMonth > 12)
1431   2              {
1432   3                  adjustedMonth = 1;                                                          // Roll over
1433   3              }
1434   2      
1435   2              sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1436   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1437   2          }
1438   1          else if(realTimeClockItems == DATE_ADJUST)
1439   1          {
1440   2              adjustedDate++;
1441   2              dateUpdated = SET;
1442   2      
1443   2              if(adjustedDate > 31)
1444   2              {
1445   3                  adjustedDate = 1;                                                           // Roll over
1446   3              }
1447   2      
1448   2              sprintf(str, "%bu   ", adjustedDate);
1449   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1450   2          }
1451   1          else if(realTimeClockItems == YEAR_ADJUST)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 28  

1452   1          {
1453   2              adjustedYear++;
1454   2              yearUpdated = SET;
1455   2      
1456   2              if(adjustedYear > 99)
1457   2              {
1458   3                  adjustedYear = 99;
1459   3              }
1460   2      
1461   2              sprintf(str, "20%02bu", adjustedYear);
1462   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1463   2          }
1464   1          else if(realTimeClockItems == HOUR_ADJUST)
1465   1          {
1466   2              adjustedHours++;
1467   2              hoursUpdated = SET;
1468   2      
1469   2              if(adjustedHours > 12)
1470   2              {
1471   3                  adjustedHours = 1;                                                          // Roll over
1472   3              }
1473   2      
1474   2              sprintf(str, "%bu   ", adjustedHours);
1475   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1476   2          }
1477   1          else if(realTimeClockItems == MINUTE_ADJUST)
1478   1          {
1479   2              adjustedMinutes++;
1480   2              minutesUpdated = SET;
1481   2      
1482   2              if(adjustedMinutes > 59)
1483   2              {
1484   3                  adjustedMinutes = 0;
1485   3              }
1486   2      
1487   2              sprintf(str, "%bu   ", adjustedMinutes);
1488   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1489   2          }
1490   1          else if(realTimeClockItems == AMPM_ADJUST)
1491   1          {
1492   2              if(adjustedAmPm == 'P')
1493   2              {
1494   3                  adjustedAmPm = 'A';
1495   3              }
1496   2              else if(adjustedAmPm == 'A')
1497   2              {
1498   3                  adjustedAmPm = 'P';
1499   3              }
1500   2              else
1501   2              {}
1502   2      
1503   2              amPmUpdated = SET;
1504   2      
1505   2              sprintf(str, "%cM  ", adjustedAmPm);
1506   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1507   2          }
1508   1          else
1509   1          {}
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 29  

1510   1      }
1511          
1512          //-------------------------------------------------------------------------------------------------------
1513          // Function Name: moveDateTimeDown
1514          // Return Value: None 
1515          // Parmeters: None
1516          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1517          //-------------------------------------------------------------------------------------------------------
1518          void moveDateTimeDown(void)
1519          {
1520   1          char str[SPRINTF_SIZE];
1521   1      
1522   1          if(realTimeClockItems == MONTH_ADJUST)
1523   1          {
1524   2              adjustedMonth--;
1525   2              monthUpdated = SET;
1526   2      
1527   2              if(adjustedMonth < 1)
1528   2              {
1529   3                  adjustedMonth = 12;                                                         // Roll over to ho
             -ur 12
1530   3              }
1531   2              sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1532   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1533   2          }
1534   1          else if(realTimeClockItems == DATE_ADJUST)
1535   1          {
1536   2              adjustedDate--;
1537   2              dateUpdated = SET;
1538   2      
1539   2              if(adjustedDate < 1)
1540   2              {
1541   3                  adjustedDate = 31;                                                          // Roll over to da
             -y 31
1542   3              }
1543   2      
1544   2              sprintf(str, "%bu   ", adjustedDate);
1545   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1546   2          }
1547   1          else if(realTimeClockItems == YEAR_ADJUST)
1548   1          {
1549   2              if(adjustedYear > 0)
1550   2              {
1551   3                  adjustedYear--;                                                             // Check if it is 
             -greater than 0 before decrementing                                                
1552   3              }                                                                               // to avoid a nega
             -tive number
1553   2              else
1554   2              {
1555   3                  adjustedYear = 0;                                                           // Roll over to 99
1556   3              }
1557   2              
1558   2              yearUpdated = SET;
1559   2      
1560   2              sprintf(str, "20%02bu", adjustedYear);
1561   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1562   2          }
1563   1          else if(realTimeClockItems == HOUR_ADJUST)
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 30  

1564   1          {
1565   2              if(adjustedHours > 0)
1566   2              {
1567   3                  adjustedHours--;                                                            // Check if it is 
             -greater than 0 before decrementing
1568   3              }                                                                               // to avoid a nega
             -tive number
1569   2              else
1570   2              {
1571   3                  adjustedHours = 12;
1572   3              }
1573   2      
1574   2              hoursUpdated = SET;
1575   2      
1576   2              sprintf(str, "%bu   ", adjustedHours);
1577   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1578   2          }
1579   1          else if(realTimeClockItems == MINUTE_ADJUST)
1580   1          {
1581   2              if(adjustedMinutes > 0)
1582   2              {
1583   3                  adjustedMinutes--;                                                          // Check if it is 
             -greater than 0 before decrementing
1584   3              }                                                                               // to avoid a nega
             -tive number
1585   2              else
1586   2              {
1587   3                  adjustedMinutes = 59;
1588   3              }
1589   2      
1590   2              minutesUpdated = SET;
1591   2      
1592   2              sprintf(str, "%bu   ", adjustedMinutes);
1593   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1594   2          }
1595   1          else if(realTimeClockItems == AMPM_ADJUST)
1596   1          {
1597   2              if(adjustedAmPm == 'P')
1598   2              {
1599   3                  adjustedAmPm = 'A';
1600   3              }
1601   2              else if(adjustedAmPm == 'A')
1602   2              {
1603   3                  adjustedAmPm = 'P';
1604   3              }
1605   2              else
1606   2              {}
1607   2      
1608   2              amPmUpdated = SET;
1609   2      
1610   2              sprintf(str, "%cM  ", adjustedAmPm);
1611   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1612   2          }
1613   1          else
1614   1          {}
1615   1      }
1616          
1617          //-------------------------------------------------------------------------------------------------------
1618          // Function Name: enterDateTime
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 31  

1619          // Return Value: None 
1620          // Parmeters: None
1621          // Function Description: This function confirms the date or time set by the user on the touch screen
1622          //-------------------------------------------------------------------------------------------------------
1623          void enterDateTime(void)
1624          {
1625   1          char str[SPRINTF_SIZE];
1626   1          
1627   1          realTimeClockItems++;                                                               // Move to next it
             -em
1628   1          
1629   1          if(realTimeClockItems == MONTH_ADJUST)
1630   1          {
1631   2              monthUpdated = SET;
1632   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1633   2              sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1634   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1635   2          }
1636   1          else if(realTimeClockItems == DATE_ADJUST)
1637   1          {
1638   2              dateUpdated = SET;
1639   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1640   2              sprintf(str, "%bu   ", adjustedDate);
1641   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1642   2          }
1643   1          else if(realTimeClockItems == YEAR_ADJUST)
1644   1          {
1645   2              yearUpdated = SET;
1646   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1647   2              sprintf(str, "20%02bu", adjustedYear);
1648   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1649   2          }
1650   1          else if(realTimeClockItems == HOUR_ADJUST)
1651   1          {
1652   2              hoursUpdated = SET;
1653   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1654   2              sprintf(str, "%bu   ", adjustedHours);
1655   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1656   2          }
1657   1          else if(realTimeClockItems == MINUTE_ADJUST)
1658   1          {
1659   2              minutesUpdated = SET;
1660   2              amPmUpdated = SET;                                                              // Set it anyway b
             -ecause user usually does not set at the end
1661   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1662   2              sprintf(str, "%bu   ", adjustedMinutes);
1663   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1664   2          }
1665   1          else if(realTimeClockItems == AMPM_ADJUST)
1666   1          {
1667   2              amPmUpdated = SET;                                                              // Set it anyway b
             -ecause user usually does not set at the end
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 32  

1668   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1669   2              sprintf(str, "%cM  ", adjustedAmPm);
1670   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1671   2          }
1672   1          else if(realTimeClockItems == DONE_ADJUST)
1673   1          {
1674   2              amPmUpdated = SET;                                                              // Set it if user 
             -explicitly press enter button
1675   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1676   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE
             -_DISPLAY_Y);
1677   2          }
1678   1          else if(realTimeClockItems == ROLL_OVER_ADJUST)
1679   1          {
1680   2              realTimeClockItems = MONTH_ADJUST;                                              // Set it for next
             - round of real time clock items
1681   2              monthUpdated = SET;
1682   2              displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X,
             - TITLE_DISPLAY_Y);
1683   2              sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1684   2              displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DI
             -SPLAY_Y);
1685   2          }
1686   1          else
1687   1          {}
1688   1      }
1689          
1690          //-------------------------------------------------------------------------------------------------------
1691          // Function Name: setClockOnScreen
1692          // Return Value: None 
1693          // Parmeters: None
1694          // Function Description: This function sets the real time clock on the touch screen
1695          //-------------------------------------------------------------------------------------------------------
1696          void setClockOnScreen(void)
1697          {       
1698   1          unsigned char hoursAux;
1699   1          
1700   1          if(monthUpdated == SET)
1701   1          {
1702   2              sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);      // Get updated mon
             -th from user on screen
1703   2              writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);                           // Set month only 
             -(1 byte)
1704   2              monthUpdated = CLEAR;                                                           //Clear flag after
             - writing to real time clock                                                   
1705   2          }
1706   1          
1707   1          if(dateUpdated == SET)
1708   1          {
1709   2              sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);        // Get updated dat
             -e from user on screen
1710   2              writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);                            // Set date only (
             -1 byte)
1711   2              dateUpdated = CLEAR;
1712   2          }
1713   1      
1714   1          if(yearUpdated == SET)
1715   1          {
1716   2              sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);        // Get updated yea
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 33  

             -r from user on screen
1717   2              writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);                            // Set year only (
             -1 byte)
1718   2              yearUpdated = CLEAR;
1719   2          }
1720   1      
1721   1          if(hoursUpdated == SET || amPmUpdated == SET)
1722   1          {
1723   2              hoursAux = convertDecimalToBCD(adjustedHours);                                  // Get updated hou
             -rs from user on screen
1724   2              
1725   2              if(amPmUpdated == SET)
1726   2              {
1727   3                  amPm = adjustedAmPm;                                                        // Set updated amP
             -m from user on screen
1728   3              
1729   3                  hoursAux = hoursAux | 0x40;                                                 // Set 12/24 bit -
             --> 12 hour mode
1730   3                  
1731   3                  if(adjustedAmPm == 'P')
1732   3                  {                                                                   
1733   4                      hoursAux = hoursAux | 0x60;                                             // Set AM/PM bit -
             --> PM mode
1734   4                  }
1735   3                  else if(adjustedAmPm == 'A')
1736   3                  {                                                                   
1737   4                      hoursAux = hoursAux & 0x5F;                                             // Clear AM/PM bit
             - --> AM mode
1738   4                  }
1739   3                  else
1740   3                  {}
1741   3      
1742   3                  amPmUpdated = CLEAR;
1743   3              }
1744   2              
1745   2              sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1746   2              writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);                           // Set hours only 
             -(1 byte)
1747   2              hoursUpdated = CLEAR; 
1748   2          }
1749   1      
1750   1          if(minutesUpdated == SET)
1751   1          {
1752   2              sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes);  // Get updated min
             -utes from user on screen
1753   2              writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);                         // Set minutes onl
             -y (1 byte)
1754   2              minutesUpdated = CLEAR;
1755   2          }
1756   1      
1757   1          realTimeClockItems = MONTH_ADJUST;                                                  // Set starting it
             -em = Month for adjustment
1758   1      
1759   1          getClockData();                                                                     // Get current mon
             -th, date, year set by user
1760   1      
1761   1          //clockSetupDisplayRepeat = 0;                                                      // Display clock u
             -pdates on screen                                                                      // System goes back to main page  
             -                  
1762   1      }
1763          
1764          //-------------------------------------------------------------------------------------------------------
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 34  

1765          // Function Name: resetClock
1766          // Return Value: None 
1767          // Parmeters: None
1768          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1769          //-------------------------------------------------------------------------------------------------------
1770          void resetClock(void)
1771          {
1772   1          seconds = 0;
1773   1          minutes = 0;
1774   1          hours = 0;
1775   1          amPm = 'P';
1776   1          day = 1;
1777   1          date = 1;
1778   1          month = 1;
1779   1          year = 0;
1780   1          century = 0;
1781   1          timeMode = 1;
1782   1      
1783   1          setClock();                                                                         // Set real time c
             -lock
1784   1      }
1785          
1786          //-------------------------------------------------------------------------------------------------------
1787          // Function Name: convertDecimalToBCD
1788          // Return Value: bcd 
1789          // Parmeters: decimal
1790          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1791          //-------------------------------------------------------------------------------------------------------
1792          unsigned char convertDecimalToBCD(unsigned char decimal)
1793          {
1794   1          unsigned char bcd;
1795   1      
1796   1          bcd = (decimal / 10) << 4;                                                          // Get upper 4 bit
             -s
1797   1          bcd = bcd | (decimal % 10);                                                         // Get a BCD
1798   1      
1799   1          return bcd;
1800   1      }
1801          
1802          //-------------------------------------------------------------------------------------------------------
1803          // Function Name: convertBCDToDecimal
1804          // Return Value: decimal value 
1805          // Parmeters: bcd
1806          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1807          //-------------------------------------------------------------------------------------------------------
1808          unsigned char convertBCDToDecimal(unsigned char bcd)
1809          {
1810   1          unsigned char decimal;
1811   1      
1812   1          decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                                         // Combine upper a
             -nd lower nibbles to get
1813   1                                                                                              // 8 bit number
1814   1          return decimal;
1815   1      }
1816          
1817          //-------------------------------------------------------------------------------------------------------
1818          // Function Name: displayClock
1819          // Return Value: None 
1820          // Parmeters: None
1821          // Function Description: This function displays clock data on the touch screen
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 35  

1822          // The clock format is MM/DD/YYYY hour/minute/second
1823          //-------------------------------------------------------------------------------------------------------
1824          void displayClock(void)
1825          {
1826   1          char str[SPRINTF_SIZE];
1827   1          
1828   1          //if(screen == MAIN_PAGE)
1829   1          //{
1830   1              getClockData();
1831   1      
1832   1              sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1833   1              displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS
             -_DATE_Y);
1834   1              monthDateYearUpdated = CLEAR;
1835   1              
1836   1              sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1837   1              displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS
             -_TIME_Y);
1838   1          //}
1839   1          /*else if(screen == CLOCK_SETUP_PAGE)
1840   1          {
1841   1              if(buttonPressed == CLEAR)
1842   1              {
1843   1                  getClockData();
1844   1          
1845   1                  sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1846   1                  displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DIS
             -PLAY_Y);
1847   1                  monthDateYearUpdated = CLEAR;
1848   1      
1849   1                  sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1850   1                  displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DIS
             -PLAY_Y);
1851   1                  timeUpdated = CLEAR;
1852   1              }
1853   1          }*/
1854   1      }
1855          
1856          //-------------------------------------------------------------------------------------------------------
1857          // Main
1858          //-------------------------------------------------------------------------------------------------------
1859          
1860          
1861          //------------------------------------------------------------------------------------------------------
1862          // Utility functions by team 1 
1863          //------------------------------------------------------------------------------------------------------
1864          
1865          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1866          {
1867   1          char str[128] = { 0 };
1868   1          
1869   1          int i = 0;
1870   1          while(i < 10000) i++;
1871   1              
1872   1          sprintf(str, "S %s %s\r", fg, bg);
1873   1          sendCommand(str);
1874   1          sprintf(str, "f %s\r", Font[size]);
1875   1          sendCommand(str);
1876   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1877   1          sendCommand(str);
1878   1      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 36  

1879          
1880          static void send_macro(const unsigned int macro_index)
1881          {
1882   1          char str[8] = { 0 };
1883   1          
1884   1          int i = 0;
1885   1          while(i < 10000) i++;
1886   1              
1887   1          sprintf(str, "m %u\r", macro_index);
1888   1          sendCommand(str);
1889   1      }
1890          
1891          int handle_passcode(int k){
1892   1              int isValid = 0,i = 0;
1893   1              char str[SPRINTF_SIZE];
1894   1              sprintf(str, "%s", "    ");
1895   1              display_text("000000", "FFFFFF", 8, str, 240, 40);
1896   1              if(k == 0){
1897   2                  passcode[0]='\0';
1898   2              }
1899   1              
1900   1              if ('1' == userCommand[1] && '4' == userCommand[2] && '1' == userCommand[3]) {
1901   2                      strcat(passcode,"1");
1902   2                      isValid = 1;
1903   2              }
1904   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '2' == userCommand[3]) {
1905   2                      strcat(passcode,"2");
1906   2                      isValid = 1;
1907   2              }
1908   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '3' == userCommand[3]) {
1909   2                      strcat(passcode,"3");
1910   2                      isValid = 1;
1911   2              }
1912   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '4' == userCommand[3]) {
1913   2                      strcat(passcode,"4");
1914   2                      isValid = 1;
1915   2              }
1916   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '5' == userCommand[3]) {
1917   2                      strcat(passcode,"5");
1918   2                      isValid = 1;
1919   2              }
1920   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '6' == userCommand[3]) {
1921   2                      strcat(passcode,"6");
1922   2                      isValid = 1;
1923   2              }
1924   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '7' == userCommand[3]) {
1925   2                      strcat(passcode,"7");
1926   2                      isValid = 1;
1927   2              }
1928   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '8' == userCommand[3]) {
1929   2                      strcat(passcode,"8");
1930   2                      isValid = 1;
1931   2              }
1932   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '9' == userCommand[3]) {
1933   2                      strcat(passcode,"9");
1934   2                      isValid = 1;
1935   2              }
1936   1              else if ('1' == userCommand[1] && '4' == userCommand[2] && '0' == userCommand[3]) {
1937   2                      strcat(passcode,"0");
1938   2                      isValid = 1;
1939   2              }
1940   1              else if ('1' == userCommand[1] && '5' == userCommand[2] && '0' == userCommand[3]) {
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 37  

1941   2                      strcat(passcode,"*");
1942   2                      isValid = 1;
1943   2              }
1944   1              else if ('1' == userCommand[1] && '5' == userCommand[2] && '1' == userCommand[3]) {
1945   2                      strcat(passcode,"#");
1946   2                      isValid = 1;
1947   2              }
1948   1              if(isValid){
1949   2                  str[0] = '\0';
1950   2                  for(i=0;i<=k;i++){
1951   3                      strcat(str,"*");
1952   3                  }
1953   2              }
1954   1              //sprintf(str, "%s", passcode);
1955   1              display_text("000000", "FFFFFF", 6, str, 240, 80);
1956   1              return isValid;
1957   1      }
1958          
1959          
1960          void display_time(unsigned char Seconds_l, unsigned char Minutes_l, unsigned char Hours_l, unsigned char A
             -mPm, unsigned char Date_l, unsigned char Month_l, unsigned char Year_l) {
1961   1              char *str;
1962   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[Month_l], Date_l, Year_l);
1963   1          display_text("000000","FFFFFF",8,str, 240,100);
1964   1          
1965   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", Hours_l, Minutes_l, Seconds_l, AmPm);
1966   1          display_text("000000","FFFFFF",8,str, 400,100);
1967   1      }
1968          
1969          
1970          void set_Clock(void)
1971          {
1972   1          //154 - previous, 155 - next, 156 - enter, 157 -> value - 1, 158 -> value + 1;
1973   1          getClockData();
1974   1          seconds_l = seconds;
1975   1          minutes_l = minutes;
1976   1          hours_l = hours;
1977   1          amPm_l = amPm;
1978   1          date_l = date;
1979   1          month_l = month;
1980   1          year_l = year;
1981   1      
1982   1          
1983   1          set = 0;
1984   1          selection = 0;
1985   1          
1986   1          while (!set) {
1987   2              display_text("000000","FFFFFF",8,setDateTime[selection], 400,100);
1988   2              if (selection == 0) { //to set seconds in time
1989   3                  
1990   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
1991   4                      //increase seconds
1992   4                      if (seconds_l == 59) {
1993   5                          seconds_l = 0;
1994   5                      }
1995   4                      else {
1996   5                          seconds_l += 1;
1997   5                      }
1998   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
1999   4                  }
2000   3                  
2001   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 38  

2002   4                      //decrease seconds
2003   4                      if (seconds_l == 0) {
2004   5                          seconds_l = 59;
2005   5                      }
2006   4                      else {
2007   5                          seconds_l -= 1;
2008   5                      }
2009   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2010   4                  }
2011   3              }
2012   2              
2013   2              else if (selection == 1) { //to set minutes
2014   3                  
2015   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2016   4                      //increase seconds
2017   4                      if (minutes_l == 59) {
2018   5                          minutes_l = 0;
2019   5                      }
2020   4                      else {
2021   5                          minutes_l += 1;
2022   5                      }
2023   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2024   4                  }
2025   3                  
2026   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2027   4                      //decrease seconds
2028   4                      if (minutes_l == 0) {
2029   5                          minutes_l = 59;
2030   5                      }
2031   4                      else {
2032   5                          minutes_l -= 1;
2033   5                      }
2034   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2035   4                  }
2036   3              }
2037   2              
2038   2              else if (selection == 2) { //to set hours
2039   3                  
2040   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2041   4                      //increase hours
2042   4                      if (hours_l == 12) {
2043   5                          hours_l = 1;
2044   5                      }
2045   4                      else {
2046   5                          hours_l += 1;
2047   5                      }
2048   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2049   4                  }
2050   3                  
2051   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2052   4                      //decrease hours
2053   4                      if (hours_l == 0) {
2054   5                          hours_l = 12;
2055   5                      }
2056   4                      else {
2057   5                          hours_l -= 1;
2058   5                      }
2059   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,  date_l, month_l, year_l);
2060   4                  }
2061   3              }
2062   2              
2063   2              else if (selection == 3) { //to set Am/ Pm
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 39  

2064   3                  
2065   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2066   4                      //changes AM / PM
2067   4                      if (amPm_l == 'P') {
2068   5                          amPm_l = 'A';
2069   5                      }
2070   4                      else {
2071   5                          amPm_l = 'P';
2072   5                      }
2073   4                     display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2074   4                  }
2075   3                  
2076   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2077   4                      //changes AM / PM
2078   4                      if (amPm_l == 'P') {
2079   5                          amPm_l = 'A';
2080   5                      }
2081   4                      else {
2082   5                          amPm_l = 'P';
2083   5                      }
2084   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2085   4                  }
2086   3              }
2087   2              
2088   2              else if (selection == 4) { //to set date
2089   3                  
2090   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2091   4                      //increase date
2092   4                      if (date_l == 31) {
2093   5                          date_l = 1;
2094   5                      }
2095   4                      else {
2096   5                          date_l += 1;
2097   5                      }
2098   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,  date_l, month_l, year_l);
2099   4                  }
2100   3                  
2101   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2102   4                      //decrease date
2103   4                      if (date_l == 1) {
2104   5                          date_l = 31;
2105   5                      }
2106   4                      else {
2107   5                          date_l -= 1;
2108   5                      }
2109   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2110   4                  }
2111   3              }
2112   2              
2113   2              else if (selection == 5) { //to set month
2114   3                  
2115   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2116   4                      //increase month
2117   4                      if (month_l == 12) {
2118   5                          month_l = 1;
2119   5                      }
2120   4                      else {
2121   5                          month_l += 1;
2122   5                      }
2123   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,    date_l, month_l, year_l);
2124   4                  }
2125   3                  
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 40  

2126   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2127   4                      //decrease month
2128   4                      if (month_l == 1) {
2129   5                          month_l = 12;
2130   5                      }
2131   4                      else {
2132   5                          month_l -= 1;
2133   5                      }
2134   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,    date_l, month_l, year_l);
2135   4                  }
2136   3              }
2137   2              
2138   2              else if (selection == 6) { //to set year
2139   3                  
2140   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2141   4                      //increase year
2142   4                      year_l += 1;
2143   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,    date_l, month_l, year_l);
2144   4                  }
2145   3                  
2146   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2147   4                      //decrease year
2148   4                      year_l -= 1;
2149   4                      display_time(seconds_l, minutes_l, hours_l, amPm_l,    date_l, month_l, year_l);
2150   4                  }
2151   3              }
2152   2              
2153   2              
2154   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '4' == userCommand[3]) {
2155   3                  //previous in menu
2156   3                  if (selection == 0) {
2157   4                      selection = 6;
2158   4                  }
2159   3                  else {
2160   4                      selection -= 1;
2161   4                  }
2162   3                  
2163   3              }
2164   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '5' == userCommand[3]) {
2165   3                  //next in menu
2166   3                  if (selection == 6) {
2167   4                      selection = 0;
2168   4                  }
2169   3                  else {
2170   4                      selection += 1;
2171   4                  }
2172   3                  
2173   3              }
2174   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2175   3                  // store the values (Enter is pressed)
2176   3                  seconds = seconds_l;
2177   3                  minutes = minutes_l;
2178   3                  hours = hours_l;
2179   3                  amPm = amPm_l;
2180   3                  //day = day_l;
2181   3                  date = date_l;
2182   3                  month = month_l;
2183   3                  year = year_l;
2184   3                  set = 1;
2185   3              }
2186   2              
2187   2          }
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 41  

2188   1          
2189   1          setClock();                                                                            // Set real tim
             -e clock
2190   1      }
2191          
2192          //-------------------------------------------------------------------------------------------------------
2193          // Main
2194          //-------------------------------------------------------------------------------------------------------
2195          
2196          #define PAGE_MAIN            1
2197          #define PAGE_SETTINGS        2
2198          #define PAGE_SERVICE         3
2199          #define PAGE_CONFIG          4
2200          int current_page = PAGE_MAIN;
2201          int buffer[5];
2202          
2203          
2204          void main()
2205          {
2206   1          int i = 0;
2207   1          int count = 0;
2208   1          int prev_temp = 0;
2209   1          int display_celsius = 0;
2210   1          int state_changed = 1;
2211   1          char str[SPRINTF_SIZE];
2212   1          
2213   1          disableWatchdog();
2214   1          systemClockInit();
2215   1          portInit();
2216   1          enableInterrupts();
2217   1          uart0Init();
2218   1          smbInit();
2219   1          timer3Init();
2220   1          
2221   1          tsLastCharGone = 1;
2222   1          tsTxOut = tsTxIn = 0;
2223   1          tsTxEmpty = 1;
2224   1          
2225   1          sprintf(str, "z\r");
2226   1          sendCommand(str);
2227   1          
2228   1          send_macro(display_temperature);
2229   1          
2230   1      
2231   1          while(1)
2232   1          {
2233   2              buffer[0] = userCommand[0];
2234   2              buffer[1] = userCommand[1];
2235   2              buffer[2] = userCommand[2];
2236   2              buffer[3] = userCommand[3];
2237   2              buffer[4] = '\0';
2238   2      
2239   2              display_text("000000", "FFFFFF", 8, buffer, 0, 0);
*** WARNING C182 IN LINE 2239 OF main.c: pointer to different objects
2240   2      
2241   2              switch(current_page) 
2242   2              {
2243   3                  case (PAGE_SETTINGS):
2244   3                  {
2245   4                      if (state_changed) {
2246   5                          state_changed = 0;
2247   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 42  

2248   4      
2249   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2250   5                          current_page = PAGE_SETTINGS;
2251   5                          state_changed = 1;
2252   5                      }
2253   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2254   5                          current_page = PAGE_MAIN;
2255   5                          state_changed = 1;
2256   5                      }
2257   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2258   5                          current_page = PAGE_SERVICE;
2259   5                          state_changed = 1;
2260   5                      }
2261   4                      else 
2262   4                      {
2263   5                          // for (k = 0; k < 4 ; )
2264   5                          // {                      
2265   5                          //     while(tsCommandReceived == 0);
2266   5                              
2267   5                          //     if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2268   5                          //         current_page = PAGE_SETTINGS;
2269   5                          //         state_changed = 1;
2270   5                          //     }
2271   5                          //     else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3
             -]) {
2272   5                          //         current_page = PAGE_MAIN;
2273   5                          //         state_changed = 1;
2274   5                          //     }
2275   5                          //     else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3
             -]) {
2276   5                          //         current_page = PAGE_SERVICE;
2277   5                          //         state_changed = 1;
2278   5                          //     }
2279   5                          //     else if ('1' == userCommand[1] && '5' == userCommand[2] && '3' == userCommand[3
             -]) 
2280   5                          //     {
2281   5                          //         if (strcmp(passcode,ACTUAL) == 0){
2282   5                          //             display_text("000000","FFFFFF",6,"OK!", 240,200);
2283   5                          //         }
2284   5                          //         else {
2285   5                          //             display_text("000000","FFFFFF",6,"INCORRECT!", 160,200);
2286   5                          //             k = 0;
2287   5                          //             sprintf(str,"%s","");
2288   5                          //             display_text("000000","FFFFFF",6,str, 240,40);
2289   5                          //         }
2290   5                          //         continue;
2291   5                          //     }
2292   5                          //     else if ('1' == userCommand[1] && '5' == userCommand[2] && '2' == userCommand[3
             -]) 
2293   5                          //     {
2294   5                          //         size_t len = strlen(passcode);
2295   5                          //         if (len > 0) {
2296   5                          //             passcode[len-1]=0;
2297   5                          //         }
2298   5                          //         else if (k < 4) {
2299   5                          //             if(handle_passcode(k)) {
2300   5                          //                 k++;
2301   5                          //             }
2302   5                          //         }
2303   5                          //     }
2304   5                          // }
2305   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 43  

2306   4                      break;
2307   4                  }
2308   3                  case (PAGE_CONFIG):
2309   3                  {
2310   4                      if (state_changed) {
2311   5                          state_changed = 0;
2312   5                          display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
2313   5                      }
2314   4      
2315   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2316   5                          current_page = PAGE_SETTINGS;
2317   5                          state_changed = 1;
2318   5                      }
2319   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2320   5                          current_page = PAGE_MAIN;
2321   5                          state_changed = 1;
2322   5                      }
2323   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2324   5                          current_page = PAGE_SERVICE;
2325   5                          state_changed = 1;
2326   5                      }
2327   4                      else {
2328   5                          set_Clock();
2329   5                      }
2330   4                      break;
2331   4                  }
2332   3                  case (PAGE_SERVICE):
2333   3                  {
2334   4                      if (state_changed) {
2335   5                          state_changed = 0;
2336   5                          display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2337   5                      }
2338   4      
2339   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2340   5                          current_page = PAGE_SETTINGS;
2341   5                          state_changed = 1;
2342   5                      }
2343   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2344   5                          current_page = PAGE_MAIN;
2345   5                          state_changed = 1;
2346   5                      }
2347   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2348   5                          current_page = PAGE_SERVICE;
2349   5                          state_changed = 1;
2350   5                      }
2351   4                      else {
2352   5                          // NOOP
2353   5                      }
2354   4                      break;
2355   4                  }
2356   3      
2357   3                  default:            // no break
2358   3                  case (PAGE_MAIN) :
2359   3                  {
2360   4                      roomTemp1 = readOneByteFromSlave(ROOM_TEMP_1);
2361   4      
2362   4                      if (state_changed) {
2363   5                          state_changed = 0;
2364   5                          sprintf(str, "%-3buC", roomTemp1);
2365   5                          display_text("000000", "FFFFFF", 8, str, 240, 110);
2366   5                      }
2367   4                      
C51 COMPILER V9.56.0.0   MAIN                                                              11/28/2017 20:22:26 PAGE 44  

2368   4                      if (tsCommandReceived || roomTemp1 != prev_temp) 
2369   4                      {
2370   5                          prev_temp = roomTemp1;
2371   5                          
2372   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
2373   6                              display_celsius = 1;
2374   6                              sprintf(str, "%-3buC", roomTemp1);
2375   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
2376   6                          }
2377   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2378   6                              display_celsius = 0;
2379   6                              roomTemp1 = (roomTemp1 * 9) / 5 + 32;
2380   6                              sprintf(str, "%-3buF", roomTemp1);
2381   6                              display_text("000000", "FFFFFF", 8, str, 240, 110);
2382   6                          }
2383   5                          else {
2384   6                              display_text("000000", "FFFFFF", 8, "BAD", 240, 110);
2385   6                          }
2386   5                      }
2387   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2388   5                          current_page = PAGE_SETTINGS;
2389   5                          state_changed = 1;                    
2390   5                      }
2391   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2392   5                          current_page = PAGE_MAIN;
2393   5                          state_changed = 1;
2394   5                      }
2395   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2396   5                          current_page = PAGE_SERVICE;
2397   5                          state_changed = 1;
2398   5                      }
2399   4                      else {
2400   5                          // Noop
2401   5                      }
2402   4                      break;
2403   4                  }
2404   3              }
2405   2          }
2406   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   9057    ----
   CONSTANT SIZE    =    711    ----
   XDATA SIZE       =   3546     992
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
