C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          
   8          //edits - added new
   9          
  10          //Passcode
  11          int k = 0;
  12          char passcode[] = "";
  13          char *ACTUAL = "1457";
  14          
  15          // real time clock
  16          unsigned char seconds_l;
  17          unsigned char minutes_l;
  18          unsigned char hours_l;
  19          unsigned char amPm_l;
  20          unsigned char date_l;
  21          unsigned char month_l;
  22          unsigned char year_l;
  23          unsigned char selection;
  24          unsigned char set;
  25          
  26          const char code *setDateTime[] =  {/*0*/  "SET SECONDS",
  27              /*1*/ "SET MINUTES",
  28              /*2*/ "SET HOURS",
  29              /*3*/ "SET AM/PM",
  30              /*4*/ "SET DATE",
  31              /*5*/ "SET MONTH",
  32              /*6*/ "SET YEAR"};
  33          
  34          
  35          //original code's variables
  36          
  37          unsigned char tsByte;
  38          
  39          bit sliderCommandReceived = 0;
  40          bit splashEnd = 0;
  41          bit screenReset = 0;
  42          bit ackFromScreen = 0;
  43          bit tsCommandReceived = 0;
  44          bit tsCommandTransmitted = 0;
  45          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  46          
  47          unsigned char sharedDataRx[SHARED_DATA_MAX];
  48          unsigned char sharedDataTx[SHARED_DATA_MAX];
  49          unsigned char eepromTx[EEPROM_TX_BUFFER];
  50          unsigned char eepromRx[EEPROM_RX_BUFFER];
  51          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  52          
  53          unsigned int pageCount;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 2   

  54          unsigned int bytesExtra;
  55          unsigned int eepromPageCounter;
  56          unsigned int startAddr;
  57          unsigned char slaveAddr;                                                // Target SMBus slave address
  58          unsigned char eepromDataByte;
  59          
  60          unsigned int numBytesRD;
  61          unsigned int numBytesWR;
  62          unsigned char slaveWriteDone;
  63          unsigned char slaveReadDone;
  64          unsigned char eepromWriteDone;
  65          unsigned char eepromReaddone;
  66          unsigned char rtcWriteDone;
  67          unsigned char rtcReadDone;
  68          
  69          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  70          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  71          unsigned char userCommand[RX_BUFFER_SIZE];
  72          
  73          unsigned int tsRxIn;
  74          unsigned int tsRxOut; 
  75          unsigned int tsTxIn;
  76          unsigned int tsTxOut;
  77          
  78          bit tsRxEmpty;
  79          bit tsTxEmpty;
  80          bit tsLastCharGone; 
  81          
  82          bit screenChanged;
  83          unsigned char screen;
  84          unsigned char lastScreen;
  85          
  86          const char code * Font[] = {/*0*/ "m10B", 
  87              /*1*/ "m12B",
  88              /*2*/ "m14B",
  89              /*3*/ "m16B",
  90              /*4*/ "m20B",
  91              /*5*/ "m24B",
  92              /*6*/ "m32B",
  93              /*7*/ "m48",
  94              /*8*/ "m64"};
  95          
  96          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  97          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  98          
  99          unsigned int startAddr;
 100          unsigned char slaveAddr;                                                // Target SMBus slave address
 101          
 102          unsigned int numBytesRD;
 103          unsigned int numBytesWR;
 104          
 105          unsigned char slaveWriteDone;
 106          unsigned char slaveReadDone;
 107          
 108          unsigned char roomTemp1;
 109          unsigned char roomTemp2;
 110          unsigned char roomTemp3;
 111          
 112          unsigned char seconds;
 113          unsigned char minutes;
 114          unsigned char hours;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 3   

 115          unsigned char hours24;
 116          unsigned char amPm;
 117          unsigned char day;
 118          unsigned char date;
 119          unsigned char month;
 120          unsigned char year;
 121          unsigned char century;
 122          unsigned char timeMode;
 123          unsigned char currentIndex = 0;
 124          unsigned char minuteIndex = 0;
 125          unsigned char hourIndex = 0;
 126          
 127          unsigned char currentDate;
 128          unsigned char currentMonth;
 129          unsigned char currentYear;
 130          
 131          unsigned char realTimeClockItems;
 132          
 133          unsigned char adjustedSeconds;
 134          unsigned char adjustedMinutes;
 135          unsigned char adjustedHours;
 136          unsigned char adjustedAmPm;
 137          unsigned char adjustedDay;
 138          unsigned char adjustedDate;
 139          unsigned char adjustedMonth;
 140          unsigned char adjustedYear;
 141          unsigned char adjustedCentury;
 142          unsigned char adjustedTimeMode;
 143          
 144          bit monthUpdated;
 145          bit dateUpdated;
 146          bit yearUpdated;
 147          bit hoursUpdated;
 148          bit minutesUpdated;
 149          bit secondsUpdated;
 150          bit amPmUpdated;
 151          bit timeUpdated;
 152          bit monthDateYearUpdated;
 153          
 154          const char code * dayOfWeek[] =   {/*0*/  "NON",
 155              /*1*/ "SUN",
 156              /*2*/ "MON",
 157              /*3*/ "TUE",
 158              /*4*/ "WED",
 159              /*5*/ "THU",
 160              /*6*/ "FRI",
 161              /*7*/ "SAT"};
 162          
 163          const char code * monthOfYear[] =   {/*0*/  "NON",
 164              /*1*/ "JAN",
 165              /*2*/ "FEB",
 166              /*3*/ "MAR",
 167              /*4*/ "APR",
 168              /*5*/ "MAY",
 169              /*6*/ "JUN",
 170              /*7*/ "JUL",
 171              /*8*/ "AUG",
 172              /*9*/ "SEP",
 173              /*10*/  "OCT",
 174              /*11*/  "NOV",
 175              /*12*/  "DEC"};
 176          
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 4   

 177          
 178          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 179              /*1*/ "WRITING DATA... WAIT!  ",
 180              /*2*/ "DATA SUCCESSFULLY SAVED",
 181              /*3*/ "ERROR                  "};
 182          
 183          //-------------------------------------------------------------------------------------------------------
 184          // System Configurations
 185          //-------------------------------------------------------------------------------------------------------
 186          void systemClockInit(void)
 187          {
 188   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 189   1          int i = 0;
 190   1          
 191   1          SFRPAGE  = CONFIG_PAGE;
 192   1          
 193   1          OSCICN    = 0x83;
 194   1          
 195   1          SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 196   1      }
 197          
 198          void portInit(void)
 199          {
 200   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 201   1          
 202   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
 203   1          
 204   1          XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4
 205   1          XBR1 = 0x01;
 206   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up
 207   1          
 208   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 209   1          // TX0 = P0.0; RX0 = P0.1
 210   1          P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 211   1          // TX1 = P1.0; RX1 = P1.1
 212   1          P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pul
             -l
 213   1          
 214   1          P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 215   1          
 216   1          P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 217   1          
 218   1          P6MDOUT = 0x00;
 219   1          
 220   1          P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 221   1          
 222   1          P0 = 0xFF;                                  // Initialize port P0 latch
 223   1          P1 = 0xFF;                                  // Initialize port P1 latch
 224   1          P2 = 0xFF;                                  // Initialize port P2 latch
 225   1          P3 = 0xFF;                                  // Initialize port P3 latch
 226   1          P4 = 0xFF;                                  // Initialize port P4 latch
 227   1          P5 = 0xFF;                                  // Initialize port P5 latch
 228   1          P6 = 0xFF;                                  // Initialize port P6 latch
 229   1          P7 = 0xFF;                                  // Initialize port P7 latch
 230   1          
 231   1          RHW = 0;                                  // Pull low SMB error line
 232   1          
 233   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 234   1      }
 235          
 236          void enableInterrupts(void)
 237          {
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 5   

 238   1          IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
 239   1          EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 240   1          EIE2 |= 0x40;                               // Enable UART1 interrupt
 241   1          EIE1 |= 0x0A;                               // Enable SMBus interrupt
 242   1      }
 243          
 244          void uart0Init(void)
 245          {
 246   1          char SFRPAGE_SAVE;
 247   1          
 248   1          SFRPAGE_SAVE = SFRPAGE;                                             // Preserve SFRPAGE
 249   1          
 250   1          SFRPAGE = TMR2_PAGE;
 251   1          TMR2CN = 0x00;                                                      // Stop timer. Timer 2 in 16-bit auto
             --reload up timer mode
 252   1          TMR2CF = 0x08;                                                      // SYSCLK is time base; no output; up
             - count only
 253   1          RCAP2L = 0xF3;                                                               // Low byte
 254   1          RCAP2H = 0xFF;                                                               // High byte
 255   1          TMR2 = RCAP2;                                                                // Load 16 bit reload val
             -ue into timer 2
 256   1          TMR2CN = 0x04;                                                               // Enable timer 2 (Start 
             -timer 2)
 257   1          
 258   1          SFRPAGE = UART0_PAGE;
 259   1          SCON0 = 0x50;                                                       // 8-bit variable baud rate; 9th bit 
             -ignored; RX enabled
 260   1          SSTA0 = 0x05;                                                       // Enable baud rate
 261   1          // Use timer 2 as RX and TX baud rate source
 262   1          IE = 0x90;                                                                   // Enable all interrupts 
             -and UART0 Interrupt
 263   1          
 264   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 265   1      }
 266          
 267          void disableWatchdog(void)
 268          {
 269   1          WDTCN = 0xDE;                                               // Disable watchdog timer
 270   1          WDTCN = 0xAD;
 271   1      }
 272          
 273          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 274          {
 275   1          char SFRPAGE_SAVE = SFRPAGE;
 276   1          unsigned int i = 0;
 277   1          unsigned long txWaitCounter = 0;
 278   1          
 279   1          SFRPAGE = UART0_PAGE;
 280   1          
 281   1          if(RI0 == 1)                                                        // There is a char in SBUF
 282   1          {
 283   2              RI0 = 0;                                                    // Clear interrupt flag
 284   2              
 285   2              tsByte = SBUF0;                                             // Read a character from UART
 286   2              
 287   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 288   2              {
 289   3                  if(tsByte != '\r')                          // Check end of a command from touch screen
 290   3                  {
 291   4                      tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 292   4                      tsRxIn++;                           // Increment index
 293   4                  }
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 6   

 294   3                  else                                // If it is CR character, it marks end of command
 295   3                  {
 296   4                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 297   4                      {
 298   5                          if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[
             -4] == 'e' && tsRxBuffer[5] == '}')
 299   5                          {
 300   6                              splashEnd = 1;                                        // Detect end of splash scree
             -n
 301   6                              screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 302   6                          }
 303   5                          else
 304   5                          {
 305   6                              splashEnd = 0;                                          // End of splash screen NO
             -T detected
 306   6                              screenReset = 0;
 307   6                          }
 308   5                      }
 309   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 310   4                      {                                                               // A command starts with '
             -('
 311   5                          for(i = 0; i < tsRxIn; i++)
 312   5                          {
 313   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 314   6                          }
 315   5                          
 316   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 317   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 318   5                      }
 319   4                      else if (tsRxBuffer[0] == 'l')
 320   4                      {
 321   5                          for(i = 0; i < tsRxIn; i++)
 322   5                          {
 323   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 324   6                          }
 325   5                          userCommand [i] = '\0';
 326   5                          sliderCommandReceived = 1;
 327   5      
 328   5                      }
 329   4                      else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 330   4                      {                               // A command starts with '('
 331   5                          for(i = 0; i < tsRxIn; i++)
 332   5                          {
 333   6                              userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluatio
             -n
 334   6                          }
 335   5                          
 336   5                          ackFromScreen = 0;                      // This is a command, NOT an ACK
 337   5                          tsCommandReceived = 1;                    // Set flag when a complete command is received
 338   5                      }
 339   4                      else                              // Not a command from touch screen controller
 340   4                      {
 341   5                          ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 342   5                          tsCommandReceived = 0;                    // No need to set flag because it is not a command
 343   5                      }
 344   4                      
 345   4                      for(i = 0; i < tsRxIn; i++)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 7   

 346   4                      {
 347   5                          tsRxBuffer[i] = '\0';                   // Delete all contents
 348   5                      }
 349   4                      
 350   4                      tsRxOut = 0;                          // Reset index Out
 351   4                      tsRxIn = 0;                           // Reset index In
 352   4                  }
 353   3              }
 354   2              else                                  // Reset all indexes
 355   2              {
 356   3                  while(tsRxOut < tsRxIn)
 357   3                  {
 358   4                      tsRxBuffer[tsRxOut] = '\0';
 359   4                      tsRxOut++;
 360   4                  }
 361   3                  tsRxOut = 0;
 362   3                  tsRxIn = 0;
 363   3                  tsCommandReceived = 0;
 364   3              }
 365   2          }
 366   1          
 367   1          if(TI0 == 1)                                                // Check if one character is successfully sent out
 368   1          {
 369   2              TI0 = 0;                                                    // Clear interrupt flag
 370   2              
 371   2              if(tsTxEmpty == 0)                            // TX buffer has something to send
 372   2              {
 373   3                  SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 374   3                  tsTxOut++;                              // Move to next character
 375   3                  
 376   3                  while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmissi
             -on TI0 = 1
 377   3                  if(txWaitCounter >= TX_WAIT_LIMIT)
 378   3                  {
 379   4                      TI0 = 1;                            // TI0 is not set by hardware, set it by software
 380   4                  }                                 // When TI0 is set to 1, this ISR is executed again
 381   3                  
 382   3                  txWaitCounter = 0;                          // Reset counter for next execution
 383   3                  
 384   3                  if(tsTxOut >= TX_BUFFER_SIZE)
 385   3                  {
 386   4                      tsTxOut = 0;                          // Reset index to 0
 387   4                  }
 388   3                  
 389   3                  if(tsTxOut == tsTxIn)                       // If two indexes are equal
 390   3                  {
 391   4                      tsTxEmpty = 1;                          // No more character in buffer. Empty
 392   4                  }
 393   3              }
 394   2              else
 395   2              {
 396   3                  tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 397   3              }
 398   2          }
 399   1          
 400   1          SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 401   1      }
 402          
 403          //-------------------------------------------------------------------------------------------------------
 404          // Function Name: sendCommand
 405          // Return Value: None 
 406          // Parmeters: s (a string to send)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 8   

 407          // Function Description: This function sends a command from the touch screen
 408          //-------------------------------------------------------------------------------------------------------
 409          void sendCommand(const char * s)
 410          { 
 411   1          char SFRPAGE_SAVE = SFRPAGE;
 412   1          
 413   1          while(*s != '\0')                             // Search for end of touch screen command in buffer
 414   1          {
 415   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 416   2              {
 417   3                  tsTxBuffer[tsTxIn++] = *s;
 418   3                  if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
 419   3                  {
 420   4                      tsTxIn = 0;                           // Reset if limit reached
 421   4                  }
 422   3                  
 423   3                  if(tsTxEmpty == 1)                          // If buffer is empty
 424   3                  {
 425   4                      tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 426   4                  }
 427   3              }
 428   2              
 429   2              s++;                                  // Point to next char to send out
 430   2          }
 431   1          
 432   1          if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 433   1          {
 434   2              tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 435   2              SFRPAGE = UART0_PAGE;
 436   2              TI0 = 1;                                                            // Set this flage to call ISR to
             - send out one character
 437   2          }
 438   1          
 439   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 440   1      }
 441          
 442          //-------------------------------------------------------------------------------------------------------
 443          // Function Name: 
 444          // Return Value: None 
 445          // Parmeters: fg, bg, size, message, x, y
 446          // Function Description: This function displays a text on the touch screen
 447          //-------------------------------------------------------------------------------------------------------
 448          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 449          {
 450   1          char str[TS_BUFFER_SIZE] = { 0 };                         // String
 451   1          
 452   1          sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 453   1          sendCommand(str);
 454   1          sprintf(str, "f %s\r", Font[size]);                     // Set text font
 455   1          sendCommand(str);
 456   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
 457   1          sendCommand(str);
 458   1      }
 459          
 460          //-------------------------------------------------------------------------------------------------------
 461          // Function Name: showBitmap
 462          // Return Value: None 
 463          // Parmeters: index, x, y (bitmap index and coordinates)
 464          // Function Description: This function displays a bitmap image
 465          //-------------------------------------------------------------------------------------------------------
 466          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 9   

 467          {
 468   1          char str[TS_BUFFER_SIZE];
 469   1          
 470   1          sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 471   1          sendCommand(str);
 472   1      }
 473          
 474          //-------------------------------------------------------------------------------------------------------
 475          // Function Name: changeScreen
 476          // Return Value: None 
 477          // Parmeters: screenIndex (macro number)
 478          // Function Description: This function switches to the new screen
 479          //-------------------------------------------------------------------------------------------------------
 480          void changeScreen(const unsigned char screenIndex)
 481          {
 482   1          callMacro(screenIndex);                           // Change screen
 483   1      }
 484          
 485          //-------------------------------------------------------------------------------------------------------
 486          // Function Name: callMacro
 487          // Return Value: None 
 488          // Parmeters: macroNumber (macro number in the macro file)
 489          // Function Description: This function calls a macro
 490          //-------------------------------------------------------------------------------------------------------
 491          void callMacro(const unsigned int macroNumber)
 492          {
 493   1          char str[TS_BUFFER_SIZE];
 494   1          
 495   1          sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 496   1          sendCommand(str);
 497   1      }
 498          
 499          //-------------------------------------------------------------------------------------------------------
 500          // Function Name: scanUserInput
 501          // Return Value: None 
 502          // Parmeters: None
 503          // Function Description: This function processes commands from the touch screen
 504          //-------------------------------------------------------------------------------------------------------
 505          void scanUserInput(void)
 506          { 
 507   1          int i = 0;
 508   1          
 509   1          if(screen == MAIN_PAGE)                           // Main screen
 510   1          {
 511   2              if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 512   2              {
 513   3                  switch (userCommand[1])                         // Scan a command type
 514   3                  {
 515   4                      case '1':                           // Main page
 516   4                          changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 517   4                          break;
 518   4                      case '2':                           // Settings page
 519   4                          changeScreen(SETTINGS_PAGE);
 520   4                          break;
 521   4                      case '3':                             // Service page
 522   4                          changeScreen(SERVICE_PAGE);
 523   4                          break;
 524   4                      case 'A':
 525   4                          // Call a function here or do something here
 526   4                          break;
 527   4                      case 'B':
 528   4                          // Call a function here or do something here
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 10  

 529   4                          break;
 530   4                      case 'C':
 531   4                          // Call a function here or do something here
 532   4                          break;
 533   4                      default:                            // Other options
 534   4                          break;
 535   4                  }
 536   3              }
 537   2              else                                  // Not a command, empty buffer with null char
 538   2              {
 539   3                  i = 0;
 540   3                  while(userCommand[i] != '\0')
 541   3                  {
 542   4                      userCommand[i] = '\0';
 543   4                      i++;
 544   4                  }
 545   3              }
 546   2          }
 547   1          else if(screen == SETTINGS_PAGE)                      // Settings page
 548   1          {
 549   2              if(userCommand[0] == '(')
 550   2              {
 551   3                  switch (userCommand[1])
 552   3                  {
 553   4                      case '1':
 554   4                          changeScreen(MAIN_PAGE);
 555   4                          break;
 556   4                      case '2':
 557   4                          changeScreen(SETTINGS_PAGE);
 558   4                          break;
 559   4                      case '3':
 560   4                          changeScreen(SERVICE_PAGE);
 561   4                          break;
 562   4                      case 'A':
 563   4                          // Call a function here or do something here
 564   4                          break;
 565   4                      case 'B':
 566   4                          // Call a function here or do something here
 567   4                          break;
 568   4                      case 'C':
 569   4                          // Call a function here or do something here
 570   4                          break;
 571   4                      default:
 572   4                          break;
 573   4                  }
 574   3              }
 575   2              else                                  // Not a command, empty buffer with null
 576   2              {
 577   3                  i = 0;
 578   3                  while(userCommand[i] != '\0')
 579   3                  {
 580   4                      userCommand[i] = '\0';
 581   4                      i++;
 582   4                  }
 583   3              }
 584   2          }
 585   1          else if(screen == SERVICE_PAGE)
 586   1          {
 587   2              if(userCommand[0] == '(')
 588   2              {
 589   3                  switch (userCommand[1])
 590   3                  {
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 11  

 591   4                      case '1':
 592   4                          changeScreen(MAIN_PAGE);
 593   4                          break;
 594   4                      case '2':
 595   4                          changeScreen(SETTINGS_PAGE);
 596   4                          break;
 597   4                      case '3':
 598   4                          changeScreen(SERVICE_PAGE);
 599   4                          break;
 600   4                      case 'A':
 601   4                          // Call a function here or do something here
 602   4                      case 'B':
 603   4                          // Call a function here or do something here
 604   4                      case 'C':
 605   4                          // Call a function here or do something here
 606   4                      default:
 607   4                          break;
 608   4                  }
 609   3              }
 610   2              else                                  // Not a command, empty buffer with null
 611   2              {
 612   3                  i = 0;
 613   3                  while(userCommand[i] != '\0')
 614   3                  {
 615   4                      userCommand[i] = '\0';
 616   4                      i++;
 617   4                  }
 618   3              }
 619   2          }
 620   1          else
 621   1          {
 622   2              
 623   2          }
 624   1          
 625   1          i = 0;
 626   1          while(userCommand[i] != '\0')
 627   1          {
 628   2              userCommand[i] = '\0';                          // Delete all contents in array
 629   2              i++;
 630   2          }
 631   1      }
 632          
 633          //-------------------------------------------------------------------------------------------------------
 634          // Function Name: smbInit
 635          // Return Value: None 
 636          // Parmeters: None
 637          // Function Description: This function initializes the SMB bus 
 638          //-------------------------------------------------------------------------------------------------------
 639          void smbInit(void)
 640          {
 641   1          int i;
 642   1          unsigned long pollingCounter = 0;
 643   1          char SFRPAGE_SAVE = SFRPAGE;
 644   1          
 645   1          SFRPAGE = SMB0_PAGE;
 646   1          while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because o
             -f error or reset
 647   1          {
 648   2              SCL = 0;                                                          // Drive the clock low
 649   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 650   2              SCL = 1;                                                          // Release the clock
 651   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 12  

 652   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
 653   2          }
 654   1          
 655   1          SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 656   1          // Enable SMBus Free timeout detect;
 657   1          SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and 
             -Thigh equations
 658   1          
 659   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 660   1          
 661   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 662   1          
 663   1          SMB_BUSY = 0;
 664   1          // Release SMB
 665   1          slaveWriteDone = FALSE;
 666   1          slaveReadDone = FALSE;
 667   1          eepromWriteDone = FALSE;
 668   1          eepromReadDone = FALSE;
 669   1          rtcWriteDone = FALSE;
 670   1          rtcReadDone = FALSE;
 671   1      }
 672          
 673          //-------------------------------------------------------------------------------------------------------
 674          // Function Name: timer3Init
 675          // Return Value: None 
 676          // Parmeters: None
 677          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 678          //-------------------------------------------------------------------------------------------------------
 679          void timer3Init (void)
 680          {
 681   1          char SFRPAGE_SAVE = SFRPAGE;
 682   1          
 683   1          SFRPAGE = TMR3_PAGE;
 684   1          
 685   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 686   1          // Timer 3 auto reload
 687   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 688   1          
 689   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 690   1          TMR3 = RCAP3;
 691   1          
 692   1          TR3 = 1;                                                            // Start Timer 3
 693   1          
 694   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 695   1      }
 696          
 697          //-------------------------------------------------------------------------------------------------------
 698          // Function Name: timer3ISR
 699          // Return Value: None 
 700          // Parmeters: None
 701          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 702          //-------------------------------------------------------------------------------------------------------
 703          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 704          {
 705   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 706   1          
 707   1          SFRPAGE = SMB0_PAGE;
 708   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 709   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 710   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 13  

 711   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
 712   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 713   1          SMB_BUSY = 0;                                                       // Free bus
 714   1          
 715   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 716   1      }
 717          
 718          //-------------------------------------------------------------------------------------------------------
 719          // Function Name: writeOneByteToSlave
 720          // Return Value: None 
 721          // Parmeters: target, startAddr, content
 722          // Function Description: This function writes one to the slave microprocessor
 723          //-------------------------------------------------------------------------------------------------------
 724          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 725          {       
 726   1          sharedDataTx[startAddr] = content;
 727   1          smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 728   1      }
 729          
 730          //-------------------------------------------------------------------------------------------------------
 731          // Function Name: readOneByteFromSlave
 732          // Return Value: long 
 733          // Parmeters: startAddr, bytes
 734          // Function Description: This function reads one from the slave microprocessor
 735          //-------------------------------------------------------------------------------------------------------
 736          unsigned char readOneByteFromSlave(unsigned char startAddr)
 737          {
 738   1          smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 739   1          return sharedDataRx[startAddr];
 740   1      }
 741          
 742          //-------------------------------------------------------------------------------------------------------
 743          // Function Name: writeBytesToRealTimeClock
 744          // Return Value: None 
 745          // Parmeters: target, startAddr, bytes
 746          // Function Description: This function writes data byte to the real time clock DS3232
 747          //-------------------------------------------------------------------------------------------------------
 748          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 749          {
 750   1          smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 751   1      }
 752          
 753          //-------------------------------------------------------------------------------------------------------
 754          // Function Name: readBytesFromRealTimeClock
 755          // Return Value: None 
 756          // Parmeters: target, startAddr, bytes
 757          // Function Description: This function reads data byte from the real time clock DS3232
 758          //-------------------------------------------------------------------------------------------------------
 759          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 760          {
 761   1          smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 762   1      }
 763          
 764          //-------------------------------------------------------------------------------------------------------
 765          // Function Name: smbRead
 766          // Return Value: unsigned char * 
 767          // Parmeters: target, startAddr, bytes
 768          // Function Description: This function reads from SM bus
 769          //-------------------------------------------------------------------------------------------------------
 770          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 771          {
 772   1          char SFRPAGE_SAVE = SFRPAGE;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 14  

 773   1          
 774   1          SFRPAGE = SMB0_PAGE;
 775   1          
 776   1          while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 777   1          
 778   1          SFRPAGE = SFRPAGE_SAVE;
 779   1          
 780   1          switch(deviceId)
 781   1          {
 782   2              case MCU_SLAVE_ADDR:
 783   2              case REAL_TIME_CLOCK_ADDR:
 784   2              case EEPROM_ADDR:
 785   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 786   2                  break;
 787   2              default:
 788   2                  break;
 789   2          }
 790   1          
 791   1          SFRPAGE = SMB0_PAGE;
 792   1          
 793   1          while(BUSY || SMB_BUSY);
 794   1          slaveAddr = deviceId;                                                     // Address of MCU slave
 795   1          startAddr = location;                                 // Starting address to read from slave
 796   1          numBytesRD = bytes;                                   // Number of bytes to read
 797   1          
 798   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
 799   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
 800   1          STA = 1;
 801   1          
 802   1          while(BUSY || SMB_BUSY);                                                    // Wait for SMB
 803   1          
 804   1          SFRPAGE = SFRPAGE_SAVE;
 805   1          
 806   1          switch(deviceId)
 807   1          {
 808   2              case MCU_SLAVE_ADDR:
 809   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
 810   2                  break;
 811   2              case REAL_TIME_CLOCK_ADDR:
 812   2                  while(rtcReadDone == 0);                                            // Wait until real time cloc
             -k write completed or timeout occurs
 813   2                  break;
 814   2              case EEPROM_ADDR:
 815   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
 816   2                  break;
 817   2              default:
 818   2                  break;
 819   2          }
 820   1      }
 821          
 822          //-------------------------------------------------------------------------------------------------------
 823          // Function Name: smbWrite
 824          // Return Value: unsigned char * 
 825          // Parmeters: target, startAddr, bytes
 826          // Function Description: This function reads to SM bus
 827          //-------------------------------------------------------------------------------------------------------
 828          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 829          {
 830   1          unsigned char i = 0;
 831   1          unsigned int pageWrittenDelay = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 15  

 832   1          char SFRPAGE_SAVE = SFRPAGE;
 833   1          
 834   1          SFRPAGE = SMB0_PAGE;
 835   1          
 836   1          while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
 837   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
 838   1          startAddr = location;                               // Starting address to write to slave
 839   1          
 840   1          switch(deviceId)
 841   1          {
 842   2              case MCU_SLAVE_ADDR:                              // Pass through
 843   2              case DEVICE_DUMP_ADDR:                              // Pass through
 844   2                  numBytesWR = bytes;                             // Number of bytes to read
 845   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 846   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 847   2                  STA = 1;                                                          // Start transfer
 848   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 849   2                  break;
 850   2              case REAL_TIME_CLOCK_ADDR:
 851   2                  numBytesWR = bytes;                             // Number of bytes to read
 852   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 853   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 854   2                  STA = 1;                                                          // Start transfer
 855   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
 856   2                  break;
 857   2              default:
 858   2                  break;
 859   2          }
 860   1          
 861   1          SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
 862   1      }
 863          
 864          //-------------------------------------------------------------------------------------------------------
 865          // Function Name: smbISR
 866          // Return Value: None 
 867          // Parmeters: None
 868          // Function Description: 
 869          // SMBus Interrupt Service Routine (ISR)
 870          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 871          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 872          //-------------------------------------------------------------------------------------------------------
 873          void smbISR (void) interrupt INTERRUPT_SMB using 2
 874          {
 875   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
 876   1          static unsigned int TxCounter;                          // Initialize counter
 877   1          static unsigned int RxCounter;                          // Initialize counter
 878   1          static unsigned int slaveCount = 0;
 879   1          static unsigned int realTimeClockCount = 0;
 880   1          static unsigned int eepromCount = 0;
 881   1          static unsigned char eepromAddrDone;
 882   1          
 883   1          switch (SMB0STA >> 3)                             // Check SMB bus status
 884   1          {
 885   2                  //--------------------------------------------------------------------------------------------
             ------------
 886   2                  // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device ad
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 16  

             -dress
 887   2                  //--------------------------------------------------------------------------------------------
             ------------
 888   2              case SMB_START:                               // Master initiates a transfer
 889   2                  
 890   2                  //--------------------------------------------------------------------------------------------
             ------------
 891   2                  // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave 
             -device address
 892   2                  //--------------------------------------------------------------------------------------------
             ------------
 893   2              case SMB_REPEAT_START:
 894   2                  SMB0DAT = slaveAddr;                                            // Load address of the slave.
 895   2                  SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for t
             -he R/W bit
 896   2                  SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
 897   2                  STA = 0;                                                      // Manually clear STA bit
 898   2                  
 899   2                  RxCounter = 0;                                                // Reset the counter
 900   2                  TxCounter = 0;                                                // Reset the counter
 901   2                  eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address
 902   2                  
 903   2                  break;
 904   2                  
 905   2                  //--------------------------------------------------------------------------------------------
             ------------
 906   2                  // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 907   2                  // For a WRITE: Send the first data byte to the slave
 908   2                  //--------------------------------------------------------------------------------------------
             ------------
 909   2              case SMB_ADDR_W_TX_ACK_RX:
 910   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 911   2                  {
 912   3                      if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence o
             -nly
 913   3                      {
 914   4                          STO = 1;                            // Stop this transfer
 915   4                          SMB_BUSY = 0;                         // Releas SMB
 916   4                      }
 917   3                      else
 918   3                      {
 919   4                          SMB0DAT = startAddr;                      // Send 1 byte address to slave
 920   4                          slaveWriteDone = 0;                       // Mark start of slave write
 921   4                      }
 922   3                  }
 923   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 924   2                  {
 925   3                      SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
 926   3                      rtcWriteDone = 0;                         // Mark start of rtc write
 927   3                  }
 928   2                  else{}
 929   2                  break;
 930   2                  
 931   2                  //--------------------------------------------------------------------------------------------
             ------------
 932   2                  // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 933   2                  //--------------------------------------------------------------------------------------------
             ------------
 934   2              case SMB_ADDR_W_TX_NACK_RX:
 935   2                  if(slaveAddr == MCU_SLAVE_ADDR || slaveAddr == WAVEFORM_GEN_ADDR )
 936   2                  {
 937   3                      if(slaveCount < MAX_NACK_RETRY)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 17  

 938   3                      {
 939   4                          slaveCount++;                         // Increment number of attempts when NACK is received
 940   4                          STA = 1;                            // Restart a new transfer
 941   4                      }
 942   3                      else
 943   3                      {
 944   4                          slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
 945   4                          slaveWriteDone = 1;
 946   4                          STO = 1;
 947   4                          SMB_BUSY = 0;
 948   4                          FAIL = 1;
 949   4                      }
 950   3                  }
 951   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 952   2                  {
 953   3                      if(realTimeClockCount < MAX_NACK_RETRY)
 954   3                      {
 955   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
 956   4                          STA = 1;                            // Restart a new transfer
 957   4                      }
 958   3                      else
 959   3                      {
 960   4                          realTimeClockCount = 0;
 961   4                          rtcWriteDone = 1;
 962   4                          STO = 1;
 963   4                          SMB_BUSY = 0;
 964   4                          FAIL = 1;
 965   4                      }
 966   3                  }
 967   2                  else if(slaveAddr == EEPROM_ADDR)
 968   2                  {
 969   3                      if(eepromCount < MAX_NACK_RETRY)
 970   3                      {
 971   4                          eepromCount++;                          // Increment number of attempts when NACK is received
 972   4                          STA = 1;                            // Restart a new transfer
 973   4                      }
 974   3                      else
 975   3                      {
 976   4                          eepromCount = 0;
 977   4                          eepromWriteDone = 1;
 978   4                          STO = 1;
 979   4                          SMB_BUSY = 0;
 980   4                          FAIL = 1;
 981   4                      }
 982   3                  }
 983   2                  else
 984   2                  {}
 985   2                  
 986   2                  break;
 987   2                  
 988   2                  //--------------------------------------------------------------------------------------------
             ------------
 989   2                  //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 990   2                  //For a WRITE: Send all data.  After the last data byte, send the stop bit
 991   2                  //--------------------------------------------------------------------------------------------
             ------------
 992   2              case SMB_DATA_TX_ACK_RX:
 993   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 994   2                  {
 995   3                      if(TxCounter < numBytesWR)
 996   3                      {
 997   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 18  

 998   4                          TxCounter++;
 999   4                      }
1000   3                      else
1001   3                      {
1002   4                          STO = 1;                                                // Set STO to terminate transfer
1003   4                          SMB_BUSY = 0;                                           // And free SMBus interface
1004   4                          slaveWriteDone = 1;                       // Mark end of slave write
1005   4                      }
1006   3                  }
1007   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1008   2                  {
1009   3                      if(TxCounter < numBytesWR)
1010   3                      {
1011   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1012   4                          TxCounter++;
1013   4                      }
1014   3                      else
1015   3                      {
1016   4                          STO = 1;                                                // Set STO to terminate transfer
1017   4                          SMB_BUSY = 0;                                           // And free SMBus interface
1018   4                          rtcWriteDone = 1;                       // Mark end of slave write
1019   4                      }
1020   3                  }
1021   2                  break;
1022   2                  
1023   2                  //--------------------------------------------------------------------------------------------
             ------------
1024   2                  // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1025   2                  //--------------------------------------------------------------------------------------------
             ------------
1026   2              case SMB_DATA_TX_NACK_RX:
1027   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1028   2                  {
1029   3                      if(slaveCount < MAX_NACK_RETRY)
1030   3                      {
1031   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1032   4                          STA = 1;                            // Restart a new transfer
1033   4                      }
1034   3                      else
1035   3                      {
1036   4                          slaveCount = 0;
1037   4                          STO = 1;
1038   4                          SMB_BUSY = 0;
1039   4                          FAIL = 1;
1040   4                      }
1041   3                  }
1042   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1043   2                  {
1044   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1045   3                      {
1046   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1047   4                          STA = 1;                            // Restart a new transfer
1048   4                      }
1049   3                      else
1050   3                      {
1051   4                          realTimeClockCount = 0;
1052   4                          STO = 1;
1053   4                          SMB_BUSY = 0;
1054   4                          FAIL = 1;
1055   4                      }
1056   3                  }
1057   2                  else if(slaveAddr == EEPROM_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 19  

1058   2                  {
1059   3                      if(eepromCount < MAX_NACK_RETRY)
1060   3                      {
1061   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1062   4                          STA = 1;                            // Restart a new transfer
1063   4                      }
1064   3                      else
1065   3                      {
1066   4                          eepromCount = 0;
1067   4                          STO = 1;
1068   4                          SMB_BUSY = 0;
1069   4                          FAIL = 1;
1070   4                      }
1071   3                  }
1072   2                  else
1073   2                  {}
1074   2                  break;
1075   2                  
1076   2                  //--------------------------------------------------------------------------------------------
             ------------
1077   2                  // Master Receiver: Slave address + READ transmitted.  ACK received.
1078   2                  // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1079   2                  // is received to end the transfer. if not, set the ACK and receive the other data bytes
1080   2                  //--------------------------------------------------------------------------------------------
             ------------
1081   2              case SMB_ADDR_R_TX_ACK_RX:
1082   2                  if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1083   2                  {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1084   3                      AA = 0;                                                   // Clear AA flag before data byte is 
             -received
1085   3                      // send NACK signal to slave after byte is received
1086   3                  }
1087   2                  else
1088   2                  {
1089   3                      AA = 1;                                                   // More than one byte in this transfe
             -r,
1090   3                      // send ACK after byte is received
1091   3                  }
1092   2                  break;
1093   2                  
1094   2                  //--------------------------------------------------------------------------------------------
             ------------
1095   2                  // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1096   2                  //--------------------------------------------------------------------------------------------
             ------------
1097   2              case SMB_ADDR_R_TX_NACK_RX:
1098   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1099   2                  {
1100   3                      if(slaveCount < MAX_NACK_RETRY)
1101   3                      {
1102   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1103   4                          STA = 1;                            // Restart transfer after receiving a NACK
1104   4                      }
1105   3                      else
1106   3                      {
1107   4                          slaveCount = 0;                         // Reset counter
1108   4                          STO = 1;
1109   4                          SMB_BUSY = 0;
1110   4                          FAIL = 1;
1111   4                      }
1112   3                  }
1113   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 20  

1114   2                  {
1115   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1116   3                      {
1117   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1118   4                          STA = 1;                            // Restart a new transfer
1119   4                      }
1120   3                      else
1121   3                      {
1122   4                          realTimeClockCount = 0;
1123   4                          STO = 1;
1124   4                          SMB_BUSY = 0;
1125   4                          FAIL = 1;
1126   4                      }
1127   3                  }
1128   2                  else if(slaveAddr == EEPROM_ADDR)
1129   2                  {
1130   3                      if(eepromCount < MAX_NACK_RETRY)
1131   3                      {
1132   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1133   4                          STA = 1;                            // Restart a new transfer
1134   4                      }
1135   3                      else
1136   3                      {
1137   4                          eepromCount = 0;
1138   4                          STO = 1;
1139   4                          SMB_BUSY = 0;
1140   4                          FAIL = 1;
1141   4                      }
1142   3                  }
1143   2                  else
1144   2                  {}
1145   2                  break;
1146   2                  
1147   2                  //--------------------------------------------------------------------------------------------
             ------------
1148   2                  // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1149   2                  // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and se
             -t the STOP bit
1150   2                  //--------------------------------------------------------------------------------------------
             ------------
1151   2              case SMB_DATA_RX_ACK_TX:
1152   2                  
1153   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1154   2                  {
1155   3                      if (RxCounter < numBytesRD)
1156   3                      {
1157   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1158   4                          AA = 1;                                                 // Send ACK to indicate byte recei
             -ved
1159   4                          RxCounter++;                                            // Increment the byte counter
1160   4                          slaveReadDone = 0;                        // Mark start of slave read
1161   4                      }
1162   3                      else
1163   3                      {
1164   4                          AA = 0;                                                 // Send NACK to indicate last byte
             - is received
1165   4                          slaveReadDone = 1;                        // Mark end of slave read
1166   4                      }
1167   3                  }
1168   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1169   2                  {
1170   3                      if(RxCounter < numBytesRD)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 21  

1171   3                      {
1172   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1173   4                          rtcReadDone = 0;
1174   4                          
1175   4                          AA = 1;                             // Send ACK to indicate byte received
1176   4                          RxCounter++;                          // Increment the byte counter
1177   4                      }
1178   3                      else
1179   3                      {
1180   4                          rtcReadDone = 1;
1181   4                          AA = 0;                             // Send NACK to indicate last byte is received
1182   4                      }
1183   3                  }
1184   2                  else if(slaveAddr == EEPROM_ADDR)
1185   2                  {
1186   3                      if(RxCounter < numBytesRD)
1187   3                      {
1188   4                          eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1189   4                          AA = 1;                             // Send ACK to indicate byte received
1190   4                          RxCounter++;                          // Increment the byte counter
1191   4                          eepromReadDone = 0;                       // Mark start of fram read
1192   4                      }
1193   3                      else
1194   3                      {
1195   4                          AA = 0;                             // Send NACK to indicate last byte is received
1196   4                          eepromReadDone = 1;                       // Mark end of fram read
1197   4                      }
1198   3                  }
1199   2                  break;
1200   2                  
1201   2                  //--------------------------------------------------------------------------------------------
             ------------
1202   2                  // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1203   2                  // For a READ: Read operation has completed.  Read data register and send STOP
1204   2                  //--------------------------------------------------------------------------------------------
             ------------
1205   2              case SMB_DATA_RX_NACK_TX:
1206   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1207   2                  {
1208   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1209   3                      STO = 1;                              // Stop transfer
1210   3                      SMB_BUSY = 0;                           // Release SMB
1211   3                      AA = 1;
1212   3                      slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next
             - transfer
1213   3                  }
1214   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1215   2                  {
1216   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1217   3                      rtcReadDone = 1;
1218   3                      
1219   3                      STO = 1;                              // Stop transfer
1220   3                      SMB_BUSY = 0;                           // Release SMB
1221   3                      AA = 1;                               // Send ACK to indicate byte received
1222   3                  }
1223   2                  else if(slaveAddr == EEPROM_ADDR)
1224   2                  {
1225   3                      eepromRx[RxCounter] = SMB0DAT;
1226   3                      STO = 1;                              // Stop transfer
1227   3                      SMB_BUSY = 0;                           // Release SMB
1228   3                      AA = 1;
1229   3                      eepromReadDone = 1;                         // Mark end of eeprom read
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 22  

1230   3                  }
1231   2                  break;
1232   2                  
1233   2                  //--------------------------------------------------------------------------------------------
             ------------
1234   2                  // Master Transmitter: Arbitration lost
1235   2                  //--------------------------------------------------------------------------------------------
             ------------
1236   2              case SMB_ARBITRATION_LOST:
1237   2                  FAIL = 1;                                                     // Indicate failed transfer
1238   2                  // and handle at end of ISR
1239   2                  break;
1240   2                  
1241   2                  //--------------------------------------------------------------------------------------------
             ------------
1242   2                  // All other status codes invalid.  Reset communication
1243   2                  //--------------------------------------------------------------------------------------------
             ------------
1244   2              default:
1245   2                  FAIL = 1;
1246   2                  break;
1247   2          }
1248   1          //----------------------------------------------------------------------------------------------------
             ----
1249   1          // If all failed, reset everything
1250   1          //----------------------------------------------------------------------------------------------------
             ----
1251   1          if(FAIL)                                                            // If the transfer failed,
1252   1          {
1253   2              SMB0CN &= ~0x40;                                                  // Reset communication
1254   2              SMB0CN |= 0x40;
1255   2              STA = 0;
1256   2              STO = 0;
1257   2              AA = 0;
1258   2              
1259   2              SMB_BUSY = 0;                                                     // Free SMBus
1260   2              
1261   2              FAIL = 0;
1262   2              // Set to finish all pending processes
1263   2              slaveWriteDone = 1;                             // Mark end of slave write
1264   2              slaveReadDone = 1;                              // Mark end of slave read
1265   2              rtcWriteDone = 1;
1266   2              rtcReadDone = 1;
1267   2              eepromWriteDone = 1;                            // Mark end of eeprom write
1268   2              eepromReadDone = 1;                             // Mark end of eeprom read
1269   2          }
1270   1          
1271   1          SI = 0;                                                             // Clear interrupt flag
1272   1      }
1273          
1274          //-------------------------------------------------------------------------------------------------------
1275          // Function Name: setClockControl
1276          // Return Value: None 
1277          // Parmeters: None
1278          // Function Description: This function sets values to the real time clock control register
1279          // Check DS3232 documentation for more details of this this control register
1280          //-------------------------------------------------------------------------------------------------------
1281          void setClockControl(void)
1282          {
1283   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1284   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30;
1285   1          writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 23  

1286   1      }
1287          
1288          //-------------------------------------------------------------------------------------------------------
1289          // Function Name: setClock
1290          // Return Value: None 
1291          // Parmeters: None
1292          // Function Description: This function sets the new values to the real time clock
1293          //-------------------------------------------------------------------------------------------------------
1294          void setClock(void)
1295          { 
1296   1          unsigned char hoursAux;
1297   1          
1298   1          sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to 
             -array before writing
1299   1          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... ar
             -e already converted to BCD
1300   1          sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1301   1          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1302   1          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1303   1          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1304   1          
1305   1          hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1306   1          
1307   1          hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1308   1          
1309   1          if(amPm == 'P')
1310   1          {
1311   2              hoursAux = hoursAux | 0x60;                         // Set AM/PM bit --> PM mode
1312   2          }
1313   1          else if(amPm == 'A')
1314   1          {
1315   2              hoursAux = hoursAux & 0x5F;                         // Clear AM/PM bit --> AM mode
1316   2          }
1317   1          
1318   1          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1319   1          
1320   1          writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes t
             -o RTC
1321   1          
1322   1          //resetAllDisplayCounters();                              // Update new values on screen
1323   1      }     
1324          
1325          //-------------------------------------------------------------------------------------------------------
1326          // Function Name: getClockData()
1327          // Return Value: None 
1328          // Parmeters: None
1329          // Function Description: This function gets the new values from the real time clock
1330          //-------------------------------------------------------------------------------------------------------
1331          void getClockData()
1332          {
1333   1          static unsigned char previousMonth = 0;
1334   1          static unsigned char previousDate = 0;
1335   1          static unsigned char previousYear = 0;
1336   1          static unsigned char previousHours = 0;
1337   1          static unsigned char previousMinutes = 0;
1338   1          static unsigned char previousSeconds = 0;
1339   1          
1340   1          unsigned int currentIndex = 0;
1341   1          unsigned char tempHours;
1342   1          
1343   1          readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1344   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 24  

1345   1          seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal fo
             -r seconds (1 byte)
1346   1          minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal fo
             -r minutes (1 byte)
1347   1          
1348   1          tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/P
             -M
1349   1          
1350   1          if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1351   1          {
1352   2              timeMode = TWELVE_HR_MODE;
1353   2              
1354   2              if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
1355   2              {
1356   3                  amPm = 'P';
1357   3              }
1358   2              else
1359   2              {
1360   3                  amPm = 'A';
1361   3              }
1362   2          }
1363   1          else
1364   1          {
1365   2              timeMode = TWENTY_FOUR_HR_MODE;
1366   2          }
1367   1          
1368   1          hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore othe
             -rs)
1369   1          
1370   1          if(hours == 12)
1371   1          {
1372   2              if(amPm == 'A')
1373   2              {
1374   3                  hours24 = 0;
1375   3              }
1376   2              else
1377   2              {
1378   3                  hours24 = hours;
1379   3              }
1380   2          }
1381   1          else
1382   1          {
1383   2              if(amPm == 'P')
1384   2              {
1385   3                  hours24 = hours + 12;                           // Twenty four hour format if PM
1386   3              }
1387   2              else
1388   2              {
1389   3                  hours24 = hours;                              // Twenty four hour format if AM
1390   3              }
1391   2          }
1392   1          
1393   1          day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day 
             -(1 byte)
1394   1          date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for dat
             -e (1 byte)
1395   1          month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for m
             -onth (1 byte)
1396   1          year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for yea
             -r (1 byte)
1397   1          
1398   1          if(month != previousMonth || date != previousDate || year != previousYear)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 25  

1399   1          {
1400   2              monthDateYearUpdated = SET;
1401   2          }
1402   1          if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1403   1          {
1404   2              timeUpdated = SET;
1405   2          }
1406   1          
1407   1          if(amPm == 'P')
1408   1          {
1409   2              currentIndex = ((12 + hours) * 60) + minutes;
1410   2          }
1411   1          else if(amPm == 'A')
1412   1          {
1413   2              if(hours == 12)
1414   2              {
1415   3                  hours = 0;
1416   3              }
1417   2              
1418   2              currentIndex = (hours * 60) + minutes;
1419   2          }
1420   1          else
1421   1          {}
1422   1          
1423   1          minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1424   1          hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1425   1          
1426   1          previousDate = date;
1427   1          previousMonth = month;
1428   1          previousYear = year;
1429   1          previousHours = hours;
1430   1          previousMinutes = minutes;
1431   1          previousSeconds = seconds;
1432   1      }
1433          
1434          //-------------------------------------------------------------------------------------------------------
1435          // Function Name: moveDateTimeUp
1436          // Return Value: None 
1437          // Parmeters: None
1438          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1439          //-------------------------------------------------------------------------------------------------------
1440          /*
1441           void moveDateTimeUp(void)
1442           {
1443           }
1444           */
1445          
1446          //-------------------------------------------------------------------------------------------------------
1447          // Function Name: moveDateTimeDown
1448          // Return Value: None 
1449          // Parmeters: None
1450          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1451          //-------------------------------------------------------------------------------------------------------
1452          /*
1453           void moveDateTimeDown(void)
1454           {
1455           
1456           }
1457           */
1458          
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 26  

1459          //-------------------------------------------------------------------------------------------------------
1460          // Function Name: enterDateTime
1461          // Return Value: None 
1462          // Parmeters: None
1463          // Function Description: This function confirms the date or time set by the user on the touch screen
1464          //-------------------------------------------------------------------------------------------------------
1465          /*
1466           void enterDateTime(void)
1467           {
1468           char str[SPRINTF_SIZE];
1469           
1470           realTimeClockItems++;                                // Move to next item
1471           
1472           if(realTimeClockItems == MONTH_ADJUST)
1473           {
1474           monthUpdated = SET;
1475           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1476           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1477           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1478           }
1479           else if(realTimeClockItems == DATE_ADJUST)
1480           {
1481           dateUpdated = SET;
1482           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1483           sprintf(str, "%bu   ", adjustedDate);
1484           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1485           }
1486           else if(realTimeClockItems == YEAR_ADJUST)
1487           {
1488           yearUpdated = SET;
1489           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1490           sprintf(str, "20%02bu", adjustedYear);
1491           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1492           }
1493           else if(realTimeClockItems == HOUR_ADJUST)
1494           {
1495           hoursUpdated = SET;
1496           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1497           sprintf(str, "%bu   ", adjustedHours);
1498           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1499           }
1500           else if(realTimeClockItems == MINUTE_ADJUST)
1501           {
1502           minutesUpdated = SET;
1503           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
1504           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1505           sprintf(str, "%bu   ", adjustedMinutes);
1506           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1507           }
1508           else if(realTimeClockItems == AMPM_ADJUST)
1509           {
1510           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 27  

1511           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1512           sprintf(str, "%cM  ", adjustedAmPm);
1513           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1514           }
1515           else if(realTimeClockItems == DONE_ADJUST)
1516           {
1517           amPmUpdated = SET;                               // Set it if user explicitly press enter button
1518           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1519           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPLA
             -Y_Y);
1520           }
1521           else if(realTimeClockItems == ROLL_OVER_ADJUST)
1522           {
1523           realTimeClockItems = MONTH_ADJUST;                       // Set it for next round of real time clock items
1524           monthUpdated = SET;
1525           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1526           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1527           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1528           }
1529           else
1530           {}
1531           }
1532           */
1533          
1534          //-------------------------------------------------------------------------------------------------------
1535          // Function Name: setClockOnScreen
1536          // Return Value: None 
1537          // Parmeters: None
1538          // Function Description: This function sets the real time clock on the touch screen
1539          //-------------------------------------------------------------------------------------------------------
1540          /*
1541           void setClockOnScreen(void)
1542           {
1543           unsigned char hoursAux;
1544           
1545           if(monthUpdated == SET)
1546           {
1547           sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);   // Get updated month from use
             -r on screen
1548           writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);              // Set month only (1 byte)
1549           monthUpdated = CLEAR;                              //Clear flag after writing to real time clock
1550           }
1551           
1552           if(dateUpdated == SET)
1553           {
1554           sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);   // Get updated date from user o
             -n screen
1555           writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);             // Set date only (1 byte)
1556           dateUpdated = CLEAR;
1557           }
1558           
1559           if(yearUpdated == SET)
1560           {
1561           sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);   // Get updated year from user o
             -n screen
1562           writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);             // Set year only (1 byte)
1563           yearUpdated = CLEAR;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 28  

1564           }
1565           
1566           if(hoursUpdated == SET || amPmUpdated == SET)
1567           {
1568           hoursAux = convertDecimalToBCD(adjustedHours);                 // Get updated hours from user on screen
1569           
1570           if(amPmUpdated == SET)
1571           {
1572           amPm = adjustedAmPm;                           // Set updated amPm from user on screen
1573           
1574           hoursAux = hoursAux | 0x40;                          // Set 12/24 bit --> 12 hour mode
1575           
1576           if(adjustedAmPm == 'P')
1577           {
1578           hoursAux = hoursAux | 0x60;                        // Set AM/PM bit --> PM mode
1579           }
1580           else if(adjustedAmPm == 'A')
1581           {
1582           hoursAux = hoursAux & 0x5F;                        // Clear AM/PM bit --> AM mode
1583           }
1584           else
1585           {}
1586           
1587           amPmUpdated = CLEAR;
1588           }
1589           
1590           sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1591           writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);              // Set hours only (1 byte)
1592           hoursUpdated = CLEAR;
1593           }
1594           
1595           if(minutesUpdated == SET)
1596           {
1597           sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes); // Get updated minutes fro
             -m user on screen
1598           writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);              // Set minutes only (1 byte)
1599           minutesUpdated = CLEAR;
1600           }
1601           
1602           realTimeClockItems = MONTH_ADJUST;                         // Set starting item = Month for adjustment
1603           
1604           getClockData();                                      // Get current month, date, year set by user
1605           
1606           //clockSetupDisplayRepeat = 0;                           // Display clock updates on screen                                    // Syste
             -m goes back to main page
1607           }
1608           */
1609          
1610          //-------------------------------------------------------------------------------------------------------
1611          // Function Name: resetClock
1612          // Return Value: None 
1613          // Parmeters: None
1614          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1615          //-------------------------------------------------------------------------------------------------------
1616          void resetClock(void)
1617          {
1618   1          seconds = 0;
1619   1          minutes = 0;
1620   1          hours = 0;
1621   1          amPm = 'P';
1622   1          day = 1;
1623   1          date = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 29  

1624   1          month = 1;
1625   1          year = 0;
1626   1          century = 0;
1627   1          timeMode = 1;
1628   1          
1629   1          setClock();                                             // Set real time clock
1630   1      }
1631          
1632          //-------------------------------------------------------------------------------------------------------
1633          // Function Name: convertDecimalToBCD
1634          // Return Value: bcd 
1635          // Parmeters: decimal
1636          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1637          //-------------------------------------------------------------------------------------------------------
1638          unsigned char convertDecimalToBCD(unsigned char decimal)
1639          {
1640   1          unsigned char bcd;
1641   1          
1642   1          bcd = (decimal / 10) << 4;                              // Get upper 4 bits
1643   1          bcd = bcd | (decimal % 10);                             // Get a BCD
1644   1          
1645   1          return bcd;
1646   1      }
1647          
1648          //-------------------------------------------------------------------------------------------------------
1649          // Function Name: convertBCDToDecimal
1650          // Return Value: decimal value 
1651          // Parmeters: bcd
1652          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1653          //-------------------------------------------------------------------------------------------------------
1654          unsigned char convertBCDToDecimal(unsigned char bcd)
1655          {
1656   1          unsigned char decimal;
1657   1          
1658   1          decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
1659   1          // 8 bit number
1660   1          return decimal;
1661   1      }
1662          
1663          //-------------------------------------------------------------------------------------------------------
1664          // Function Name: displayClock
1665          // Return Value: None 
1666          // Parmeters: None
1667          // Function Description: This function displays clock data on the touch screen
1668          // The clock format is MM/DD/YYYY hour/minute/second
1669          //-------------------------------------------------------------------------------------------------------
1670          void displayClock(void)
1671          {
1672   1          char str[SPRINTF_SIZE];
1673   1          
1674   1          //if(screen == MAIN_PAGE)
1675   1          //{
1676   1          getClockData();
1677   1          
1678   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1679   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS_DAT
             -E_Y);
1680   1          monthDateYearUpdated = CLEAR;
1681   1          
1682   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 30  

1683   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS_TIM
             -E_Y);
1684   1          //}
1685   1          /*else if(screen == CLOCK_SETUP_PAGE)
1686   1           {
1687   1           if(buttonPressed == CLEAR)
1688   1           {
1689   1           getClockData();
1690   1           
1691   1           sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1692   1           displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y)
             -;
1693   1           monthDateYearUpdated = CLEAR;
1694   1           
1695   1           sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1696   1           displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y)
             -;
1697   1           timeUpdated = CLEAR;
1698   1           }
1699   1           }*/
1700   1      }
1701          
1702          //------------------------------------------------------------------------------------------------------
1703          // Utility functions by team 1 
1704          //------------------------------------------------------------------------------------------------------
1705          
1706          typedef enum 
1707          {
1708              SLIDER_VERTICAL = 0,
1709              SLIDER_HORIZONTAL,
1710          } SLIDER_ORIENTATION_E;
1711          
1712          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1713          {
1714   1          char str[128] = { 0 };
1715   1          
1716   1          int i = 0;
1717   1          while(i < 10000) i++;
1718   1          
1719   1          sprintf(str, "S %s %s\r", fg, bg);
1720   1          sendCommand(str);
1721   1          sprintf(str, "f %s\r", Font[size]);
1722   1          sendCommand(str);
1723   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1724   1          sendCommand(str);
1725   1      }
1726          
1727          void display_test_pad_3(const char * fg, const char * bg, const unsigned char size, const char * message, 
             -const int x, const int y)
1728          {
1729   1          char str[128] = { 0 };
1730   1          
1731   1          int i = 0;
1732   1          while(i < 10000) i++;
1733   1          
1734   1          sprintf(str, "S %s %s\r", fg, bg);
1735   1          sendCommand(str);
1736   1          sprintf(str, "f %s\r", Font[size]);
1737   1          sendCommand(str);
1738   1          sprintf(str, "t \"%3s\" %u %u\r", message, x, y);
1739   1          sendCommand(str);
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 31  

1740   1      }
1741          
1742          void display_time_settings_text(const char * fg, const char * bg, const unsigned char size, const char * m
             -essage, const int x, const int y)
1743          {
1744   1          char str[128] = { 0 };
1745   1          
1746   1          int i = 0;
1747   1          while(i < 10000) i++;
1748   1          
1749   1          sprintf(str, "S %s %s\r", fg, bg);
1750   1          sendCommand(str);
1751   1          sprintf(str, "f %s\r", Font[size]);
1752   1          sendCommand(str);
1753   1          sprintf(str, "t \"%11s\" %u %u\r", message, x, y);
1754   1          sendCommand(str);
1755   1      }
1756          
1757          static void send_macro(const unsigned int macro_index)
1758          {
1759   1          char str[8] = { 0 };
1760   1          
1761   1          int i = 0;
1762   1          while(i < 10000) i++;
1763   1          
1764   1          sprintf(str, "m %u\r", macro_index);
1765   1          sendCommand(str);
1766   1      }
1767          
1768          static void display_slider(const int idx, const int bg, const int x, const int y, const int slider, 
1769                                     const int offset, const SLIDER_ORIENTATION_E orientation, const int invert, con
             -st int high, const int low)
1770          {
1771   1          char str[50] = { 0 };
1772   1          sprintf(str, "sl %u %u %u %u %u %u %u %u 1 %u %u", idx, bg, x, y, slider, offset, orientation, invert,
             - high, low);
1773   1          sendCommand(str);
1774   1      }
1775          
1776          static void set_brightness(const char * brightness)
1777          {
1778   1          char str[10] = { 0 };
1779   1      
1780   1          sprintf(str, "xbb %s\r", brightness);
1781   1          // display_text("000000", "FFFFFF", 6, str, 0, 0);
1782   1          sendCommand(str);
1783   1      }
1784          
1785          static void set_volume(const char * volume)
1786          {
1787   1          char str[10] = { 0 };
1788   1      
1789   1          sprintf(str, "bv %s\r", volume);
1790   1          // display_text("000000", "FFFFFF", 6, str, 0, 0);
1791   1          sendCommand(str);
1792   1      }
1793          
1794          static void set_slider(const int slider, const int value)
1795          {
1796   1          char str[10] = { 0 };
1797   1      
1798   1          sprintf(str, "sv %u %u\r", slider, value);
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 32  

1799   1          sendCommand(str);
1800   1      }
1801          
1802          static void draw_rectangle(const int x0, const int y0, const int x1, const int y1, const int fill)
1803          {
1804   1          char str [50]= { 0 };
1805   1      
1806   1          sprintf(str, "r %u %u %u %u %u 000000\r", x0, y0, x1, y1, fill);
1807   1          sendCommand(str);
1808   1      }
1809          
1810          int handle_passcode(int k){
1811   1          int isValid = 0,i = 0;
1812   1          char str[SPRINTF_SIZE];
1813   1          sprintf(str, "%s", "     ");
1814   1          // displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 240, 80);
1815   1          if(k == 0){
1816   2              passcode[0]='\0';
1817   2          }
1818   1          
1819   1          if ('1' == userCommand[1] && '4' == userCommand[2] && '1' == userCommand[3]) {
1820   2              strcat(passcode,"1");
1821   2              isValid = 1;
1822   2          }
1823   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '2' == userCommand[3]) {
1824   2              strcat(passcode,"2");
1825   2              isValid = 1;
1826   2          }
1827   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '3' == userCommand[3]) {
1828   2              strcat(passcode,"3");
1829   2              isValid = 1;
1830   2          }
1831   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '4' == userCommand[3]) {
1832   2              strcat(passcode,"4");
1833   2              isValid = 1;
1834   2          }
1835   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '5' == userCommand[3]) {
1836   2              strcat(passcode,"5");
1837   2              isValid = 1;
1838   2          }
1839   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '6' == userCommand[3]) {
1840   2              strcat(passcode,"6");
1841   2              isValid = 1;
1842   2          }
1843   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '7' == userCommand[3]) {
1844   2              strcat(passcode,"7");
1845   2              isValid = 1;
1846   2          }
1847   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '8' == userCommand[3]) {
1848   2              strcat(passcode,"8");
1849   2              isValid = 1;
1850   2          }
1851   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '9' == userCommand[3]) {
1852   2              strcat(passcode,"9");
1853   2              isValid = 1;
1854   2          }
1855   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '0' == userCommand[3]) {
1856   2              strcat(passcode,"0");
1857   2              isValid = 1;
1858   2          }
1859   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '0' == userCommand[3]) {
1860   2              strcat(passcode,"*");
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 33  

1861   2              isValid = 1;
1862   2          }
1863   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '1' == userCommand[3]) {
1864   2              strcat(passcode,"#");
1865   2              isValid = 1;
1866   2          }
1867   1          if(isValid){
1868   2              str[0] = '\0';
1869   2              for(i=0;i<=k;i++){
1870   3                  strcat(str,"*");
1871   3              }
1872   2          }
1873   1          //sprintf(str, "%s", passcode);
1874   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 295, 105);
1875   1          return isValid;
1876   1      }
1877          
1878          
1879          void display_time(unsigned char Seconds_l, unsigned char Minutes_l, unsigned char Hours_l, unsigned char A
             -mPm, unsigned char Date_l, unsigned char Month_l, unsigned char Year_l) {
1880   1          char *str;
1881   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[Month_l], Date_l, Year_l);
1882   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 55, 190);
1883   1          //monthDateYearUpdated = CLEAR;
1884   1          
1885   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", Hours_l, Minutes_l, Seconds_l, AmPm);
1886   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 55, 240);
1887   1          
1888   1      }
1889          
1890          #define PAGE_MAIN            1
1891          #define PAGE_SETTINGS        2
1892          #define PAGE_SERVICE         3
1893          #define PAGE_CONFIG          4
1894          
1895          unsigned int set_Clock(void)
1896          {
1897   1          //154 - previous, 155 - next, 156 - enter, 157 -> value - 1, 158 -> value + 1;
1898   1          char *str;
1899   1          unsigned int screen_index = PAGE_CONFIG;
1900   1          getClockData();
1901   1          seconds_l = seconds;
1902   1          minutes_l = minutes;
1903   1          hours_l = hours;
1904   1          amPm_l = amPm;
1905   1          date_l = date;
1906   1          month_l = month;
1907   1          year_l = year;
1908   1          
1909   1          
1910   1          set = 0;
1911   1          selection = 1;
1912   1          //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
1913   1         
1914   1          
1915   1         while (!set)
1916   1          {   
1917   2            
1918   2              display_time_settings_text(SETTINGS_DATE_FG, SETTINGS_DATE_BG,SETTINGS_DATE_FONT,setDateTime[selec
             -tion], 370,180); //menu display to set
1919   2              if (selection < 4) {
1920   3                  sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 34  

1921   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1922   3              }
1923   2              else {
1924   3                  sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1925   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1926   3              }
1927   2              while(tsCommandReceived == 0); //wait till there is a new key pressed pressed
1928   2              /*if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3])// upper arrow - inc
             -rease value (158)
1929   2              {
1930   2                  switch(selection)
1931   2                  {
1932   2                  case 0 : {
1933   2                      //increase seconds
1934   2                      if (seconds_l == 59) {
1935   2                          seconds_l = 0;
1936   2                      }
1937   2                      else {
1938   2                          seconds_l += 1;
1939   2                      }
1940   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1941   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1942   2                      
1943   2                      break;
1944   2                  }
1945   2                  case 1 : {
1946   2                      //increase minutes
1947   2                      if (minutes_l == 59) {
1948   2                          minutes_l = 0;
1949   2                      }
1950   2                      else {
1951   2                          minutes_l += 1;
1952   2                      }
1953   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1954   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1955   2                      
1956   2                      
1957   2                      break;
1958   2                  }
1959   2                  case 2 : {
1960   2                      //increase hours
1961   2                      if (hours_l == 12) {
1962   2                          hours_l = 1;
1963   2                      }
1964   2                      else {
1965   2                          hours_l += 1;
1966   2                      }
1967   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1968   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1969   2                      
1970   2                      break;
1971   2                  }
1972   2                  case 3 : {
1973   2                      //changes AM / PM
1974   2                      if (amPm_l == 'P') {
1975   2                          amPm_l = 'A';
1976   2                      }
1977   2                      else {
1978   2                          amPm_l = 'P';
1979   2                      }
1980   2                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1981   2                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 35  

1982   2                      
1983   2                      break;
1984   2                  }
1985   2                  case 4 : {
1986   2                      //increase date
1987   2                      if (date_l == 31) {
1988   2                          date_l = 1;
1989   2                      }
1990   2                      else {
1991   2                          date_l += 1;
1992   2                      }
1993   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1994   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1995   2                      
1996   2                      break;
1997   2                  }
1998   2                  case 5 : {
1999   2                      //increase month
2000   2                      if (month_l == 12) {
2001   2                          month_l = 1;
2002   2                      }
2003   2                      else {
2004   2                          month_l += 1;
2005   2                      }
2006   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2007   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2008   2                      
2009   2                      break;
2010   2                  }
2011   2                  case 6 : {
2012   2                      //increase year
2013   2                      year_l += 1;
2014   2                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2015   2                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2016   2                      
2017   2                      break;
2018   2                  }
2019   2                  default :
2020   2                      {
2021   2                          break;
2022   2                      }
2023   2                  } //switch ends
2024   2              } //if ends
2025   2              
2026   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3])// lower arrow - decre
             -ase value (157)
2027   2              {
2028   2                  switch(selection)
2029   2                  {
2030   2                  case 0 :
2031   2                      {
2032   2                          //decrease seconds
2033   2                          if (seconds_l == 0) {
2034   2                              seconds_l = 59;
2035   2                          }
2036   2                          else {
2037   2                              seconds_l -= 1;
2038   2                          }
2039   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2040   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2041   2                          break;
2042   2                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 36  

2043   2                  case 1 :
2044   2                      {
2045   2                          //decrease minutes
2046   2                          if (minutes_l == 0) {
2047   2                              minutes_l = 59;
2048   2                          }
2049   2                          else {
2050   2                              minutes_l -= 1;
2051   2                          }
2052   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2053   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2054   2                          break;
2055   2                      }
2056   2                  case 2 :
2057   2                      {
2058   2                          //decrease hours
2059   2                          if (hours_l == 0) {
2060   2                              hours_l = 12;
2061   2                          }
2062   2                          else {
2063   2                              hours_l -= 1;
2064   2                          }
2065   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2066   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2067   2                          break;
2068   2                      }
2069   2                  case 3 :
2070   2                      {
2071   2                          //changes AM / PM
2072   2                          if (amPm_l == 'P') {
2073   2                              amPm_l = 'A';
2074   2                          }
2075   2                          else {
2076   2                              amPm_l = 'P';
2077   2                          }
2078   2                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2079   2                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2080   2                          break;
2081   2                      }
2082   2                  case 4 :
2083   2                      {
2084   2                          //decrease date
2085   2                          if (date_l == 1) {
2086   2                              date_l = 31;
2087   2                          }
2088   2                          else {
2089   2                              date_l -= 1;
2090   2                          }
2091   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2092   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2093   2                          
2094   2                          break;
2095   2                      }
2096   2                  case 5 :
2097   2                      {
2098   2                          //decrease month
2099   2                          if (month_l == 1) {
2100   2                              month_l = 12;
2101   2                          }
2102   2                          else {
2103   2                              month_l -= 1;
2104   2                          }
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 37  

2105   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2106   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2107   2                          
2108   2                          break;
2109   2                      }
2110   2                  case 6 :
2111   2                      {
2112   2                          //decrease year
2113   2                          year_l -= 1;
2114   2                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2115   2                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2116   2                          
2117   2                          break;
2118   2                      }
2119   2                  default :
2120   2                      {
2121   2                          break;
2122   2                      }
2123   2                  }
2124   2              } */
2125   2          if (selection == 0) { //to set seconds in time
2126   3                  
2127   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2128   4                      //increase seconds
2129   4                      if (seconds_l == 59) {
2130   5                          seconds_l = 0;
2131   5                      }
2132   4                      else {
2133   5                          seconds_l += 1;
2134   5                      }
2135   4                      
2136   4                  }
2137   3                  
2138   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2139   4                      //decrease seconds
2140   4                      if (seconds_l == 0) {
2141   5                          seconds_l = 59;
2142   5                      }
2143   4                      else {
2144   5                          seconds_l -= 1;
2145   5                      }
2146   4                      
2147   4                  }
2148   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2149   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2150   3                      
2151   3              }
2152   2              
2153   2              else if (selection == 1) { //to set minutes
2154   3                  
2155   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2156   4                      //increase seconds
2157   4                      if (minutes_l == 59) {
2158   5                          minutes_l = 0;
2159   5                      }
2160   4                      else {
2161   5                          minutes_l += 1;
2162   5                      }
2163   4                      
2164   4                  }
2165   3                  
2166   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 38  

2167   4                      //decrease seconds
2168   4                      if (minutes_l == 0) {
2169   5                          minutes_l = 59;
2170   5                      }
2171   4                      else {
2172   5                          minutes_l -= 1;
2173   5                      }
2174   4                      
2175   4                  }
2176   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2177   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2178   3                      
2179   3              }
2180   2              
2181   2              else if (selection == 2) { //to set hours
2182   3                  
2183   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2184   4                      //increase hours
2185   4                      if (hours_l == 12) {
2186   5                          hours_l = 1;
2187   5                      }
2188   4                      else {
2189   5                          hours_l += 1;
2190   5                      }
2191   4                  }
2192   3                  
2193   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2194   4                      //decrease hours
2195   4                      if (hours_l == 1) {
2196   5                          hours_l = 12;
2197   5                      }
2198   4                      else {
2199   5                          hours_l -= 1;
2200   5                      }
2201   4                      
2202   4                  }
2203   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2204   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2205   3                      
2206   3              }
2207   2              
2208   2              else if (selection == 3) { //to set Am/ Pm
2209   3                  
2210   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2211   4                      //changes AM / PM
2212   4                      if (amPm_l == 'P') {
2213   5                          amPm_l = 'A';
2214   5                      }
2215   4                      else {
2216   5                          amPm_l = 'P';
2217   5                      }
2218   4                     
2219   4                  }
2220   3                  
2221   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2222   4                      //changes AM / PM
2223   4                      if (amPm_l == 'P') {
2224   5                          amPm_l = 'A';
2225   5                      }
2226   4                      else {
2227   5                          amPm_l = 'P';
2228   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 39  

2229   4                      
2230   4                  }
2231   3            sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
2232   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
2233   3                      
2234   3              }
2235   2              
2236   2              else if (selection == 4) { //to set date
2237   3                  
2238   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2239   4                      //increase date
2240   4                      if (date_l == 31) {
2241   5                          date_l = 1;
2242   5                      }
2243   4                      else {
2244   5                          date_l += 1;
2245   5                      }
2246   4                      
2247   4                  }
2248   3                  
2249   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2250   4                      //decrease date
2251   4                      if (date_l == 1) {
2252   5                          date_l = 31;
2253   5                      }
2254   4                      else {
2255   5                          date_l -= 1;
2256   5                      }
2257   4                    sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2258   4                    displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2259   4                            
2260   4                      
2261   4                  }
2262   3              }
2263   2              
2264   2              else if (selection == 5) { //to set month
2265   3                  
2266   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2267   4                      //increase month
2268   4                      if (month_l == 12) {
2269   5                          month_l = 1;
2270   5                      }
2271   4                      else {
2272   5                          month_l += 1;
2273   5                      }
2274   4                      
2275   4                  }
2276   3                  
2277   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2278   4                      //decrease month
2279   4                      if (month_l == 1) {
2280   5                          month_l = 12;
2281   5                      }
2282   4                      else {
2283   5                          month_l -= 1;
2284   5                      }
2285   4                      
2286   4                      
2287   4                  }
2288   3            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2289   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2290   3                          
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 40  

2291   3              }
2292   2              
2293   2              else if (selection == 6) { //to set year
2294   3                  
2295   3                  if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3]) {
2296   4                      //increase year
2297   4                      year_l += 1;
2298   4                      
2299   4                    
2300   4                  }
2301   3                  
2302   3                  else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3]) {
2303   4                      //decrease year
2304   4                      year_l -= 1;
2305   4                      
2306   4                    
2307   4                  }
2308   3            sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2309   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2310   3                          
2311   3              }
2312   2              
2313   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '4' == userCommand[3]) {
2314   3                  //previous in menu
2315   3                  if (selection == 0) {
2316   4                      selection = 6;
2317   4                  }
2318   3                  else {
2319   4                      selection -= 1;
2320   4                  }
2321   3                  //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2322   3              }
2323   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '5' == userCommand[3]) {
2324   3                  //next in menu
2325   3                  if (selection == 6) {
2326   4                      selection = 0;
2327   4                  }
2328   3                  else {
2329   4                      selection += 1;
2330   4                  }
2331   3                  //display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2332   3              }
2333   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '6' == userCommand[3]) {
2334   3                  // store the values (Enter is pressed, 156)
2335   3                  seconds = seconds_l;
2336   3                  minutes = minutes_l;
2337   3                  hours = hours_l;
2338   3                  amPm = amPm_l;
2339   3                  //day = day_l;
2340   3                  date = date_l;
2341   3                  month = month_l;
2342   3                  year = year_l;
2343   3                  set = 1;
2344   3                  setClock();                                                                            // Set 
             -real time clock
2345   3                  screen_index = PAGE_MAIN;
2346   3                  //enter directs to settings page where user has to enter password again
2347   3              }
2348   2              
2349   2              if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3])
2350   2              {
2351   3                  screen_index = PAGE_SETTINGS;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 41  

2352   3                  set = 1;
2353   3              }
2354   2              if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2355   3                  screen_index = PAGE_MAIN;
2356   3                  set = 1;
2357   3              }
2358   2              if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2359   3                  screen_index = PAGE_SERVICE;
2360   3                  set = 1;
2361   3              }
2362   2          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
2363   2          display_text(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 55, 190);
2364   2          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
2365   2          display_text(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 55, 240);
2366   2          } //end of while
2367   1          return screen_index;
2368   1      }
2369          
2370          //-------------------------------------------------------------------------------------------------------
2371          // Main
2372          //-------------------------------------------------------------------------------------------------------
2373          
2374          
2375          #define PAGE_SETTINGS_SUCCESS 5
2376          int current_page = 1;
2377          volatile int busyWait = 0;
2378          
2379          void main()
2380          {
2381   1          int i = 0;
2382   1          int count = 0;
2383   1          int prev_temp = 0;
2384   1          int display_celsius = 0;
2385   1          int state_changed = 1;
2386   1          char str[SPRINTF_SIZE];
2387   1          int brightness = 0;
2388   1          int volume = 0;
2389   1          
2390   1          disableWatchdog();
2391   1          systemClockInit();
2392   1          portInit();
2393   1          enableInterrupts();
2394   1          uart0Init();
2395   1          smbInit();
2396   1          timer3Init();
2397   1          
2398   1          tsLastCharGone = 1;
2399   1          tsTxOut = tsTxIn = 0;
2400   1          tsTxEmpty = 1;
2401   1          
2402   1          sprintf(str, "z\r"); //clear screen
2403   1          sendCommand(str); //clear screen
2404   1          send_macro(Splash); //startUp page
2405   1        //   while(i < 600) { i++;
2406   1          // //sprintf(str,"%d", i);
2407   1        //     //  display_text("000000","FFFFFF",6,str, 240,40);
2408   1          //  if (i == 599){
2409   1      
2410   1          //    sprintf(str,"%d", i);
2411   1        //       display_text("000000","FFFFFF",6,str, 240,40);
2412   1          //  }
2413   1          // } //wait for startup graphics to finish
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 42  

2414   1        //   i = 0;
2415   1          //state_changed = 1;
2416   1          //current_page = PAGE_MAIN;
2417   1          
2418   1          while(!splashEnd);
2419   1          while(1)
2420   1          {
2421   2              //scanUserInput();                                                        // Detect a string input
             - from the touch screen
2422   2              
2423   2              
2424   2              //sprintf(str,"%d", current_page);
2425   2              //display_text("000000","FFFFFF",6,str, 240,40);
2426   2              switch(current_page)
2427   2              {
2428   3                  case (PAGE_SETTINGS_SUCCESS):
2429   3                  {
2430   4                      if(state_changed)
2431   4                      {
2432   5                          state_changed = 0;
2433   5                        }
2434   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2435   5                          current_page = PAGE_SETTINGS;
2436   5                          state_changed = 1;
2437   5                          break;
2438   5                      }
2439   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2440   5                          current_page = PAGE_MAIN;
2441   5                          state_changed = 1;
2442   5                          break;
2443   5                      }
2444   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2445   5                          current_page = PAGE_SERVICE;
2446   5                          state_changed = 1;
2447   5                          break;
2448   5                      }
2449   4                      break;
2450   4                  }
2451   3                      
2452   3                  case (PAGE_SETTINGS):
2453   3                  {
2454   4                      
2455   4                      if (state_changed) {
2456   5                state_changed = 0;
2457   5                send_macro(display_settings_new);
2458   5                          //clear passcode
2459   5                passcode[0] = '\0';
2460   5                          draw_rectangle(244, 97, 390, 129, 1);
2461   5                          display_text("000000", "FFFFFF", 4, "Maintenance", 0, 30);
2462   5                          
2463   5                      }
2464   4                      
2465   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2466   5                          current_page = PAGE_SETTINGS;
2467   5                          state_changed = 0;
2468   5                          break;
2469   5                      }
2470   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2471   5                          current_page = PAGE_MAIN;
2472   5                          state_changed = 1;
2473   5                          break;
2474   5                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 43  

2475   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2476   5                          current_page = PAGE_SERVICE;
2477   5                          state_changed = 1;
2478   5                          break;
2479   5                      }
2480   4                      else {
2481   5                          for (k = 0; k < 4 ; ){
2482   6                              
2483   6                              while(tsCommandReceived == 0);
2484   6                              if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2485   7                                  current_page = PAGE_SETTINGS;
2486   7                                  state_changed = 0;
2487   7                                  break;
2488   7                              }
2489   6                              else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) 
             -{
2490   7                                  current_page = PAGE_MAIN;
2491   7                                  state_changed = 1;
2492   7                                  break;
2493   7                              }
2494   6                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) 
             -{
2495   7                                  current_page = PAGE_SERVICE;
2496   7                                  state_changed = 1;
2497   7                                  break;
2498   7                              }
2499   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '3' == userCommand[3]) 
             -{
2500   7                                  if(strcmp(passcode,ACTUAL) == 0){
2501   8                                      //display_text("000000","FFFFFF",6,"OK!", 240,200);
2502   8                                      current_page = PAGE_CONFIG;
2503   8                                      state_changed = 1;
2504   8                               //       send_macro(display_configuration);
2505   8                                  }
2506   7                                  else {
2507   8                      sprintf(str, "%s", "ERROR");
2508   8                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 280, 105);
2509   8                                      k = 0;
2510   8                                      current_page = PAGE_SETTINGS;
2511   8                                      state_changed = 0;
2512   8                                  }
2513   7                                  break;//continue;
2514   7                              }
2515   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '2' == userCommand[3]) 
             -{
2516   7                                  size_t len = strlen(passcode);
2517   7                                  if(len > 0) passcode[len-1]=0;
2518   7                                  // k = 0;
2519   7                                  current_page = PAGE_SETTINGS;
2520   7                              }
2521   6                              else if(k < 4) {
2522   7                                  if(handle_passcode(k)) k++;
2523   7                                  current_page = PAGE_SETTINGS;
2524   7                              }
2525   6                              //tsCommandReceived  = 0;
2526   6                          }
2527   5                      }
2528   4                      break;
2529   4                  }
2530   3                  case (PAGE_CONFIG):
2531   3                  {
2532   4                      if (state_changed) {
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 44  

2533   5                          state_changed = 0;
2534   5                          send_macro(display_configuration);
2535   5                          //display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
2536   5                      }
2537   4                      
2538   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2539   5                          current_page = PAGE_SETTINGS;
2540   5                          state_changed = 1;
2541   5                      }
2542   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2543   5                          current_page = PAGE_MAIN;
2544   5                          state_changed = 1;
2545   5                      }
2546   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2547   5                          current_page = PAGE_SERVICE;
2548   5                          state_changed = 1;
2549   5                      }
2550   4                      else {
2551   5                          current_page = set_Clock();
2552   5                          state_changed = 1;
2553   5                      }
2554   4                      break;
2555   4                  }
2556   3                  case (PAGE_SERVICE):
2557   3                  {
2558   4                      // display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2559   4                      if (state_changed) {
2560   5                          char * tempString[10];
2561   5                          state_changed = 0;
2562   5                          send_macro(display_service);
2563   5                          display_text("000000", "FFFFFF", 4, "Config", 0, 30);
2564   5                          display_text("000000", "FFFFFF", 3, "Brightness: ", 135, 225);
2565   5                          sprintf(tempString, "%u", brightness);
*** WARNING C182 IN LINE 2565 OF main.c: pointer to different objects
2566   5                          display_text("000000", "FFFFFF", 3, tempString, 285, 225);
*** WARNING C182 IN LINE 2566 OF main.c: pointer to different objects
2567   5                          display_text("000000", "FFFFFF", 3, "Volume: ", 360, 225);
2568   5                          sprintf(tempString, "%u", volume);
*** WARNING C182 IN LINE 2568 OF main.c: pointer to different objects
2569   5                          display_text("000000", "FFFFFF", 3, tempString, 455, 225);
*** WARNING C182 IN LINE 2569 OF main.c: pointer to different objects
2570   5      
2571   5                          set_slider(200, brightness);
2572   5                          set_slider(201, volume);
2573   5                      }
2574   4                      
2575   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2576   5                          current_page = PAGE_SETTINGS;
2577   5                          state_changed = 1;
2578   5                      }
2579   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2580   5                          current_page = PAGE_MAIN;
2581   5                          state_changed = 1;
2582   5                      }
2583   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2584   5                          current_page = PAGE_SERVICE;
2585   5                          state_changed = 0;
2586   5                      }
2587   4                      else {
2588   5                          // NOOP
2589   5                      }
2590   4                      if(sliderCommandReceived)
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 45  

2591   4                      {
2592   5                          if ('2' == userCommand[1] && '0' == userCommand[2] && '0' == userCommand[3])
2593   5                          {
2594   6                              int i = 0;
2595   6                              char temp[4] = { 0 };
2596   6                              
2597   6                              for(i = 0; i < 3; i++)
2598   6                              {
2599   7                                  if(userCommand[5+i] != '\r')
2600   7                                  {
2601   8                                      temp[i] = userCommand[5+i];
2602   8                                  }
2603   7                                  else
2604   7                                  {
2605   8                                      temp[i] = '\r';
2606   8                                      break;
2607   8                                  }
2608   7                              }
2609   6                              temp[3] = '\0';
2610   6                              brightness = atoi(temp);
2611   6                              display_test_pad_3("000000", "FFFFFF", 3, temp, 285, 225);
2612   6                              set_brightness(temp);
2613   6                          }
2614   5      
2615   5                          else if ('2' == userCommand[1] && '0' == userCommand[2] && '1' == userCommand[3])
2616   5                          {
2617   6                              int i = 0;
2618   6                              char temp[4] = { 0 };
2619   6                              for(i = 0; i < 3; i++)
2620   6                              {
2621   7                                  if(userCommand[5+i] != '\r')
2622   7                                  {
2623   8                                      temp[i] = userCommand[5+i];
2624   8                                  }
2625   7                                  else
2626   7                                  {
2627   8                                      temp[i] = '\r';
2628   8                                      break;
2629   8                                  }
2630   7                              }
2631   6                              temp[3] = '\0';
2632   6                              volume = atoi(temp);
2633   6                              display_test_pad_3("000000", "FFFFFF", 3, temp, 455, 225);
2634   6                              set_volume(temp);
2635   6                          }
2636   5                          sliderCommandReceived = 0;
2637   5                      }
2638   4                      break;
2639   4                  }
2640   3                  default:            // no break
2641   3                  case (PAGE_MAIN) :
2642   3                  {
2643   4                      //sprintf(str, "%d", state_changed);
2644   4                      //display_text("000000", "FFFFFF", 8, str, 240, 110);
2645   4                      roomTemp1 = readOneByteFromSlave(ROOM_TEMP_1);
2646   4                      
2647   4                      
2648   4                      if (state_changed) {
2649   5                          state_changed = 0;
2650   5                          while(busyWait < 5000)
2651   5                          {
2652   6                              busyWait++;
C51 COMPILER V9.56.0.0   MAIN                                                              12/04/2017 21:26:44 PAGE 46  

2653   6                          }
2654   5                          sprintf(str, "%-3buC", roomTemp1);
2655   5                send_macro(display_temperature); //main_page/ temperature display
2656   5                          display_text("000000", "FFFFFF", 4, "Temperature", 0, 30);
2657   5                          display_text("000000", "FFFFFF", 6, str, 240, 110);
2658   5                      }
2659   4                      
2660   4                      if (tsCommandReceived || roomTemp1 != prev_temp)
2661   4                      {
2662   5                          prev_temp = roomTemp1;
2663   5                          
2664   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
2665   6                              display_celsius = 1;
2666   6                              sprintf(str, "%-3buC", roomTemp1);
2667   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2668   6                          }
2669   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2670   6                              display_celsius = 0;
2671   6                              roomTemp1 = (roomTemp1 * 9) / 5 + 32;
2672   6                              sprintf(str, "%-3buF", roomTemp1);
2673   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2674   6                          }
2675   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2676   6                              current_page = PAGE_SETTINGS;
2677   6                              state_changed = 1;
2678   6                          }
2679   5                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2680   6                              current_page = PAGE_MAIN;
2681   6                              state_changed = 0;
2682   6                          }
2683   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2684   6                              current_page = PAGE_SERVICE;
2685   6                              state_changed = 1;
2686   6                          }
2687   5                          else {
2688   6                              // Noop
2689   6                          }
2690   5                      }
2691   4                      break;
2692   4                  }
2693   3              }//switch ends
2694   2          } //while ends
2695   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  10705    ----
   CONSTANT SIZE    =   1291    ----
   XDATA SIZE       =   3538    1292
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     21       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  4 WARNING(S),  0 ERROR(S)
