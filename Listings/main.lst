C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 1   


C51 COMPILER V9.56.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE main.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Listing
                    -s\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include <main.h>
   2          #include "macros.h"
   3          
   4          //-------------------------------------------------------------------------------------------------------
   5          // Global Declarations
   6          //-------------------------------------------------------------------------------------------------------
   7          
   8          //edits - added new
   9          
  10          //Passcode
  11          int k = 0;
  12          char passcode[] = "";
  13          char *ACTUAL = "1457";
  14          
  15          // real time clock
  16          unsigned char seconds_l;
  17          unsigned char minutes_l;
  18          unsigned char hours_l;
  19          unsigned char amPm_l;
  20          unsigned char date_l;
  21          unsigned char month_l;
  22          unsigned char year_l;
  23          unsigned char selection;
  24          unsigned char set;
  25          
  26          const char code *setDateTime[] =  {/*0*/  "SET SECONDS",
  27              /*1*/ "SET MINUTES",
  28              /*2*/ "SET HOURS",
  29              /*3*/ "SET AM/PM",
  30              /*4*/ "SET DATE",
  31              /*5*/ "SET MONTH",
  32              /*6*/ "SET YEAR"};
  33          
  34          
  35          //original code's variables
  36          
  37          unsigned char tsByte;
  38          
  39          bit splashEnd = 0;
  40          bit screenReset = 0;
  41          bit ackFromScreen = 0;
  42          bit tsCommandReceived = 0;
  43          bit tsCommandTransmitted = 0;
  44          bit SMB_RW;                                                           // Software flag to indicate Read or Writ
             -e
  45          
  46          unsigned char sharedDataRx[SHARED_DATA_MAX];
  47          unsigned char sharedDataTx[SHARED_DATA_MAX];
  48          unsigned char eepromTx[EEPROM_TX_BUFFER];
  49          unsigned char eepromRx[EEPROM_RX_BUFFER];
  50          unsigned char eepromPageTx[EEPROM_PAGE_SIZE];
  51          
  52          unsigned int pageCount;
  53          unsigned int bytesExtra;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 2   

  54          unsigned int eepromPageCounter;
  55          unsigned int startAddr;
  56          unsigned char slaveAddr;                                                // Target SMBus slave address
  57          unsigned char eepromDataByte;
  58          
  59          unsigned int numBytesRD;
  60          unsigned int numBytesWR;
  61          unsigned char slaveWriteDone;
  62          unsigned char slaveReadDone;
  63          unsigned char eepromWriteDone;
  64          unsigned char eepromReaddone;
  65          unsigned char rtcWriteDone;
  66          unsigned char rtcReadDone;
  67          
  68          unsigned char tsRxBuffer[RX_BUFFER_SIZE];
  69          unsigned char tsTxBuffer[TX_BUFFER_SIZE];
  70          unsigned char userCommand[RX_BUFFER_SIZE];
  71          
  72          unsigned int tsRxIn;
  73          unsigned int tsRxOut; 
  74          unsigned int tsTxIn;
  75          unsigned int tsTxOut;
  76          
  77          bit tsRxEmpty;
  78          bit tsTxEmpty;
  79          bit tsLastCharGone; 
  80          
  81          bit screenChanged;
  82          unsigned char screen;
  83          unsigned char lastScreen;
  84          
  85          const char code * Font[] = {/*0*/ "m10B", 
  86              /*1*/ "m12B",
  87              /*2*/ "m14B",
  88              /*3*/ "m16B",
  89              /*4*/ "m20B",
  90              /*5*/ "m24B",
  91              /*6*/ "m32B",
  92              /*7*/ "m48",
  93              /*8*/ "m64"};
  94          
  95          bit SMB_BUSY = 0;                                                       // Set to claim the bus, clear to free
  96          bit SMB_RW;                                                                     // Software flag to indica
             -te Read or Write
  97          
  98          unsigned int startAddr;
  99          unsigned char slaveAddr;                                                // Target SMBus slave address
 100          
 101          unsigned int numBytesRD;
 102          unsigned int numBytesWR;
 103          
 104          unsigned char slaveWriteDone;
 105          unsigned char slaveReadDone;
 106          
 107          unsigned char roomTemp1;
 108          unsigned char roomTemp2;
 109          unsigned char roomTemp3;
 110          
 111          unsigned char seconds;
 112          unsigned char minutes;
 113          unsigned char hours;
 114          unsigned char hours24;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 3   

 115          unsigned char amPm;
 116          unsigned char day;
 117          unsigned char date;
 118          unsigned char month;
 119          unsigned char year;
 120          unsigned char century;
 121          unsigned char timeMode;
 122          unsigned char currentIndex = 0;
 123          unsigned char minuteIndex = 0;
 124          unsigned char hourIndex = 0;
 125          
 126          unsigned char currentDate;
 127          unsigned char currentMonth;
 128          unsigned char currentYear;
 129          
 130          unsigned char realTimeClockItems;
 131          
 132          unsigned char adjustedSeconds;
 133          unsigned char adjustedMinutes;
 134          unsigned char adjustedHours;
 135          unsigned char adjustedAmPm;
 136          unsigned char adjustedDay;
 137          unsigned char adjustedDate;
 138          unsigned char adjustedMonth;
 139          unsigned char adjustedYear;
 140          unsigned char adjustedCentury;
 141          unsigned char adjustedTimeMode;
 142          
 143          bit monthUpdated;
 144          bit dateUpdated;
 145          bit yearUpdated;
 146          bit hoursUpdated;
 147          bit minutesUpdated;
 148          bit secondsUpdated;
 149          bit amPmUpdated;
 150          bit timeUpdated;
 151          bit monthDateYearUpdated;
 152          
 153          const char code * dayOfWeek[] =   {/*0*/  "NON",
 154              /*1*/ "SUN",
 155              /*2*/ "MON",
 156              /*3*/ "TUE",
 157              /*4*/ "WED",
 158              /*5*/ "THU",
 159              /*6*/ "FRI",
 160              /*7*/ "SAT"};
 161          
 162          const char code * monthOfYear[] =   {/*0*/  "NON",
 163              /*1*/ "JAN",
 164              /*2*/ "FEB",
 165              /*3*/ "MAR",
 166              /*4*/ "APR",
 167              /*5*/ "MAY",
 168              /*6*/ "JUN",
 169              /*7*/ "JUL",
 170              /*8*/ "AUG",
 171              /*9*/ "SEP",
 172              /*10*/  "OCT",
 173              /*11*/  "NOV",
 174              /*12*/  "DEC"};
 175          
 176          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 4   

 177          const char code * clockSetupMsg[] = {/*0*/  "SET DATE AND TIME      ",
 178              /*1*/ "WRITING DATA... WAIT!  ",
 179              /*2*/ "DATA SUCCESSFULLY SAVED",
 180              /*3*/ "ERROR                  "};
 181          
 182          //-------------------------------------------------------------------------------------------------------
 183          // System Configurations
 184          //-------------------------------------------------------------------------------------------------------
 185          void systemClockInit(void)
 186          {
 187   1          char SFRPAGE_SAVE = SFRPAGE;                            // Save Current SFR page
 188   1          int i = 0;
 189   1          
 190   1          SFRPAGE  = CONFIG_PAGE;
 191   1          
 192   1          OSCICN    = 0x83;
 193   1          
 194   1          SFRPAGE = SFRPAGE_SAVE;                                 // Restore SFRPAGE
 195   1      }
 196          
 197          void portInit(void)
 198          {
 199   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 200   1          
 201   1          SFRPAGE = CONFIG_PAGE;                                              // Set SFR page
 202   1          
 203   1          XBR0 = 0x2F;                                // Enable UART0, UART1, SPI0, SMB, CEX0 - CEX4
 204   1          XBR1 = 0x01;
 205   1          XBR2 = 0xC4;                                // Enable crossbar and disable weak pull-up
 206   1          
 207   1          P0MDOUT = 0x01;                                                     // Set TX0 pin to push-pull
 208   1          // TX0 = P0.0; RX0 = P0.1
 209   1          P1MDOUT = 0x01;                               // Set TX1 pin to push-pull, P1.0
 210   1          // TX1 = P1.0; RX1 = P1.1
 211   1          P3MDOUT = 0xCA;                               // P3.0, P3.2, P3.4, P3.5: open drain; P3.1, P3.3, P3.6, P3.7: push pul
             -l
 212   1          
 213   1          P4MDOUT = 0x0F;                               // P4.0, P4.1, P4.2, P4.3: push pull
 214   1          
 215   1          P5MDOUT = 0x04;                               // P5.0 open drain; P5.1 Open drain; P5.2 Push pull
 216   1          
 217   1          P6MDOUT = 0x00;
 218   1          
 219   1          P7MDOUT = 0x80;                               // Set P7.7 push-pull (smb error line)
 220   1          
 221   1          P0 = 0xFF;                                  // Initialize port P0 latch
 222   1          P1 = 0xFF;                                  // Initialize port P1 latch
 223   1          P2 = 0xFF;                                  // Initialize port P2 latch
 224   1          P3 = 0xFF;                                  // Initialize port P3 latch
 225   1          P4 = 0xFF;                                  // Initialize port P4 latch
 226   1          P5 = 0xFF;                                  // Initialize port P5 latch
 227   1          P6 = 0xFF;                                  // Initialize port P6 latch
 228   1          P7 = 0xFF;                                  // Initialize port P7 latch
 229   1          
 230   1          RHW = 0;                                  // Pull low SMB error line
 231   1          
 232   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 233   1      }
 234          
 235          void enableInterrupts(void)
 236          {
 237   1          IE = 0x92;                                  // Enable all interrupts + UART0 + Timer 0
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 5   

 238   1          EIE2 |= 0x01;                                                     // Enable Timer 3 interrupt
 239   1          EIE2 |= 0x40;                               // Enable UART1 interrupt
 240   1          EIE1 |= 0x0A;                               // Enable SMBus interrupt
 241   1      }
 242          
 243          void uart0Init(void)
 244          {
 245   1          char SFRPAGE_SAVE;
 246   1          
 247   1          SFRPAGE_SAVE = SFRPAGE;                                             // Preserve SFRPAGE
 248   1          
 249   1          SFRPAGE = TMR2_PAGE;
 250   1          TMR2CN = 0x00;                                                      // Stop timer. Timer 2 in 16-bit auto
             --reload up timer mode
 251   1          TMR2CF = 0x08;                                                      // SYSCLK is time base; no output; up
             - count only
 252   1          RCAP2L = 0xF3;                                                               // Low byte
 253   1          RCAP2H = 0xFF;                                                               // High byte
 254   1          TMR2 = RCAP2;                                                                // Load 16 bit reload val
             -ue into timer 2
 255   1          TMR2CN = 0x04;                                                               // Enable timer 2 (Start 
             -timer 2)
 256   1          
 257   1          SFRPAGE = UART0_PAGE;
 258   1          SCON0 = 0x50;                                                       // 8-bit variable baud rate; 9th bit 
             -ignored; RX enabled
 259   1          SSTA0 = 0x05;                                                       // Enable baud rate
 260   1          // Use timer 2 as RX and TX baud rate source
 261   1          IE = 0x90;                                                                   // Enable all interrupts 
             -and UART0 Interrupt
 262   1          
 263   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 264   1      }
 265          
 266          void disableWatchdog(void)
 267          {
 268   1          WDTCN = 0xDE;                                               // Disable watchdog timer
 269   1          WDTCN = 0xAD;
 270   1      }
 271          
 272          void uart0Interrupt(void) interrupt INTERRUPT_UART_0 using 2
 273          {
 274   1          char SFRPAGE_SAVE = SFRPAGE;
 275   1          unsigned int i = 0;
 276   1          unsigned long txWaitCounter = 0;
 277   1          
 278   1          SFRPAGE = UART0_PAGE;
 279   1          
 280   1          if(RI0 == 1)                                                        // There is a char in SBUF
 281   1          {
 282   2              RI0 = 0;                                                    // Clear interrupt flag
 283   2              
 284   2              tsByte = SBUF0;                                             // Read a character from UART
 285   2              
 286   2              if(tsRxIn < RX_BUFFER_SIZE)                       // If buffer size is within limit
 287   2              {
 288   3                  if(tsByte != '\r')                          // Check end of a command from touch screen
 289   3                  {
 290   4                      tsRxBuffer[tsRxIn] = tsByte;                  // Store a character in software buffer
 291   4                      tsRxIn++;                           // Increment index
 292   4                  }
 293   3                  else                                // If it is CR character, it marks end of command
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 6   

 294   3                  {
 295   4                      if(tsRxBuffer[0] == '{')                                        // Splash screen indicator
 296   4                      {
 297   5                          if(tsRxBuffer[1] == 'c' && tsRxBuffer[2] == 'm' && tsRxBuffer[3] == 'p' && tsRxBuffer[
             -4] == 'e' && tsRxBuffer[5] == '}')
 298   5                          {
 299   6                              splashEnd = 1;                                        // Detect end of splash scree
             -n
 300   6                              screenReset = 1;                    // Screen was reset, so touch screen sends {babe\r}
 301   6                          }
 302   5                          else
 303   5                          {
 304   6                              splashEnd = 0;                                          // End of splash screen NO
             -T detected
 305   6                              screenReset = 0;
 306   6                          }
 307   5                      }
 308   4                      else if(tsRxBuffer[0] == 'x')                                   // It is a command from to
             -uch screen controller
 309   4                      {                                                               // A command starts with '
             -('
 310   5                          for(i = 0; i < tsRxIn; i++)
 311   5                          {
 312   6                              userCommand[i] = tsRxBuffer[i];                         // Copy to command array f
             -or later evaluation
 313   6                          }
 314   5                          
 315   5                          ackFromScreen = 0;                                          // This is a command, NOT 
             -an ACK
 316   5                          tsCommandReceived = 1;                                      // Set flag when a complet
             -e command is received
 317   5                      }
 318   4                      else if(tsRxBuffer[0] == '(')                   // It is a command from touch screen controller
 319   4                      {                               // A command starts with '('
 320   5                          for(i = 0; i < tsRxIn; i++)
 321   5                          {
 322   6                              userCommand[i] = tsRxBuffer[i];             // Copy to command array for later evaluatio
             -n
 323   6                          }
 324   5                          
 325   5                          ackFromScreen = 0;                      // This is a command, NOT an ACK
 326   5                          tsCommandReceived = 1;                    // Set flag when a complete command is received
 327   5                      }
 328   4                      else                              // Not a command from touch screen controller
 329   4                      {
 330   5                          ackFromScreen = 1;                      // Set a flag to indicate it is an ACK from screen
 331   5                          tsCommandReceived = 0;                    // No need to set flag because it is not a command
 332   5                      }
 333   4                      
 334   4                      for(i = 0; i < tsRxIn; i++)
 335   4                      {
 336   5                          tsRxBuffer[i] = '\0';                   // Delete all contents
 337   5                      }
 338   4                      
 339   4                      tsRxOut = 0;                          // Reset index Out
 340   4                      tsRxIn = 0;                           // Reset index In
 341   4                  }
 342   3              }
 343   2              else                                  // Reset all indexes
 344   2              {
 345   3                  while(tsRxOut < tsRxIn)
 346   3                  {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 7   

 347   4                      tsRxBuffer[tsRxOut] = '\0';
 348   4                      tsRxOut++;
 349   4                  }
 350   3                  tsRxOut = 0;
 351   3                  tsRxIn = 0;
 352   3                  tsCommandReceived = 0;
 353   3              }
 354   2          }
 355   1          
 356   1          if(TI0 == 1)                                                // Check if one character is successfully sent out
 357   1          {
 358   2              TI0 = 0;                                                    // Clear interrupt flag
 359   2              
 360   2              if(tsTxEmpty == 0)                            // TX buffer has something to send
 361   2              {
 362   3                  SBUF0 = tsTxBuffer[tsTxOut];                    // Send a character in TX buffer
 363   3                  tsTxOut++;                              // Move to next character
 364   3                  
 365   3                  while(TI0 == 0 && txWaitCounter++ < TX_WAIT_LIMIT);         // Wait until completion of transmissi
             -on TI0 = 1
 366   3                  if(txWaitCounter >= TX_WAIT_LIMIT)
 367   3                  {
 368   4                      TI0 = 1;                            // TI0 is not set by hardware, set it by software
 369   4                  }                                 // When TI0 is set to 1, this ISR is executed again
 370   3                  
 371   3                  txWaitCounter = 0;                          // Reset counter for next execution
 372   3                  
 373   3                  if(tsTxOut >= TX_BUFFER_SIZE)
 374   3                  {
 375   4                      tsTxOut = 0;                          // Reset index to 0
 376   4                  }
 377   3                  
 378   3                  if(tsTxOut == tsTxIn)                       // If two indexes are equal
 379   3                  {
 380   4                      tsTxEmpty = 1;                          // No more character in buffer. Empty
 381   4                  }
 382   3              }
 383   2              else
 384   2              {
 385   3                  tsLastCharGone = 1;                         // Last character has gone. Buffer is empty
 386   3              }
 387   2          }
 388   1          
 389   1          SFRPAGE = SFRPAGE_SAVE;                                           // Restore SFR page detector
 390   1      }
 391          
 392          //-------------------------------------------------------------------------------------------------------
 393          // Function Name: sendCommand
 394          // Return Value: None 
 395          // Parmeters: s (a string to send)
 396          // Function Description: This function sends a command from the touch screen
 397          //-------------------------------------------------------------------------------------------------------
 398          void sendCommand(const char * s)
 399          { 
 400   1          char SFRPAGE_SAVE = SFRPAGE;
 401   1          
 402   1          while(*s != '\0')                             // Search for end of touch screen command in buffer
 403   1          {
 404   2              if(tsTxEmpty == 1 || (tsTxOut != tsTxIn))               // Tx is empty or two indexes are not equal
 405   2              {
 406   3                  tsTxBuffer[tsTxIn++] = *s;
 407   3                  if(tsTxIn >= TX_BUFFER_SIZE)                    // Check for limit
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 8   

 408   3                  {
 409   4                      tsTxIn = 0;                           // Reset if limit reached
 410   4                  }
 411   3                  
 412   3                  if(tsTxEmpty == 1)                          // If buffer is empty
 413   3                  {
 414   4                      tsTxEmpty = 0;                          // Now buffer has at leat 1 character, set flag
 415   4                  }
 416   3              }
 417   2              
 418   2              s++;                                  // Point to next char to send out
 419   2          }
 420   1          
 421   1          if(tsLastCharGone == 1)                           // All characters in buffer has sent out
 422   1          {
 423   2              tsLastCharGone = 0;                           // Reset flag to indicate no char left in buffer
 424   2              SFRPAGE = UART0_PAGE;
 425   2              TI0 = 1;                                                            // Set this flage to call ISR to
             - send out one character
 426   2          }
 427   1          
 428   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFRPAGE
 429   1      }
 430          
 431          //-------------------------------------------------------------------------------------------------------
 432          // Function Name: displayText
 433          // Return Value: None 
 434          // Parmeters: fg, bg, size, message, x, y
 435          // Function Description: This function displays a text on the touch screen
 436          //-------------------------------------------------------------------------------------------------------
 437          void displayText(const char* fg, const char* bg, const unsigned char size, const char* message, const unsi
             -gned int x, const unsigned int y)
 438          {
 439   1          char str[TS_BUFFER_SIZE] = { 0 };                         // String
 440   1          
 441   1          sprintf(str, "S %s %s\r", fg, bg);                      // Set forground and background color
 442   1          sendCommand(str);
 443   1          sprintf(str, "f %s\r", Font[size]);                     // Set text font
 444   1          sendCommand(str);
 445   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);              // Display text
 446   1          sendCommand(str);
 447   1      }
 448          
 449          //-------------------------------------------------------------------------------------------------------
 450          // Function Name: showBitmap
 451          // Return Value: None 
 452          // Parmeters: index, x, y (bitmap index and coordinates)
 453          // Function Description: This function displays a bitmap image
 454          //-------------------------------------------------------------------------------------------------------
 455          void showBitmap(const unsigned int index, const unsigned int x, const unsigned int y)
 456          {
 457   1          char str[TS_BUFFER_SIZE];
 458   1          
 459   1          sprintf(str, "xi %u %u %u\r", index, x, y);                 // Bitmap index
 460   1          sendCommand(str);
 461   1      }
 462          
 463          //-------------------------------------------------------------------------------------------------------
 464          // Function Name: changeScreen
 465          // Return Value: None 
 466          // Parmeters: screenIndex (macro number)
 467          // Function Description: This function switches to the new screen
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 9   

 468          //-------------------------------------------------------------------------------------------------------
 469          void changeScreen(const unsigned char screenIndex)
 470          {
 471   1          callMacro(screenIndex);                           // Change screen
 472   1      }
 473          
 474          //-------------------------------------------------------------------------------------------------------
 475          // Function Name: callMacro
 476          // Return Value: None 
 477          // Parmeters: macroNumber (macro number in the macro file)
 478          // Function Description: This function calls a macro
 479          //-------------------------------------------------------------------------------------------------------
 480          void callMacro(const unsigned int macroNumber)
 481          {
 482   1          char str[TS_BUFFER_SIZE];
 483   1          
 484   1          sprintf(str, "m %u\r", macroNumber);                    // Execute macro number
 485   1          sendCommand(str);
 486   1      }
 487          
 488          //-------------------------------------------------------------------------------------------------------
 489          // Function Name: scanUserInput
 490          // Return Value: None 
 491          // Parmeters: None
 492          // Function Description: This function processes commands from the touch screen
 493          //-------------------------------------------------------------------------------------------------------
 494          void scanUserInput(void)
 495          { 
 496   1          int i = 0;
 497   1          
 498   1          if(screen == MAIN_PAGE)                           // Main screen
 499   1          {
 500   2              if(userCommand[0] == '(')                       // Check for an actual command followed by this '(' character
 501   2              {
 502   3                  switch (userCommand[1])                         // Scan a command type
 503   3                  {
 504   4                      case '1':                           // Main page
 505   4                          changeScreen(MAIN_PAGE);                  // Stay in main page if main button is pressed again
 506   4                          break;
 507   4                      case '2':                           // Settings page
 508   4                          changeScreen(SETTINGS_PAGE);
 509   4                          break;
 510   4                      case '3':                             // Service page
 511   4                          changeScreen(SERVICE_PAGE);
 512   4                          break;
 513   4                      case 'A':
 514   4                          // Call a function here or do something here
 515   4                          break;
 516   4                      case 'B':
 517   4                          // Call a function here or do something here
 518   4                          break;
 519   4                      case 'C':
 520   4                          // Call a function here or do something here
 521   4                          break;
 522   4                      default:                            // Other options
 523   4                          break;
 524   4                  }
 525   3              }
 526   2              else                                  // Not a command, empty buffer with null char
 527   2              {
 528   3                  i = 0;
 529   3                  while(userCommand[i] != '\0')
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 10  

 530   3                  {
 531   4                      userCommand[i] = '\0';
 532   4                      i++;
 533   4                  }
 534   3              }
 535   2          }
 536   1          else if(screen == SETTINGS_PAGE)                      // Settings page
 537   1          {
 538   2              if(userCommand[0] == '(')
 539   2              {
 540   3                  switch (userCommand[1])
 541   3                  {
 542   4                      case '1':
 543   4                          changeScreen(MAIN_PAGE);
 544   4                          break;
 545   4                      case '2':
 546   4                          changeScreen(SETTINGS_PAGE);
 547   4                          break;
 548   4                      case '3':
 549   4                          changeScreen(SERVICE_PAGE);
 550   4                          break;
 551   4                      case 'A':
 552   4                          // Call a function here or do something here
 553   4                          break;
 554   4                      case 'B':
 555   4                          // Call a function here or do something here
 556   4                          break;
 557   4                      case 'C':
 558   4                          // Call a function here or do something here
 559   4                          break;
 560   4                      default:
 561   4                          break;
 562   4                  }
 563   3              }
 564   2              else                                  // Not a command, empty buffer with null
 565   2              {
 566   3                  i = 0;
 567   3                  while(userCommand[i] != '\0')
 568   3                  {
 569   4                      userCommand[i] = '\0';
 570   4                      i++;
 571   4                  }
 572   3              }
 573   2          }
 574   1          else if(screen == SERVICE_PAGE)
 575   1          {
 576   2              if(userCommand[0] == '(')
 577   2              {
 578   3                  switch (userCommand[1])
 579   3                  {
 580   4                      case '1':
 581   4                          changeScreen(MAIN_PAGE);
 582   4                          break;
 583   4                      case '2':
 584   4                          changeScreen(SETTINGS_PAGE);
 585   4                          break;
 586   4                      case '3':
 587   4                          changeScreen(SERVICE_PAGE);
 588   4                          break;
 589   4                      case 'A':
 590   4                          // Call a function here or do something here
 591   4                      case 'B':
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 11  

 592   4                          // Call a function here or do something here
 593   4                      case 'C':
 594   4                          // Call a function here or do something here
 595   4                      default:
 596   4                          break;
 597   4                  }
 598   3              }
 599   2              else                                  // Not a command, empty buffer with null
 600   2              {
 601   3                  i = 0;
 602   3                  while(userCommand[i] != '\0')
 603   3                  {
 604   4                      userCommand[i] = '\0';
 605   4                      i++;
 606   4                  }
 607   3              }
 608   2          }
 609   1          else
 610   1          {
 611   2              
 612   2          }
 613   1          
 614   1          i = 0;
 615   1          while(userCommand[i] != '\0')
 616   1          {
 617   2              userCommand[i] = '\0';                          // Delete all contents in array
 618   2              i++;
 619   2          }
 620   1      }
 621          
 622          //-------------------------------------------------------------------------------------------------------
 623          // Function Name: smbInit
 624          // Return Value: None 
 625          // Parmeters: None
 626          // Function Description: This function initializes the SMB bus 
 627          //-------------------------------------------------------------------------------------------------------
 628          void smbInit(void)
 629          {
 630   1          int i;
 631   1          unsigned long pollingCounter = 0;
 632   1          char SFRPAGE_SAVE = SFRPAGE;
 633   1          
 634   1          SFRPAGE = SMB0_PAGE;
 635   1          while(SDA == 0 && pollingCounter++ < SMB_POLLING_LIMIT)             // If slave is holding SDA low because o
             -f error or reset
 636   1          {
 637   2              SCL = 0;                                                          // Drive the clock low
 638   2              for(i = 0; i < 255; i++);                                         // Hold the clock low
 639   2              SCL = 1;                                                          // Release the clock
 640   2              while(SCL == 0 && pollingCounter++ < SMB_POLLING_LIMIT);          // Wait for open-drain
 641   2              for(i = 0; i < 10; i++);                                          // Hold the clock high
 642   2          }
 643   1          
 644   1          SMB0CN = 0x07;                                                      // Assert Acknowledge low (AA bit = 1b);
 645   1          // Enable SMBus Free timeout detect;
 646   1          SMB0CR = 267 - (SYSTEM_CLOCK / (8 * SMB_FREQUENCY));              // Derived approximation from the Tlow and 
             -Thigh equations
 647   1          
 648   1          SMB0CN |= 0x40;                                                     // Enable SMBus;
 649   1          
 650   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 651   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 12  

 652   1          SMB_BUSY = 0;
 653   1          // Release SMB
 654   1          slaveWriteDone = FALSE;
 655   1          slaveReadDone = FALSE;
 656   1          eepromWriteDone = FALSE;
 657   1          eepromReadDone = FALSE;
 658   1          rtcWriteDone = FALSE;
 659   1          rtcReadDone = FALSE;
 660   1      }
 661          
 662          //-------------------------------------------------------------------------------------------------------
 663          // Function Name: timer3Init
 664          // Return Value: None 
 665          // Parmeters: None
 666          // Function Description: This function nitializes timer 3 which is used to time out the SMB if errors occu
             -r
 667          //-------------------------------------------------------------------------------------------------------
 668          void timer3Init (void)
 669          {
 670   1          char SFRPAGE_SAVE = SFRPAGE;
 671   1          
 672   1          SFRPAGE = TMR3_PAGE;
 673   1          
 674   1          TMR3CN = 0x00;                                                      // Timer 3 in timer mode
 675   1          // Timer 3 auto reload
 676   1          TMR3CF = 0x00;                                                      // Timer 3 prescaler = 12
 677   1          
 678   1          RCAP3 = -(SYSTEM_CLOCK / 12 / 40);                                    // Timer 3 overflows after 25 ms
 679   1          TMR3 = RCAP3;
 680   1          
 681   1          TR3 = 1;                                                            // Start Timer 3
 682   1          
 683   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page
 684   1      }
 685          
 686          //-------------------------------------------------------------------------------------------------------
 687          // Function Name: timer3ISR
 688          // Return Value: None 
 689          // Parmeters: None
 690          // Function Description: This function is timer 3 ISR which is used to reset the SMB bus if the clock line
             - is held for too long
 691          //-------------------------------------------------------------------------------------------------------
 692          void timer3ISR(void) interrupt INTERRUPT_Timer_3
 693          {
 694   1          char SFRPAGE_SAVE = SFRPAGE;                                        // Save Current SFR page
 695   1          
 696   1          SFRPAGE = SMB0_PAGE;
 697   1          SMB0CN &= ~0x40;                                                    // Disable SMBus
 698   1          SMB0CN |= 0x40;                                                     // Re-enable SMBus
 699   1          
 700   1          SFRPAGE = SFRPAGE_SAVE;                                             // Switch back to the Timer3 SFRPAGE
 701   1          TF3 = 0;                                                            // Clear Timer3 interrupt-pending flag
 702   1          SMB_BUSY = 0;                                                       // Free bus
 703   1          
 704   1          SFRPAGE = SFRPAGE_SAVE;                                             // Restore SFR page detector
 705   1      }
 706          
 707          //-------------------------------------------------------------------------------------------------------
 708          // Function Name: writeOneByteToSlave
 709          // Return Value: None 
 710          // Parmeters: target, startAddr, content
 711          // Function Description: This function writes one to the slave microprocessor
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 13  

 712          //-------------------------------------------------------------------------------------------------------
 713          void writeOneByteToSlave(unsigned char startAddr, unsigned char content)
 714          {       
 715   1          sharedDataTx[startAddr] = content;
 716   1          smbWrite(MCU_SLAVE_ADDR, startAddr, 1);
 717   1      }
 718          
 719          //-------------------------------------------------------------------------------------------------------
 720          // Function Name: readOneByteFromSlave
 721          // Return Value: long 
 722          // Parmeters: startAddr, bytes
 723          // Function Description: This function reads one from the slave microprocessor
 724          //-------------------------------------------------------------------------------------------------------
 725          unsigned char readOneByteFromSlave(unsigned char startAddr)
 726          {
 727   1          smbRead(MCU_SLAVE_ADDR, startAddr, 1);
 728   1          return sharedDataRx[startAddr];
 729   1      }
 730          
 731          //-------------------------------------------------------------------------------------------------------
 732          // Function Name: writeBytesToRealTimeClock
 733          // Return Value: None 
 734          // Parmeters: target, startAddr, bytes
 735          // Function Description: This function writes data byte to the real time clock DS3232
 736          //-------------------------------------------------------------------------------------------------------
 737          void writeBytesToRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 738          {
 739   1          smbWrite(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 740   1      }
 741          
 742          //-------------------------------------------------------------------------------------------------------
 743          // Function Name: readBytesFromRealTimeClock
 744          // Return Value: None 
 745          // Parmeters: target, startAddr, bytes
 746          // Function Description: This function reads data byte from the real time clock DS3232
 747          //-------------------------------------------------------------------------------------------------------
 748          void readBytesFromRealTimeClock(unsigned char startAddr, unsigned char numBytes)
 749          {
 750   1          smbRead(REAL_TIME_CLOCK_ADDR, startAddr, numBytes);
 751   1      }
 752          
 753          //-------------------------------------------------------------------------------------------------------
 754          // Function Name: smbRead
 755          // Return Value: unsigned char * 
 756          // Parmeters: target, startAddr, bytes
 757          // Function Description: This function reads from SM bus
 758          //-------------------------------------------------------------------------------------------------------
 759          void smbRead(unsigned char deviceId, unsigned int location, unsigned int bytes)
 760          {
 761   1          char SFRPAGE_SAVE = SFRPAGE;
 762   1          
 763   1          SFRPAGE = SMB0_PAGE;
 764   1          
 765   1          while(BUSY || SMB_BUSY);                                                // Wait for free SMB
 766   1          
 767   1          SFRPAGE = SFRPAGE_SAVE;
 768   1          
 769   1          switch(deviceId)
 770   1          {
 771   2              case MCU_SLAVE_ADDR:
 772   2              case REAL_TIME_CLOCK_ADDR:
 773   2              case EEPROM_ADDR:
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 14  

 774   2                  smbWrite(deviceId, location, 0);                      // Write address before reading
 775   2                  break;
 776   2              default:
 777   2                  break;
 778   2          }
 779   1          
 780   1          SFRPAGE = SMB0_PAGE;
 781   1          
 782   1          while(BUSY || SMB_BUSY);
 783   1          slaveAddr = deviceId;                                                     // Address of MCU slave
 784   1          startAddr = location;                                 // Starting address to read from slave
 785   1          numBytesRD = bytes;                                   // Number of bytes to read
 786   1          
 787   1          SMB_BUSY = 1;                                                           // Claim SMBus (set to busy)
 788   1          SMB_RW = 1;                                                             // Mark this transfer as a READ
 789   1          STA = 1;
 790   1          
 791   1          while(BUSY || SMB_BUSY);                                                    // Wait for SMB
 792   1          
 793   1          SFRPAGE = SFRPAGE_SAVE;
 794   1          
 795   1          switch(deviceId)
 796   1          {
 797   2              case MCU_SLAVE_ADDR:
 798   2                  while(slaveReadDone == 0);                                            // Wait until slave write 
             -completed
 799   2                  break;
 800   2              case REAL_TIME_CLOCK_ADDR:
 801   2                  while(rtcReadDone == 0);                                            // Wait until real time cloc
             -k write completed or timeout occurs
 802   2                  break;
 803   2              case EEPROM_ADDR:
 804   2                  while(eepromReadDone == 0);                                           // Wait until EEPROM writ
             -e completed
 805   2                  break;
 806   2              default:
 807   2                  break;
 808   2          }
 809   1      }
 810          
 811          //-------------------------------------------------------------------------------------------------------
 812          // Function Name: smbWrite
 813          // Return Value: unsigned char * 
 814          // Parmeters: target, startAddr, bytes
 815          // Function Description: This function reads to SM bus
 816          //-------------------------------------------------------------------------------------------------------
 817          void smbWrite(unsigned char deviceId, unsigned int location, unsigned int bytes)
 818          {
 819   1          unsigned char i = 0;
 820   1          unsigned int pageWrittenDelay = 0;
 821   1          char SFRPAGE_SAVE = SFRPAGE;
 822   1          
 823   1          SFRPAGE = SMB0_PAGE;
 824   1          
 825   1          while(BUSY || SMB_BUSY);                                                // Wait for SMB to be free
 826   1          slaveAddr = deviceId;                                                   // Address of MCU slave board
 827   1          startAddr = location;                               // Starting address to write to slave
 828   1          
 829   1          switch(deviceId)
 830   1          {
 831   2              case MCU_SLAVE_ADDR:                              // Pass through
 832   2              case DEVICE_DUMP_ADDR:                              // Pass through
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 15  

 833   2                  numBytesWR = bytes;                             // Number of bytes to read
 834   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 835   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 836   2                  STA = 1;                                                          // Start transfer
 837   2                  while(slaveWriteDone == 0);                                             // Wait until SRAM wri
             -te completed or timeout occurs
 838   2                  break;
 839   2              case REAL_TIME_CLOCK_ADDR:
 840   2                  numBytesWR = bytes;                             // Number of bytes to read
 841   2                  SMB_BUSY = 1;                                                     // Claim SMBus (set to busy)
 842   2                  SMB_RW = 0;                                                       // Mark this transfer as a WRIT
             -E
 843   2                  STA = 1;                                                          // Start transfer
 844   2                  while(rtcWriteDone == 0);                                             // Wait until SRAM write
             - completed or timeout occurs
 845   2                  break;
 846   2              default:
 847   2                  break;
 848   2          }
 849   1          
 850   1          SFRPAGE = SFRPAGE_SAVE;                             // Restore SFR page
 851   1      }
 852          
 853          //-------------------------------------------------------------------------------------------------------
 854          // Function Name: smbISR
 855          // Return Value: None 
 856          // Parmeters: None
 857          // Function Description: 
 858          // SMBus Interrupt Service Routine (ISR)
 859          // Anytime the SDA is pulled low by the master, this ISR will be called. For example, if STA = 1,
 860          // this ISR is called and SMB0STA = SMB_START = SMB_REPEAT_START. These cases are executed within the swit
             -ch statement.
 861          //-------------------------------------------------------------------------------------------------------
 862          void smbISR (void) interrupt INTERRUPT_SMB using 2
 863          {
 864   1          bit FAIL = 0;                                                       // Used by the ISR to flag failed trans
             -fers
 865   1          static unsigned int TxCounter;                          // Initialize counter
 866   1          static unsigned int RxCounter;                          // Initialize counter
 867   1          static unsigned int slaveCount = 0;
 868   1          static unsigned int realTimeClockCount = 0;
 869   1          static unsigned int eepromCount = 0;
 870   1          static unsigned char eepromAddrDone;
 871   1          
 872   1          switch (SMB0STA >> 3)                             // Check SMB bus status
 873   1          {
 874   2                  //--------------------------------------------------------------------------------------------
             ------------
 875   2                  // Master Transmitter/Receiver: START condition transmitted. Load SMB0DAT with slave device ad
             -dress
 876   2                  //--------------------------------------------------------------------------------------------
             ------------
 877   2              case SMB_START:                               // Master initiates a transfer
 878   2                  
 879   2                  //--------------------------------------------------------------------------------------------
             ------------
 880   2                  // Master Transmitter/Receiver: repeated START condition transmitted. Load SMB0DAT with slave 
             -device address
 881   2                  //--------------------------------------------------------------------------------------------
             ------------
 882   2              case SMB_REPEAT_START:
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 16  

 883   2                  SMB0DAT = slaveAddr;                                            // Load address of the slave.
 884   2                  SMB0DAT &= 0xFE;                                              // Clear the LSB of the address for t
             -he R/W bit
 885   2                  SMB0DAT |= SMB_RW;                                            // Load R/W bit (Read = 1; Write = 0)
 886   2                  STA = 0;                                                      // Manually clear STA bit
 887   2                  
 888   2                  RxCounter = 0;                                                // Reset the counter
 889   2                  TxCounter = 0;                                                // Reset the counter
 890   2                  eepromAddrDone = CLEAR;                         // For 2 byte EEPROM address
 891   2                  
 892   2                  break;
 893   2                  
 894   2                  //--------------------------------------------------------------------------------------------
             ------------
 895   2                  // Master Transmitter: Slave address + WRITE transmitted.  ACK received. For a READ: N/A
 896   2                  // For a WRITE: Send the first data byte to the slave
 897   2                  //--------------------------------------------------------------------------------------------
             ------------
 898   2              case SMB_ADDR_W_TX_ACK_RX:
 899   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 900   2                  {
 901   3                      if(startAddr == DEVICE_DUMP_ADDR)                 // Dump device address to check slave presence o
             -nly
 902   3                      {
 903   4                          STO = 1;                            // Stop this transfer
 904   4                          SMB_BUSY = 0;                         // Releas SMB
 905   4                      }
 906   3                      else
 907   3                      {
 908   4                          SMB0DAT = startAddr;                      // Send 1 byte address to slave
 909   4                          slaveWriteDone = 0;                       // Mark start of slave write
 910   4                      }
 911   3                  }
 912   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 913   2                  {
 914   3                      SMB0DAT = startAddr;                        // Point to byte address to write on real time clock
 915   3                      rtcWriteDone = 0;                         // Mark start of rtc write
 916   3                  }
 917   2                  else{}
 918   2                  break;
 919   2                  
 920   2                  //--------------------------------------------------------------------------------------------
             ------------
 921   2                  // Master Transmitter: Slave address + WRITE transmitted.  NACK received. Restart the transfer
 922   2                  //--------------------------------------------------------------------------------------------
             ------------
 923   2              case SMB_ADDR_W_TX_NACK_RX:
 924   2                  if(slaveAddr == MCU_SLAVE_ADDR || slaveAddr == WAVEFORM_GEN_ADDR )
 925   2                  {
 926   3                      if(slaveCount < MAX_NACK_RETRY)
 927   3                      {
 928   4                          slaveCount++;                         // Increment number of attempts when NACK is received
 929   4                          STA = 1;                            // Restart a new transfer
 930   4                      }
 931   3                      else
 932   3                      {
 933   4                          slaveCount = 0;                         // Reset this counter to keep retry seeking slave response
 934   4                          slaveWriteDone = 1;
 935   4                          STO = 1;
 936   4                          SMB_BUSY = 0;
 937   4                          FAIL = 1;
 938   4                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 17  

 939   3                  }
 940   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 941   2                  {
 942   3                      if(realTimeClockCount < MAX_NACK_RETRY)
 943   3                      {
 944   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
 945   4                          STA = 1;                            // Restart a new transfer
 946   4                      }
 947   3                      else
 948   3                      {
 949   4                          realTimeClockCount = 0;
 950   4                          rtcWriteDone = 1;
 951   4                          STO = 1;
 952   4                          SMB_BUSY = 0;
 953   4                          FAIL = 1;
 954   4                      }
 955   3                  }
 956   2                  else if(slaveAddr == EEPROM_ADDR)
 957   2                  {
 958   3                      if(eepromCount < MAX_NACK_RETRY)
 959   3                      {
 960   4                          eepromCount++;                          // Increment number of attempts when NACK is received
 961   4                          STA = 1;                            // Restart a new transfer
 962   4                      }
 963   3                      else
 964   3                      {
 965   4                          eepromCount = 0;
 966   4                          eepromWriteDone = 1;
 967   4                          STO = 1;
 968   4                          SMB_BUSY = 0;
 969   4                          FAIL = 1;
 970   4                      }
 971   3                  }
 972   2                  else
 973   2                  {}
 974   2                  
 975   2                  break;
 976   2                  
 977   2                  //--------------------------------------------------------------------------------------------
             ------------
 978   2                  //Master Transmitter: Data byte transmitted.  ACK received. For a READ: N/A
 979   2                  //For a WRITE: Send all data.  After the last data byte, send the stop bit
 980   2                  //--------------------------------------------------------------------------------------------
             ------------
 981   2              case SMB_DATA_TX_ACK_RX:
 982   2                  if(slaveAddr == MCU_SLAVE_ADDR)
 983   2                  {
 984   3                      if(TxCounter < numBytesWR)
 985   3                      {
 986   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
 987   4                          TxCounter++;
 988   4                      }
 989   3                      else
 990   3                      {
 991   4                          STO = 1;                                                // Set STO to terminate transfer
 992   4                          SMB_BUSY = 0;                                           // And free SMBus interface
 993   4                          slaveWriteDone = 1;                       // Mark end of slave write
 994   4                      }
 995   3                  }
 996   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
 997   2                  {
 998   3                      if(TxCounter < numBytesWR)
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 18  

 999   3                      {
1000   4                          SMB0DAT = sharedDataTx[startAddr + TxCounter];          // Send data byte
1001   4                          TxCounter++;
1002   4                      }
1003   3                      else
1004   3                      {
1005   4                          STO = 1;                                                // Set STO to terminate transfer
1006   4                          SMB_BUSY = 0;                                           // And free SMBus interface
1007   4                          rtcWriteDone = 1;                       // Mark end of slave write
1008   4                      }
1009   3                  }
1010   2                  break;
1011   2                  
1012   2                  //--------------------------------------------------------------------------------------------
             ------------
1013   2                  // Master Transmitter: Data byte transmitted.  NACK received. Restart the transfer
1014   2                  //--------------------------------------------------------------------------------------------
             ------------
1015   2              case SMB_DATA_TX_NACK_RX:
1016   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1017   2                  {
1018   3                      if(slaveCount < MAX_NACK_RETRY)
1019   3                      {
1020   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1021   4                          STA = 1;                            // Restart a new transfer
1022   4                      }
1023   3                      else
1024   3                      {
1025   4                          slaveCount = 0;
1026   4                          STO = 1;
1027   4                          SMB_BUSY = 0;
1028   4                          FAIL = 1;
1029   4                      }
1030   3                  }
1031   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1032   2                  {
1033   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1034   3                      {
1035   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1036   4                          STA = 1;                            // Restart a new transfer
1037   4                      }
1038   3                      else
1039   3                      {
1040   4                          realTimeClockCount = 0;
1041   4                          STO = 1;
1042   4                          SMB_BUSY = 0;
1043   4                          FAIL = 1;
1044   4                      }
1045   3                  }
1046   2                  else if(slaveAddr == EEPROM_ADDR)
1047   2                  {
1048   3                      if(eepromCount < MAX_NACK_RETRY)
1049   3                      {
1050   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1051   4                          STA = 1;                            // Restart a new transfer
1052   4                      }
1053   3                      else
1054   3                      {
1055   4                          eepromCount = 0;
1056   4                          STO = 1;
1057   4                          SMB_BUSY = 0;
1058   4                          FAIL = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 19  

1059   4                      }
1060   3                  }
1061   2                  else
1062   2                  {}
1063   2                  break;
1064   2                  
1065   2                  //--------------------------------------------------------------------------------------------
             ------------
1066   2                  // Master Receiver: Slave address + READ transmitted.  ACK received.
1067   2                  // For a READ: check if this is a one-byte transfer. if so, set the NACK after the data byte
1068   2                  // is received to end the transfer. if not, set the ACK and receive the other data bytes
1069   2                  //--------------------------------------------------------------------------------------------
             ------------
1070   2              case SMB_ADDR_R_TX_ACK_RX:
1071   2                  if(numBytesRD == 1)                           // If there is one byte to transfer, send a NACK and go to
1072   2                  {                                   // SMB_DATA_RX_NACK_TX case to accept data from slave
1073   3                      AA = 0;                                                   // Clear AA flag before data byte is 
             -received
1074   3                      // send NACK signal to slave after byte is received
1075   3                  }
1076   2                  else
1077   2                  {
1078   3                      AA = 1;                                                   // More than one byte in this transfe
             -r,
1079   3                      // send ACK after byte is received
1080   3                  }
1081   2                  break;
1082   2                  
1083   2                  //--------------------------------------------------------------------------------------------
             ------------
1084   2                  // Master Receiver: Slave address + READ transmitted.  NACK received. Restart the transfer
1085   2                  //--------------------------------------------------------------------------------------------
             ------------
1086   2              case SMB_ADDR_R_TX_NACK_RX:
1087   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1088   2                  {
1089   3                      if(slaveCount < MAX_NACK_RETRY)
1090   3                      {
1091   4                          slaveCount++;                         // Increment number of attempts when NACK is received
1092   4                          STA = 1;                            // Restart transfer after receiving a NACK
1093   4                      }
1094   3                      else
1095   3                      {
1096   4                          slaveCount = 0;                         // Reset counter
1097   4                          STO = 1;
1098   4                          SMB_BUSY = 0;
1099   4                          FAIL = 1;
1100   4                      }
1101   3                  }
1102   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1103   2                  {
1104   3                      if(realTimeClockCount < MAX_NACK_RETRY)
1105   3                      {
1106   4                          realTimeClockCount++;                     // Increment number of attempts when NACK is received
1107   4                          STA = 1;                            // Restart a new transfer
1108   4                      }
1109   3                      else
1110   3                      {
1111   4                          realTimeClockCount = 0;
1112   4                          STO = 1;
1113   4                          SMB_BUSY = 0;
1114   4                          FAIL = 1;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 20  

1115   4                      }
1116   3                  }
1117   2                  else if(slaveAddr == EEPROM_ADDR)
1118   2                  {
1119   3                      if(eepromCount < MAX_NACK_RETRY)
1120   3                      {
1121   4                          eepromCount++;                          // Increment number of attempts when NACK is received
1122   4                          STA = 1;                            // Restart a new transfer
1123   4                      }
1124   3                      else
1125   3                      {
1126   4                          eepromCount = 0;
1127   4                          STO = 1;
1128   4                          SMB_BUSY = 0;
1129   4                          FAIL = 1;
1130   4                      }
1131   3                  }
1132   2                  else
1133   2                  {}
1134   2                  break;
1135   2                  
1136   2                  //--------------------------------------------------------------------------------------------
             ------------
1137   2                  // Master Receiver: Data byte received. If AA flag was set beforehand, then ACK transmitted.
1138   2                  // For a READ: receive each byte from the slave.  if this is the last byte, send a NACK and se
             -t the STOP bit
1139   2                  //--------------------------------------------------------------------------------------------
             ------------
1140   2              case SMB_DATA_RX_ACK_TX:
1141   2                  
1142   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1143   2                  {
1144   3                      if (RxCounter < numBytesRD)
1145   3                      {
1146   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1147   4                          AA = 1;                                                 // Send ACK to indicate byte recei
             -ved
1148   4                          RxCounter++;                                            // Increment the byte counter
1149   4                          slaveReadDone = 0;                        // Mark start of slave read
1150   4                      }
1151   3                      else
1152   3                      {
1153   4                          AA = 0;                                                 // Send NACK to indicate last byte
             - is received
1154   4                          slaveReadDone = 1;                        // Mark end of slave read
1155   4                      }
1156   3                  }
1157   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1158   2                  {
1159   3                      if(RxCounter < numBytesRD)
1160   3                      {
1161   4                          sharedDataRx[startAddr + RxCounter] = SMB0DAT;          // RTC
1162   4                          rtcReadDone = 0;
1163   4                          
1164   4                          AA = 1;                             // Send ACK to indicate byte received
1165   4                          RxCounter++;                          // Increment the byte counter
1166   4                      }
1167   3                      else
1168   3                      {
1169   4                          rtcReadDone = 1;
1170   4                          AA = 0;                             // Send NACK to indicate last byte is received
1171   4                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 21  

1172   3                  }
1173   2                  else if(slaveAddr == EEPROM_ADDR)
1174   2                  {
1175   3                      if(RxCounter < numBytesRD)
1176   3                      {
1177   4                          eepromDataByte = eepromRx[RxCounter] = SMB0DAT;
1178   4                          AA = 1;                             // Send ACK to indicate byte received
1179   4                          RxCounter++;                          // Increment the byte counter
1180   4                          eepromReadDone = 0;                       // Mark start of fram read
1181   4                      }
1182   3                      else
1183   3                      {
1184   4                          AA = 0;                             // Send NACK to indicate last byte is received
1185   4                          eepromReadDone = 1;                       // Mark end of fram read
1186   4                      }
1187   3                  }
1188   2                  break;
1189   2                  
1190   2                  //--------------------------------------------------------------------------------------------
             ------------
1191   2                  // Master Receiver: Data byte received. If AA flag was cleared, then NACK transmitted.
1192   2                  // For a READ: Read operation has completed.  Read data register and send STOP
1193   2                  //--------------------------------------------------------------------------------------------
             ------------
1194   2              case SMB_DATA_RX_NACK_TX:
1195   2                  if(slaveAddr == MCU_SLAVE_ADDR)
1196   2                  {
1197   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;
1198   3                      STO = 1;                              // Stop transfer
1199   3                      SMB_BUSY = 0;                           // Release SMB
1200   3                      AA = 1;
1201   3                      slaveReadDone = 1;                          // Mark end of slave read                               // Set AA for next
             - transfer
1202   3                  }
1203   2                  else if(slaveAddr == REAL_TIME_CLOCK_ADDR)
1204   2                  {
1205   3                      sharedDataRx[startAddr + RxCounter] = SMB0DAT;            // RTC
1206   3                      rtcReadDone = 1;
1207   3                      
1208   3                      STO = 1;                              // Stop transfer
1209   3                      SMB_BUSY = 0;                           // Release SMB
1210   3                      AA = 1;                               // Send ACK to indicate byte received
1211   3                  }
1212   2                  else if(slaveAddr == EEPROM_ADDR)
1213   2                  {
1214   3                      eepromRx[RxCounter] = SMB0DAT;
1215   3                      STO = 1;                              // Stop transfer
1216   3                      SMB_BUSY = 0;                           // Release SMB
1217   3                      AA = 1;
1218   3                      eepromReadDone = 1;                         // Mark end of eeprom read
1219   3                  }
1220   2                  break;
1221   2                  
1222   2                  //--------------------------------------------------------------------------------------------
             ------------
1223   2                  // Master Transmitter: Arbitration lost
1224   2                  //--------------------------------------------------------------------------------------------
             ------------
1225   2              case SMB_ARBITRATION_LOST:
1226   2                  FAIL = 1;                                                     // Indicate failed transfer
1227   2                  // and handle at end of ISR
1228   2                  break;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 22  

1229   2                  
1230   2                  //--------------------------------------------------------------------------------------------
             ------------
1231   2                  // All other status codes invalid.  Reset communication
1232   2                  //--------------------------------------------------------------------------------------------
             ------------
1233   2              default:
1234   2                  FAIL = 1;
1235   2                  break;
1236   2          }
1237   1          //----------------------------------------------------------------------------------------------------
             ----
1238   1          // If all failed, reset everything
1239   1          //----------------------------------------------------------------------------------------------------
             ----
1240   1          if(FAIL)                                                            // If the transfer failed,
1241   1          {
1242   2              SMB0CN &= ~0x40;                                                  // Reset communication
1243   2              SMB0CN |= 0x40;
1244   2              STA = 0;
1245   2              STO = 0;
1246   2              AA = 0;
1247   2              
1248   2              SMB_BUSY = 0;                                                     // Free SMBus
1249   2              
1250   2              FAIL = 0;
1251   2              // Set to finish all pending processes
1252   2              slaveWriteDone = 1;                             // Mark end of slave write
1253   2              slaveReadDone = 1;                              // Mark end of slave read
1254   2              rtcWriteDone = 1;
1255   2              rtcReadDone = 1;
1256   2              eepromWriteDone = 1;                            // Mark end of eeprom write
1257   2              eepromReadDone = 1;                             // Mark end of eeprom read
1258   2          }
1259   1          
1260   1          SI = 0;                                                             // Clear interrupt flag
1261   1      }
1262          
1263          //-------------------------------------------------------------------------------------------------------
1264          // Function Name: setClockControl
1265          // Return Value: None 
1266          // Parmeters: None
1267          // Function Description: This function sets values to the real time clock control register
1268          // Check DS3232 documentation for more details of this this control register
1269          //-------------------------------------------------------------------------------------------------------
1270          void setClockControl(void)
1271          {
1272   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL] = 0x04;
1273   1          sharedDataTx[RTC_START_ADDR + RTC_CONTROL_STATUS] = 0x30;
1274   1          writeBytesToRealTimeClock(RTC_START_ADDR + RTC_CONTROL, 2);             // Set control registers (2 byte)
1275   1      }
1276          
1277          //-------------------------------------------------------------------------------------------------------
1278          // Function Name: setClock
1279          // Return Value: None 
1280          // Parmeters: None
1281          // Function Description: This function sets the new values to the real time clock
1282          //-------------------------------------------------------------------------------------------------------
1283          void setClock(void)
1284          { 
1285   1          unsigned char hoursAux;
1286   1          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 23  

1287   1          sharedDataTx[RTC_START_ADDR + SECONDS] = convertDecimalToBCD(seconds);        // Load all data from PC to 
             -array before writing
1288   1          sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(minutes);        // All data: seconds,.... ar
             -e already converted to BCD
1289   1          sharedDataTx[RTC_START_ADDR + DAY] = convertDecimalToBCD(day);
1290   1          sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(date);
1291   1          sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(month);
1292   1          sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(year);
1293   1          
1294   1          hoursAux = convertDecimalToBCD(hours);                        // Get updated hours from user on screen
1295   1          
1296   1          hoursAux = hoursAux | 0x40;                             // Set 12/24 bit --> 12 hour mode
1297   1          
1298   1          if(amPm == 'P')
1299   1          {
1300   2              hoursAux = hoursAux | 0x60;                         // Set AM/PM bit --> PM mode
1301   2          }
1302   1          else if(amPm == 'A')
1303   1          {
1304   2              hoursAux = hoursAux & 0x5F;                         // Clear AM/PM bit --> AM mode
1305   2          }
1306   1          
1307   1          sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1308   1          
1309   1          writeBytesToRealTimeClock(RTC_START_ADDR, 7);                                       // Write 7 bytes t
             -o RTC
1310   1          
1311   1          //resetAllDisplayCounters();                              // Update new values on screen
1312   1      }     
1313          
1314          //-------------------------------------------------------------------------------------------------------
1315          // Function Name: getClockData()
1316          // Return Value: None 
1317          // Parmeters: None
1318          // Function Description: This function gets the new values from the real time clock
1319          //-------------------------------------------------------------------------------------------------------
1320          void getClockData()
1321          {
1322   1          static unsigned char previousMonth = 0;
1323   1          static unsigned char previousDate = 0;
1324   1          static unsigned char previousYear = 0;
1325   1          static unsigned char previousHours = 0;
1326   1          static unsigned char previousMinutes = 0;
1327   1          static unsigned char previousSeconds = 0;
1328   1          
1329   1          unsigned int currentIndex = 0;
1330   1          unsigned char tempHours;
1331   1          
1332   1          readBytesFromRealTimeClock(RTC_START_ADDR, 7);                    // Get date and time (7 bytes)
1333   1          
1334   1          seconds = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + SECONDS]);        // Convert BCD to decimal fo
             -r seconds (1 byte)
1335   1          minutes = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MINUTES]);        // Convert BCD to decimal fo
             -r minutes (1 byte)
1336   1          
1337   1          tempHours = sharedDataRx[RTC_START_ADDR + HOURS];                 // Get BCD without conversion and check AM/P
             -M
1338   1          
1339   1          if(tempHours & 0x40)                                // 12/24 bit (bit 6) is set --> 12 hour mode
1340   1          {
1341   2              timeMode = TWELVE_HR_MODE;
1342   2              
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 24  

1343   2              if(tempHours & 0x20)                              // PM/AM bit (bit 5) is set --> PM
1344   2              {
1345   3                  amPm = 'P';
1346   3              }
1347   2              else
1348   2              {
1349   3                  amPm = 'A';
1350   3              }
1351   2          }
1352   1          else
1353   1          {
1354   2              timeMode = TWENTY_FOUR_HR_MODE;
1355   2          }
1356   1          
1357   1          hours = convertBCDToDecimal(tempHours & 0x1F);                    // Get hours (bit 4 to bit 0 only. Ignore othe
             -rs)
1358   1          
1359   1          if(hours == 12)
1360   1          {
1361   2              if(amPm == 'A')
1362   2              {
1363   3                  hours24 = 0;
1364   3              }
1365   2              else
1366   2              {
1367   3                  hours24 = hours;
1368   3              }
1369   2          }
1370   1          else
1371   1          {
1372   2              if(amPm == 'P')
1373   2              {
1374   3                  hours24 = hours + 12;                           // Twenty four hour format if PM
1375   3              }
1376   2              else
1377   2              {
1378   3                  hours24 = hours;                              // Twenty four hour format if AM
1379   3              }
1380   2          }
1381   1          
1382   1          day = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DAY]);            // Convert BCD to decimal for day 
             -(1 byte)
1383   1          date = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + DATE]);          // Convert BCD to decimal for dat
             -e (1 byte)
1384   1          month = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + MONTH]);          // Convert BCD to decimal for m
             -onth (1 byte)
1385   1          year = convertBCDToDecimal(sharedDataRx[RTC_START_ADDR + YEAR]);          // Convert BCD to decimal for yea
             -r (1 byte)
1386   1          
1387   1          if(month != previousMonth || date != previousDate || year != previousYear)
1388   1          {
1389   2              monthDateYearUpdated = SET;
1390   2          }
1391   1          if(hours != previousHours || minutes != previousMinutes || seconds != previousSeconds)
1392   1          {
1393   2              timeUpdated = SET;
1394   2          }
1395   1          
1396   1          if(amPm == 'P')
1397   1          {
1398   2              currentIndex = ((12 + hours) * 60) + minutes;
1399   2          }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 25  

1400   1          else if(amPm == 'A')
1401   1          {
1402   2              if(hours == 12)
1403   2              {
1404   3                  hours = 0;
1405   3              }
1406   2              
1407   2              currentIndex = (hours * 60) + minutes;
1408   2          }
1409   1          else
1410   1          {}
1411   1          
1412   1          minuteIndex = currentIndex % 60;                          // Get minute index from 0 - 59
1413   1          hourIndex = currentIndex / 60;                            // Get hour index from 0 - 23
1414   1          
1415   1          previousDate = date;
1416   1          previousMonth = month;
1417   1          previousYear = year;
1418   1          previousHours = hours;
1419   1          previousMinutes = minutes;
1420   1          previousSeconds = seconds;
1421   1      }
1422          
1423          //-------------------------------------------------------------------------------------------------------
1424          // Function Name: moveDateTimeUp
1425          // Return Value: None 
1426          // Parmeters: None
1427          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he up button
1428          //-------------------------------------------------------------------------------------------------------
1429          /*
1430           void moveDateTimeUp(void)
1431           {
1432           }
1433           */
1434          
1435          //-------------------------------------------------------------------------------------------------------
1436          // Function Name: moveDateTimeDown
1437          // Return Value: None 
1438          // Parmeters: None
1439          // Function Description: This function sets date and time of the clock from the touch screen by pressing t
             -he down button
1440          //-------------------------------------------------------------------------------------------------------
1441          /*
1442           void moveDateTimeDown(void)
1443           {
1444           
1445           }
1446           */
1447          
1448          //-------------------------------------------------------------------------------------------------------
1449          // Function Name: enterDateTime
1450          // Return Value: None 
1451          // Parmeters: None
1452          // Function Description: This function confirms the date or time set by the user on the touch screen
1453          //-------------------------------------------------------------------------------------------------------
1454          /*
1455           void enterDateTime(void)
1456           {
1457           char str[SPRINTF_SIZE];
1458           
1459           realTimeClockItems++;                                // Move to next item
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 26  

1460           
1461           if(realTimeClockItems == MONTH_ADJUST)
1462           {
1463           monthUpdated = SET;
1464           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1465           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1466           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1467           }
1468           else if(realTimeClockItems == DATE_ADJUST)
1469           {
1470           dateUpdated = SET;
1471           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET DATE  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1472           sprintf(str, "%bu   ", adjustedDate);
1473           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1474           }
1475           else if(realTimeClockItems == YEAR_ADJUST)
1476           {
1477           yearUpdated = SET;
1478           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET YEAR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1479           sprintf(str, "20%02bu", adjustedYear);
1480           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1481           }
1482           else if(realTimeClockItems == HOUR_ADJUST)
1483           {
1484           hoursUpdated = SET;
1485           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET HOUR  ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1486           sprintf(str, "%bu   ", adjustedHours);
1487           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1488           }
1489           else if(realTimeClockItems == MINUTE_ADJUST)
1490           {
1491           minutesUpdated = SET;
1492           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
1493           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MINUTE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1494           sprintf(str, "%bu   ", adjustedMinutes);
1495           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1496           }
1497           else if(realTimeClockItems == AMPM_ADJUST)
1498           {
1499           amPmUpdated = SET;                               // Set it anyway because user usually does not set at the end
1500           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET AM/PM ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1501           sprintf(str, "%cM  ", adjustedAmPm);
1502           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1503           }
1504           else if(realTimeClockItems == DONE_ADJUST)
1505           {
1506           amPmUpdated = SET;                               // Set it if user explicitly press enter button
1507           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "PRESS DONE", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1508           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, "----", VALUE_DISPLAY_X, VALUE_DISPLA
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 27  

             -Y_Y);
1509           }
1510           else if(realTimeClockItems == ROLL_OVER_ADJUST)
1511           {
1512           realTimeClockItems = MONTH_ADJUST;                       // Set it for next round of real time clock items
1513           monthUpdated = SET;
1514           displayText(TITLE_DISPLAY_FG, TITLE_DISPLAY_BG, TITLE_DISPLAY_FONT, "SET MONTH ", TITLE_DISPLAY_X, TITLE_
             -DISPLAY_Y);
1515           sprintf(str, "%s ", monthOfYear[adjustedMonth]);
1516           displayText(VALUE_DISPLAY_FG, VALUE_DISPLAY_BG, VALUE_DISPLAY_FONT, str, VALUE_DISPLAY_X, VALUE_DISPLAY_Y
             -);
1517           }
1518           else
1519           {}
1520           }
1521           */
1522          
1523          //-------------------------------------------------------------------------------------------------------
1524          // Function Name: setClockOnScreen
1525          // Return Value: None 
1526          // Parmeters: None
1527          // Function Description: This function sets the real time clock on the touch screen
1528          //-------------------------------------------------------------------------------------------------------
1529          /*
1530           void setClockOnScreen(void)
1531           {
1532           unsigned char hoursAux;
1533           
1534           if(monthUpdated == SET)
1535           {
1536           sharedDataTx[RTC_START_ADDR + MONTH] = convertDecimalToBCD(adjustedMonth);   // Get updated month from use
             -r on screen
1537           writeBytesToRealTimeClock(RTC_START_ADDR + MONTH, 1);              // Set month only (1 byte)
1538           monthUpdated = CLEAR;                              //Clear flag after writing to real time clock
1539           }
1540           
1541           if(dateUpdated == SET)
1542           {
1543           sharedDataTx[RTC_START_ADDR + DATE] = convertDecimalToBCD(adjustedDate);   // Get updated date from user o
             -n screen
1544           writeBytesToRealTimeClock(RTC_START_ADDR + DATE, 1);             // Set date only (1 byte)
1545           dateUpdated = CLEAR;
1546           }
1547           
1548           if(yearUpdated == SET)
1549           {
1550           sharedDataTx[RTC_START_ADDR + YEAR] = convertDecimalToBCD(adjustedYear);   // Get updated year from user o
             -n screen
1551           writeBytesToRealTimeClock(RTC_START_ADDR + YEAR, 1);             // Set year only (1 byte)
1552           yearUpdated = CLEAR;
1553           }
1554           
1555           if(hoursUpdated == SET || amPmUpdated == SET)
1556           {
1557           hoursAux = convertDecimalToBCD(adjustedHours);                 // Get updated hours from user on screen
1558           
1559           if(amPmUpdated == SET)
1560           {
1561           amPm = adjustedAmPm;                           // Set updated amPm from user on screen
1562           
1563           hoursAux = hoursAux | 0x40;                          // Set 12/24 bit --> 12 hour mode
1564           
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 28  

1565           if(adjustedAmPm == 'P')
1566           {
1567           hoursAux = hoursAux | 0x60;                        // Set AM/PM bit --> PM mode
1568           }
1569           else if(adjustedAmPm == 'A')
1570           {
1571           hoursAux = hoursAux & 0x5F;                        // Clear AM/PM bit --> AM mode
1572           }
1573           else
1574           {}
1575           
1576           amPmUpdated = CLEAR;
1577           }
1578           
1579           sharedDataTx[RTC_START_ADDR + HOURS] = hoursAux;
1580           writeBytesToRealTimeClock(RTC_START_ADDR + HOURS, 1);              // Set hours only (1 byte)
1581           hoursUpdated = CLEAR;
1582           }
1583           
1584           if(minutesUpdated == SET)
1585           {
1586           sharedDataTx[RTC_START_ADDR + MINUTES] = convertDecimalToBCD(adjustedMinutes); // Get updated minutes fro
             -m user on screen
1587           writeBytesToRealTimeClock(RTC_START_ADDR + MINUTES, 1);              // Set minutes only (1 byte)
1588           minutesUpdated = CLEAR;
1589           }
1590           
1591           realTimeClockItems = MONTH_ADJUST;                         // Set starting item = Month for adjustment
1592           
1593           getClockData();                                      // Get current month, date, year set by user
1594           
1595           //clockSetupDisplayRepeat = 0;                           // Display clock updates on screen                                    // Syste
             -m goes back to main page
1596           }
1597           */
1598          
1599          //-------------------------------------------------------------------------------------------------------
1600          // Function Name: resetClock
1601          // Return Value: None 
1602          // Parmeters: None
1603          // Function Description: This function resets the real time clock to 0:00:00 1/1/2000
1604          //-------------------------------------------------------------------------------------------------------
1605          void resetClock(void)
1606          {
1607   1          seconds = 0;
1608   1          minutes = 0;
1609   1          hours = 0;
1610   1          amPm = 'P';
1611   1          day = 1;
1612   1          date = 1;
1613   1          month = 1;
1614   1          year = 0;
1615   1          century = 0;
1616   1          timeMode = 1;
1617   1          
1618   1          setClock();                                             // Set real time clock
1619   1      }
1620          
1621          //-------------------------------------------------------------------------------------------------------
1622          // Function Name: convertDecimalToBCD
1623          // Return Value: bcd 
1624          // Parmeters: decimal
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 29  

1625          // Function Description: This function converts a decimal number to a BCD when writing the new value to th
             -e real time clock
1626          //-------------------------------------------------------------------------------------------------------
1627          unsigned char convertDecimalToBCD(unsigned char decimal)
1628          {
1629   1          unsigned char bcd;
1630   1          
1631   1          bcd = (decimal / 10) << 4;                              // Get upper 4 bits
1632   1          bcd = bcd | (decimal % 10);                             // Get a BCD
1633   1          
1634   1          return bcd;
1635   1      }
1636          
1637          //-------------------------------------------------------------------------------------------------------
1638          // Function Name: convertBCDToDecimal
1639          // Return Value: decimal value 
1640          // Parmeters: bcd
1641          // Function Description: This function converts a BCD to a decimal number when reading the current value f
             -rom the real time clock
1642          //-------------------------------------------------------------------------------------------------------
1643          unsigned char convertBCDToDecimal(unsigned char bcd)
1644          {
1645   1          unsigned char decimal;
1646   1          
1647   1          decimal = ((bcd >> 4) * 10) + (bcd & 0x0F);                     // Combine upper and lower nibbles to get
1648   1          // 8 bit number
1649   1          return decimal;
1650   1      }
1651          
1652          //-------------------------------------------------------------------------------------------------------
1653          // Function Name: displayClock
1654          // Return Value: None 
1655          // Parmeters: None
1656          // Function Description: This function displays clock data on the touch screen
1657          // The clock format is MM/DD/YYYY hour/minute/second
1658          //-------------------------------------------------------------------------------------------------------
1659          void displayClock(void)
1660          {
1661   1          char str[SPRINTF_SIZE];
1662   1          
1663   1          //if(screen == MAIN_PAGE)
1664   1          //{
1665   1          getClockData();
1666   1          
1667   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1668   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS_DAT
             -E_Y);
1669   1          monthDateYearUpdated = CLEAR;
1670   1          
1671   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1672   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS_TIM
             -E_Y);
1673   1          //}
1674   1          /*else if(screen == CLOCK_SETUP_PAGE)
1675   1           {
1676   1           if(buttonPressed == CLEAR)
1677   1           {
1678   1           getClockData();
1679   1           
1680   1           sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month], date, year);
1681   1           displayText(DATE_DISPLAY_FG, DATE_DISPLAY_BG, DATE_DISPLAY_FONT, str, DATE_DISPLAY_X, DATE_DISPLAY_Y)
             -;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 30  

1682   1           monthDateYearUpdated = CLEAR;
1683   1           
1684   1           sprintf(str, "%2bu:%02bu:%02bu %cM ", hours, minutes, seconds, amPm);
1685   1           displayText(TIME_DISPLAY_FG, TIME_DISPLAY_BG, TIME_DISPLAY_FONT, str, TIME_DISPLAY_X, TIME_DISPLAY_Y)
             -;
1686   1           timeUpdated = CLEAR;
1687   1           }
1688   1           }*/
1689   1      }
1690          
1691          //------------------------------------------------------------------------------------------------------
1692          // Utility functions by team 1 
1693          //------------------------------------------------------------------------------------------------------
1694          
1695          void display_text(const char * fg, const char * bg, const unsigned char size, const char * message, const 
             -int x, const int y)
1696          {
1697   1          char str[128] = { 0 };
1698   1          
1699   1          int i = 0;
1700   1          while(i < 10000) i++;
1701   1          
1702   1          sprintf(str, "S %s %s\r", fg, bg);
1703   1          sendCommand(str);
1704   1          sprintf(str, "f %s\r", Font[size]);
1705   1          sendCommand(str);
1706   1          sprintf(str, "t \"%s\" %u %u\r", message, x, y);
1707   1          sendCommand(str);
1708   1      }
1709          
1710          static void send_macro(const unsigned int macro_index)
1711          {
1712   1          char str[8] = { 0 };
1713   1          
1714   1          int i = 0;
1715   1          while(i < 10000) i++;
1716   1          
1717   1          sprintf(str, "m %u\r", macro_index);
1718   1          sendCommand(str);
1719   1      }
1720          
1721          int handle_passcode(int k){
1722   1          int isValid = 0,i = 0;
1723   1          char str[SPRINTF_SIZE];
1724   1          sprintf(str, "%s", "    ");
1725   1          display_text("000000", "FFFFFF", 8, str, 240, 40);
1726   1          if(k == 0){
1727   2              passcode[0]='\0';
1728   2          }
1729   1          
1730   1          if ('1' == userCommand[1] && '4' == userCommand[2] && '1' == userCommand[3]) {
1731   2              strcat(passcode,"1");
1732   2              isValid = 1;
1733   2          }
1734   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '2' == userCommand[3]) {
1735   2              strcat(passcode,"2");
1736   2              isValid = 1;
1737   2          }
1738   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '3' == userCommand[3]) {
1739   2              strcat(passcode,"3");
1740   2              isValid = 1;
1741   2          }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 31  

1742   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '4' == userCommand[3]) {
1743   2              strcat(passcode,"4");
1744   2              isValid = 1;
1745   2          }
1746   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '5' == userCommand[3]) {
1747   2              strcat(passcode,"5");
1748   2              isValid = 1;
1749   2          }
1750   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '6' == userCommand[3]) {
1751   2              strcat(passcode,"6");
1752   2              isValid = 1;
1753   2          }
1754   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '7' == userCommand[3]) {
1755   2              strcat(passcode,"7");
1756   2              isValid = 1;
1757   2          }
1758   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '8' == userCommand[3]) {
1759   2              strcat(passcode,"8");
1760   2              isValid = 1;
1761   2          }
1762   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '9' == userCommand[3]) {
1763   2              strcat(passcode,"9");
1764   2              isValid = 1;
1765   2          }
1766   1          else if ('1' == userCommand[1] && '4' == userCommand[2] && '0' == userCommand[3]) {
1767   2              strcat(passcode,"0");
1768   2              isValid = 1;
1769   2          }
1770   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '0' == userCommand[3]) {
1771   2              strcat(passcode,"*");
1772   2              isValid = 1;
1773   2          }
1774   1          else if ('1' == userCommand[1] && '5' == userCommand[2] && '1' == userCommand[3]) {
1775   2              strcat(passcode,"#");
1776   2              isValid = 1;
1777   2          }
1778   1          if(isValid){
1779   2              str[0] = '\0';
1780   2              for(i=0;i<=k;i++){
1781   3                  strcat(str,"*");
1782   3              }
1783   2          }
1784   1          //sprintf(str, "%s", passcode);
1785   1          display_text("000000", "FFFFFF", 6, str, 240, 80);
1786   1          return isValid;
1787   1      }
1788          
1789          
1790          void display_time(unsigned char Seconds_l, unsigned char Minutes_l, unsigned char Hours_l, unsigned char A
             -mPm, unsigned char Date_l, unsigned char Month_l, unsigned char Year_l) {
1791   1          char *str;
1792   1          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[Month_l], Date_l, Year_l);
1793   1          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, SETTINGS_DATE_X, SETTINGS_DAT
             -E_Y);
1794   1          monthDateYearUpdated = CLEAR;
1795   1          
1796   1          sprintf(str, "%2bu:%02bu:%02bu %cM ", Hours_l, Minutes_l, Seconds_l, AmPm);
1797   1          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, SETTINGS_TIME_X, SETTINGS_TIM
             -E_Y);
1798   1          
1799   1      }
1800          
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 32  

1801          #define PAGE_MAIN            1
1802          #define PAGE_SETTINGS        2
1803          #define PAGE_SERVICE         3
1804          #define PAGE_CONFIG          4
1805          
1806          unsigned int set_Clock(void)
1807          {
1808   1          //154 - previous, 155 - next, 156 - enter, 157 -> value - 1, 158 -> value + 1;
1809   1          char *str;
1810   1          unsigned int screen_index = PAGE_SETTINGS;
1811   1          getClockData();
1812   1          seconds_l = seconds;
1813   1          minutes_l = minutes;
1814   1          hours_l = hours;
1815   1          amPm_l = amPm;
1816   1          date_l = date;
1817   1          month_l = month;
1818   1          year_l = year;
1819   1          
1820   1          
1821   1          set = 0;
1822   1          selection = 0;
1823   1          
1824   1          while (!set)
1825   1          {
1826   2              display_text(SETTINGS_DATE_FG, SETTINGS_DATE_BG,SETTINGS_DATE_FONT,setDateTime[selection], 370,180
             -); //menu display to set
1827   2              if (selection < 4) {
1828   3                  sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1829   3                  displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1830   3              }
1831   2              else {
1832   3                  sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1833   3                  displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1834   3              }
1835   2              while(tsCommandReceived == 0); //wait till there is a new key pressed pressed
1836   2              if ('1' == userCommand[1] && '5' == userCommand[2] && '8' == userCommand[3])// upper arrow - incre
             -ase value (158)
1837   2              {
1838   3                  switch(selection)
1839   3                  {
1840   4                  case 0 : {
1841   5                      //increase seconds
1842   5                      if (seconds_l == 59) {
1843   6                          seconds_l = 0;
1844   6                      }
1845   5                      else {
1846   6                          seconds_l += 1;
1847   6                      }
1848   5                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1849   5                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1850   5                      
1851   5                      break;
1852   5                  }
1853   4                  case 1 : {
1854   5                      //increase minutes
1855   5                      if (minutes_l == 59) {
1856   6                          minutes_l = 0;
1857   6                      }
1858   5                      else {
1859   6                          minutes_l += 1;
1860   6                      }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 33  

1861   5                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1862   5                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1863   5                      
1864   5                      
1865   5                      break;
1866   5                  }
1867   4                  case 2 : {
1868   5                      //increase hours
1869   5                      if (hours_l == 12) {
1870   6                          hours_l = 1;
1871   6                      }
1872   5                      else {
1873   6                          hours_l += 1;
1874   6                      }
1875   5                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1876   5                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1877   5                      
1878   5                      break;
1879   5                  }
1880   4                  case 3 : {
1881   5                      //changes AM / PM
1882   5                      if (amPm_l == 'P') {
1883   6                          amPm_l = 'A';
1884   6                      }
1885   5                      else {
1886   6                          amPm_l = 'P';
1887   6                      }
1888   5                      sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1889   5                      displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1890   5                      
1891   5                      break;
1892   5                  }
1893   4                  case 4 : {
1894   5                      //increase date
1895   5                      if (date_l == 31) {
1896   6                          date_l = 1;
1897   6                      }
1898   5                      else {
1899   6                          date_l += 1;
1900   6                      }
1901   5                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1902   5                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1903   5                      
1904   5                      break;
1905   5                  }
1906   4                  case 5 : {
1907   5                      //increase month
1908   5                      if (month_l == 12) {
1909   6                          month_l = 1;
1910   6                      }
1911   5                      else {
1912   6                          month_l += 1;
1913   6                      }
1914   5                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
1915   5                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1916   5                      
1917   5                      break;
1918   5                  }
1919   4                  case 6 : {
1920   5                      //increase year
1921   5                      year_l += 1;
1922   5                      sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 34  

1923   5                      displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
1924   5                      
1925   5                      break;
1926   5                  }
1927   4                  default :
1928   4                      {
1929   5                          break;
1930   5                      }
1931   4                  } //switch ends
1932   3              } //if ends
1933   2              
1934   2              else if ('1' == userCommand[1] && '5' == userCommand[2] && '7' == userCommand[3])// lower arrow - 
             -decrease value (157)
1935   2              {
1936   3                  switch(selection)
1937   3                  {
1938   4                  case 0 :
1939   4                      {
1940   5                          //decrease seconds
1941   5                          if (seconds_l == 0) {
1942   6                              seconds_l = 59;
1943   6                          }
1944   5                          else {
1945   6                              seconds_l -= 1;
1946   6                          }
1947   5                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1948   5                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1949   5                          break;
1950   5                      }
1951   4                  case 1 :
1952   4                      {
1953   5                          //decrease minutes
1954   5                          if (minutes_l == 0) {
1955   6                              minutes_l = 59;
1956   6                          }
1957   5                          else {
1958   6                              minutes_l -= 1;
1959   6                          }
1960   5                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1961   5                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1962   5                          break;
1963   5                      }
1964   4                  case 2 :
1965   4                      {
1966   5                          //decrease hours
1967   5                          if (hours_l == 0) {
1968   6                              hours_l = 12;
1969   6                          }
1970   5                          else {
1971   6                              hours_l -= 1;
1972   6                          }
1973   5                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1974   5                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1975   5                          break;
1976   5                      }
1977   4                  case 3 :
1978   4                      {
1979   5                          //changes AM / PM
1980   5                          if (amPm_l == 'P') {
1981   6                              amPm_l = 'A';
1982   6                          }
1983   5                          else {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 35  

1984   6                              amPm_l = 'P';
1985   6                          }
1986   5                          sprintf(str, "%2bu:%02bu:%02bu %cM ", hours_l, minutes_l, seconds_l, amPm_l);
1987   5                          displayText(SETTINGS_TIME_FG, SETTINGS_TIME_BG, SETTINGS_TIME_FONT, str, 365, 250);
1988   5                          break;
1989   5                      }
1990   4                  case 4 :
1991   4                      {
1992   5                          //decrease date
1993   5                          if (date_l == 1) {
1994   6                              date_l = 31;
1995   6                          }
1996   5                          else {
1997   6                              date_l -= 1;
1998   6                          }
1999   5                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2000   5                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2001   5                          
2002   5                          break;
2003   5                      }
2004   4                  case 5 :
2005   4                      {
2006   5                          //decrease month
2007   5                          if (month_l == 1) {
2008   6                              month_l = 12;
2009   6                          }
2010   5                          else {
2011   6                              month_l -= 1;
2012   6                          }
2013   5                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2014   5                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2015   5                          
2016   5                          break;
2017   5                      }
2018   4                  case 6 :
2019   4                      {
2020   5                          //decrease year
2021   5                          year_l -= 1;
2022   5                          sprintf(str, "%s %02bu, 20%02bu", monthOfYear[month_l], date_l, year_l);
2023   5                          displayText(SETTINGS_DATE_FG, SETTINGS_DATE_BG, SETTINGS_DATE_FONT, str, 365, 250);
2024   5                          
2025   5                          break;
2026   5                      }
2027   4                  default :
2028   4                      {
2029   5                          break;
2030   5                      }
2031   4                  }
2032   3              }
2033   2              
2034   2              else if ('1' == userCommand[1] && '5' == userCommand[2] && '4' == userCommand[3]) {
2035   3                  //previous in menu
2036   3                  if (selection == 0) {
2037   4                      selection = 6;
2038   4                  }
2039   3                  else {
2040   4                      selection -= 1;
2041   4                  }
2042   3                  display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2043   3              }
2044   2              else if ('1' == userCommand[1] && '5' == userCommand[2] && '5' == userCommand[3]) {
2045   3                  //next in menu
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 36  

2046   3                  if (selection == 6) {
2047   4                      selection = 0;
2048   4                  }
2049   3                  else {
2050   4                      selection += 1;
2051   4                  }
2052   3                  display_time(seconds_l, minutes_l, hours_l, amPm_l, date_l, month_l, year_l);
2053   3              }
2054   2              else if ('1' == userCommand[1] && '5' == userCommand[2] && '6' == userCommand[3]) {
2055   3                  // store the values (Enter is pressed, 156)
2056   3                  seconds = seconds_l;
2057   3                  minutes = minutes_l;
2058   3                  hours = hours_l;
2059   3                  amPm = amPm_l;
2060   3                  //day = day_l;
2061   3                  date = date_l;
2062   3                  month = month_l;
2063   3                  year = year_l;
2064   3                  set = 1;
2065   3                  setClock();                                                                            // Set 
             -real time clock
2066   3                  //enter directs to settings page where user has to enter password again
2067   3              }
2068   2              
2069   2              else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3])
2070   2              {
2071   3                  screen_index = PAGE_SETTINGS;
2072   3                  set = 1;
2073   3              }
2074   2              else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2075   3                  screen_index = PAGE_MAIN;
2076   3                  set = 1;
2077   3              }
2078   2              else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2079   3                  screen_index = PAGE_SERVICE;
2080   3                  set = 1;
2081   3              }
2082   2              
2083   2          } //end of while
2084   1          return screen_index;
2085   1      }
2086          
2087          //-------------------------------------------------------------------------------------------------------
2088          // Main
2089          //-------------------------------------------------------------------------------------------------------
2090          
2091          
2092          #define PAGE_SETTINGS_SUCCESS 5
2093          int current_page = 1;
2094          
2095          void main()
2096          {
2097   1          int i = 0;
2098   1          int count = 0;
2099   1          int prev_temp = 0;
2100   1          int display_celsius = 0;
2101   1          int state_changed = 1;
2102   1          char str[SPRINTF_SIZE];
2103   1          
2104   1          disableWatchdog();
2105   1          systemClockInit();
2106   1          portInit();
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 37  

2107   1          enableInterrupts();
2108   1          uart0Init();
2109   1          smbInit();
2110   1          timer3Init();
2111   1          
2112   1          tsLastCharGone = 1;
2113   1          tsTxOut = tsTxIn = 0;
2114   1          tsTxEmpty = 1;
2115   1          
2116   1          sprintf(str, "z\r"); //clear screen
2117   1          sendCommand(str); //clear screen
2118   1          send_macro(Splash); //startUp page
2119   1          while(i < 600) { i++;
2120   2          //sprintf(str,"%d", i);
2121   2            //  display_text("000000","FFFFFF",6,str, 240,40);
2122   2            if (i == 599){
2123   3              sprintf(str,"%d", i);
2124   3              display_text("000000","FFFFFF",6,str, 240,40);
2125   3            }
2126   2          } //wait for startup graphics to finish
2127   1          i = 0;
2128   1          //state_changed = 1;
2129   1          //current_page = PAGE_MAIN;
2130   1          
2131   1          while(1)
2132   1          {
2133   2              //scanUserInput();                                                        // Detect a string input
             - from the touch screen
2134   2              
2135   2              
2136   2              //sprintf(str,"%d", current_page);
2137   2              //display_text("000000","FFFFFF",6,str, 240,40);
2138   2              switch(current_page)
2139   2              {
2140   3                  case (PAGE_SETTINGS_SUCCESS):
2141   3                  {
2142   4                      if(state_changed)
2143   4                      {
2144   5                          state_changed = 0;
2145   5                        }
2146   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2147   5                          current_page = PAGE_SETTINGS;
2148   5                          state_changed = 1;
2149   5                          break;
2150   5                      }
2151   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2152   5                          current_page = PAGE_MAIN;
2153   5                          state_changed = 1;
2154   5                          break;
2155   5                      }
2156   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2157   5                          current_page = PAGE_SERVICE;
2158   5                          state_changed = 1;
2159   5                          break;
2160   5                      }
2161   4                      break;
2162   4                  }
2163   3                      
2164   3                  case (PAGE_SETTINGS):
2165   3                  {
2166   4                      
2167   4                      if (state_changed) {
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 38  

2168   5                            state_changed = 0;
2169   5                        send_macro(display_settings_new);
2170   5                          //clear passcode
2171   5                          passcode[0] = '\0';
2172   5                          
2173   5                        
2174   5                          
2175   5                      }
2176   4                      
2177   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2178   5                          current_page = PAGE_SETTINGS;
2179   5                          state_changed = 0;
2180   5                          break;
2181   5                      }
2182   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2183   5                          current_page = PAGE_MAIN;
2184   5                          state_changed = 1;
2185   5                          break;
2186   5                      }
2187   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2188   5                          current_page = PAGE_SERVICE;
2189   5                          state_changed = 1;
2190   5                          break;
2191   5                      }
2192   4                      else {
2193   5                          for (k = 0; k < 4 ; ){
2194   6                              
2195   6                              while(tsCommandReceived == 0);
2196   6                              if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2197   7                                  current_page = PAGE_SETTINGS;
2198   7                                  state_changed = 0;
2199   7                                  break;
2200   7                              }
2201   6                              else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) 
             -{
2202   7                                  current_page = PAGE_MAIN;
2203   7                                  state_changed = 1;
2204   7                                  break;
2205   7                              }
2206   6                              else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) 
             -{
2207   7                                  current_page = PAGE_SERVICE;
2208   7                                  state_changed = 1;
2209   7                                  break;
2210   7                              }
2211   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '3' == userCommand[3]) 
             -{
2212   7                                  if(strcmp(passcode,ACTUAL) == 0){
2213   8                                      //display_text("000000","FFFFFF",6,"OK!", 240,200);
2214   8                                      current_page = PAGE_CONFIG;
2215   8                                      state_changed = 1;
2216   8                                      send_macro(display_configuration);
2217   8                                  }
2218   7                                  else {
2219   8                                      //display_text("000000","FFFFFF",6,"INCORRECT!", 160,200);
2220   8                                      //k = 0;
2221   8                                      //sprintf(str,"%s","");
2222   8                                      //display_text("000000","FFFFFF",6,str, 240,40);
2223   8                                      k = 0;
2224   8                                      current_page = PAGE_SETTINGS;
2225   8                                      state_changed = 0;
2226   8                                  }
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 39  

2227   7                                  break;//continue;
2228   7                              }
2229   6                              else if ('1' == userCommand[1] && '5' == userCommand[2] && '2' == userCommand[3]) 
             -{
2230   7                                  size_t len = strlen(passcode);
2231   7                                  if(len > 0) passcode[len-1]=0;
2232   7                                  current_page = PAGE_SETTINGS;
2233   7                              }
2234   6                              else if(k < 4) {
2235   7                                  if(handle_passcode(k)) k++;
2236   7                                  current_page = PAGE_SETTINGS;
2237   7                              }
2238   6                              //tsCommandReceived  = 0;
2239   6                          }
2240   5                      }
2241   4                      break;
2242   4                  }
2243   3                  case (PAGE_CONFIG):
2244   3                  {
2245   4                      if (state_changed) {
2246   5                          state_changed = 0;
2247   5                          display_text("000000", "FFFFFF", 8, "cfg!", 240, 110);
2248   5                      }
2249   4                      
2250   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2251   5                          current_page = PAGE_SETTINGS;
2252   5                          state_changed = 1;
2253   5                      }
2254   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2255   5                          current_page = PAGE_MAIN;
2256   5                          state_changed = 1;
2257   5                      }
2258   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2259   5                          current_page = PAGE_SERVICE;
2260   5                          state_changed = 1;
2261   5                      }
2262   4                      else {
2263   5                          current_page = set_Clock();
2264   5                          state_changed = 1;
2265   5                      }
2266   4                      break;
2267   4                  }
2268   3                  case (PAGE_SERVICE):
2269   3                  {
2270   4                      display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2271   4                      if (state_changed) {
2272   5                          state_changed = 0;
2273   5                          display_text("000000", "FFFFFF", 8, "svc!", 240, 110);
2274   5                          send_macro(display_service);
2275   5                      }
2276   4                      
2277   4                      if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2278   5                          current_page = PAGE_SETTINGS;
2279   5                          state_changed = 1;
2280   5                      }
2281   4                      else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2282   5                          current_page = PAGE_MAIN;
2283   5                          state_changed = 1;
2284   5                      }
2285   4                      else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2286   5                          current_page = PAGE_SERVICE;
2287   5                          state_changed = 0;
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 40  

2288   5                      }
2289   4                      else {
2290   5                          // NOOP
2291   5                      }
2292   4                      break;
2293   4                  }
2294   3                  default:            // no break
2295   3                  case (PAGE_MAIN) :
2296   3                  {
2297   4                      //sprintf(str, "%d", state_changed);
2298   4                      //display_text("000000", "FFFFFF", 8, str, 240, 110);
2299   4                      roomTemp1 = readOneByteFromSlave(ROOM_TEMP_1);
2300   4                      
2301   4                      if (state_changed) {
2302   5                          state_changed = 0;
2303   5                          sprintf(str, "%-3buC", roomTemp1);
2304   5                          display_text("000000", "FFFFFF", 6, str, 240, 110);
2305   5                          send_macro(display_temperature); //main_page/ temperature display
2306   5                      }
2307   4                      
2308   4                      if (tsCommandReceived || roomTemp1 != prev_temp)
2309   4                      {
2310   5                          prev_temp = roomTemp1;
2311   5                          
2312   5                          if ('1' == userCommand[1] && '2' == userCommand[2] && '9' == userCommand[3]) {
2313   6                              display_celsius = 1;
2314   6                              sprintf(str, "%-3buC", roomTemp1);
2315   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2316   6                          }
2317   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '0' == userCommand[3]) {
2318   6                              display_celsius = 0;
2319   6                              roomTemp1 = (roomTemp1 * 9) / 5 + 32;
2320   6                              sprintf(str, "%-3buF", roomTemp1);
2321   6                              display_text("000000", "FFFFFF", 6, str, 240, 110);
2322   6                          }
2323   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '1' == userCommand[3]) {
2324   6                              current_page = PAGE_SETTINGS;
2325   6                              state_changed = 1;
2326   6                          }
2327   5                          else if ('1' == userCommand[1] && '2' == userCommand[2] && '8' == userCommand[3]) {
2328   6                              current_page = PAGE_MAIN;
2329   6                              state_changed = 0;
2330   6                          }
2331   5                          else if ('1' == userCommand[1] && '3' == userCommand[2] && '2' == userCommand[3]) {
2332   6                              current_page = PAGE_SERVICE;
2333   6                              state_changed = 1;
2334   6                          }
2335   5                          else {
2336   6                              // Noop
2337   6                          }
2338   5                      }
2339   4                      break;
2340   4                  }
2341   3              }//switch ends
2342   2          } //while ends
2343   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   8381    ----
   CONSTANT SIZE    =    731    ----
   XDATA SIZE       =   3536     807
C51 COMPILER V9.56.0.0   MAIN                                                              12/03/2017 10:15:44 PAGE 41  

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =     20       1
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
